import {
  __commonJS
} from "./chunk-AC2VUBZ6.js";

// node_modules/cos-js-sdk-v5/dist/cos-js-sdk-v5.js
var require_cos_js_sdk_v5 = __commonJS({
  "node_modules/cos-js-sdk-v5/dist/cos-js-sdk-v5.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root2, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["COS"] = factory();
      else
        root2["COS"] = factory();
    })(exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__2(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__2.m = modules;
          __webpack_require__2.c = installedModules;
          __webpack_require__2.d = function(exports2, name, getter) {
            if (!__webpack_require__2.o(exports2, name)) {
              Object.defineProperty(exports2, name, { enumerable: true, get: getter });
            }
          };
          __webpack_require__2.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
          __webpack_require__2.t = function(value, mode) {
            if (mode & 1)
              value = __webpack_require__2(value);
            if (mode & 8)
              return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule)
              return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __webpack_require__2.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string")
              for (var key in value)
                __webpack_require__2.d(ns, key, function(key2) {
                  return value[key2];
                }.bind(null, key));
            return ns;
          };
          __webpack_require__2.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__2.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__2.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__2.p = "/dist/";
          return __webpack_require__2(__webpack_require__2.s = "./index.js");
        }({
          /***/
          "./index.js": (
            /*!******************!*\
              !*** ./index.js ***!
              \******************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var COS = __webpack_require__2(
                /*! ./src/cos */
                "./src/cos.js"
              );
              module2.exports = COS;
            }
          ),
          /***/
          "./lib/base64.js": (
            /*!***********************!*\
              !*** ./lib/base64.js ***!
              \***********************/
            /*! no static exports found */
            /***/
            function(module2, exports2) {
              var Base64 = function(global2) {
                global2 = global2 || {};
                "use strict";
                var _Base64 = global2.Base64;
                var version = "2.1.9";
                var buffer2;
                var b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                var b64tab = function(bin) {
                  var t = {};
                  for (var i = 0, l = bin.length; i < l; i++)
                    t[bin.charAt(i)] = i;
                  return t;
                }(b64chars);
                var fromCharCode = String.fromCharCode;
                var cb_utob = function cb_utob2(c) {
                  if (c.length < 2) {
                    var cc = c.charCodeAt(0);
                    return cc < 128 ? c : cc < 2048 ? fromCharCode(192 | cc >>> 6) + fromCharCode(128 | cc & 63) : fromCharCode(224 | cc >>> 12 & 15) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63);
                  } else {
                    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
                    return fromCharCode(240 | cc >>> 18 & 7) + fromCharCode(128 | cc >>> 12 & 63) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | cc & 63);
                  }
                };
                var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
                var utob = function utob2(u) {
                  return u.replace(re_utob, cb_utob);
                };
                var cb_encode = function cb_encode2(ccc) {
                  var padlen = [0, 2, 1][ccc.length % 3], ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0), chars = [b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? "=" : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? "=" : b64chars.charAt(ord & 63)];
                  return chars.join("");
                };
                var btoa2 = global2.btoa ? function(b) {
                  return global2.btoa(b);
                } : function(b) {
                  return b.replace(/[\s\S]{1,3}/g, cb_encode);
                };
                var _encode = buffer2 ? function(u) {
                  return (u.constructor === buffer2.constructor ? u : new buffer2(u)).toString("base64");
                } : function(u) {
                  return btoa2(utob(u));
                };
                var encode = function encode2(u, urisafe) {
                  return !urisafe ? _encode(String(u)) : _encode(String(u)).replace(/[+\/]/g, function(m0) {
                    return m0 == "+" ? "-" : "_";
                  }).replace(/=/g, "");
                };
                var encodeURI = function encodeURI2(u) {
                  return encode(u, true);
                };
                var re_btou = new RegExp(["[À-ß][-¿]", "[à-ï][-¿]{2}", "[ð-÷][-¿]{3}"].join("|"), "g");
                var cb_btou = function cb_btou2(cccc) {
                  switch (cccc.length) {
                    case 4:
                      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
                      return fromCharCode((offset >>> 10) + 55296) + fromCharCode((offset & 1023) + 56320);
                    case 3:
                      return fromCharCode((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
                    default:
                      return fromCharCode((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
                  }
                };
                var btou = function btou2(b) {
                  return b.replace(re_btou, cb_btou);
                };
                var cb_decode = function cb_decode2(cccc) {
                  var len = cccc.length, padlen = len % 4, n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0), chars = [fromCharCode(n >>> 16), fromCharCode(n >>> 8 & 255), fromCharCode(n & 255)];
                  chars.length -= [0, 0, 2, 1][padlen];
                  return chars.join("");
                };
                var atob2 = global2.atob ? function(a) {
                  return global2.atob(a);
                } : function(a) {
                  return a.replace(/[\s\S]{1,4}/g, cb_decode);
                };
                var _decode = buffer2 ? function(a) {
                  return (a.constructor === buffer2.constructor ? a : new buffer2(a, "base64")).toString();
                } : function(a) {
                  return btou(atob2(a));
                };
                var decode = function decode2(a) {
                  return _decode(String(a).replace(/[-_]/g, function(m0) {
                    return m0 == "-" ? "+" : "/";
                  }).replace(/[^A-Za-z0-9\+\/]/g, ""));
                };
                var noConflict = function noConflict2() {
                  var Base643 = global2.Base64;
                  global2.Base64 = _Base64;
                  return Base643;
                };
                var Base642 = {
                  VERSION: version,
                  atob: atob2,
                  btoa: btoa2,
                  fromBase64: decode,
                  toBase64: encode,
                  utob,
                  encode,
                  encodeURI,
                  btou,
                  decode,
                  noConflict
                };
                return Base642;
              }();
              module2.exports = Base64;
            }
          ),
          /***/
          "./lib/beacon.min.js": (
            /*!***************************!*\
              !*** ./lib/beacon.min.js ***!
              \***************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__2;
              var _typeof2 = __webpack_require__2(
                /*! @babel/runtime/helpers/typeof */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              );
              !function(t, e) {
                "object" == (false ? void 0 : _typeof2(exports2)) && "undefined" != typeof module2 ? module2.exports = e() : true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = e, __WEBPACK_AMD_DEFINE_RESULT__2 = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.call(exports2, __webpack_require__2, exports2, module2) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__2 !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__2)) : void 0;
              }(this, function() {
                "use strict";
                var _t = function t(e, n2) {
                  return _t = Object.setPrototypeOf || {
                    __proto__: []
                  } instanceof Array && function(t2, e2) {
                    t2.__proto__ = e2;
                  } || function(t2, e2) {
                    for (var n3 in e2)
                      Object.prototype.hasOwnProperty.call(e2, n3) && (t2[n3] = e2[n3]);
                  }, _t(e, n2);
                };
                var _e = function e() {
                  return _e = Object.assign || function(t) {
                    for (var e2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
                      for (var o2 in e2 = arguments[n2])
                        Object.prototype.hasOwnProperty.call(e2, o2) && (t[o2] = e2[o2]);
                    return t;
                  }, _e.apply(this, arguments);
                };
                function n(t, e, n2, r2) {
                  return new (n2 || (n2 = Promise))(function(o2, i2) {
                    function s2(t2) {
                      try {
                        u2(r2.next(t2));
                      } catch (t3) {
                        i2(t3);
                      }
                    }
                    function a2(t2) {
                      try {
                        u2(r2.throw(t2));
                      } catch (t3) {
                        i2(t3);
                      }
                    }
                    function u2(t2) {
                      var e2;
                      t2.done ? o2(t2.value) : (e2 = t2.value, e2 instanceof n2 ? e2 : new n2(function(t3) {
                        t3(e2);
                      })).then(s2, a2);
                    }
                    u2((r2 = r2.apply(t, e || [])).next());
                  });
                }
                function r(t, e) {
                  var n2, r2, o2, i2, s2 = {
                    label: 0,
                    sent: function sent() {
                      if (1 & o2[0])
                        throw o2[1];
                      return o2[1];
                    },
                    trys: [],
                    ops: []
                  };
                  return i2 = {
                    next: a2(0),
                    throw: a2(1),
                    return: a2(2)
                  }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
                    return this;
                  }), i2;
                  function a2(i3) {
                    return function(a3) {
                      return function(i4) {
                        if (n2)
                          throw new TypeError("Generator is already executing.");
                        for (; s2; )
                          try {
                            if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done)
                              return o2;
                            switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
                              case 0:
                              case 1:
                                o2 = i4;
                                break;
                              case 4:
                                return s2.label++, {
                                  value: i4[1],
                                  done: false
                                };
                              case 5:
                                s2.label++, r2 = i4[1], i4 = [0];
                                continue;
                              case 7:
                                i4 = s2.ops.pop(), s2.trys.pop();
                                continue;
                              default:
                                if (!(o2 = s2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                                  s2 = 0;
                                  continue;
                                }
                                if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                                  s2.label = i4[1];
                                  break;
                                }
                                if (6 === i4[0] && s2.label < o2[1]) {
                                  s2.label = o2[1], o2 = i4;
                                  break;
                                }
                                if (o2 && s2.label < o2[2]) {
                                  s2.label = o2[2], s2.ops.push(i4);
                                  break;
                                }
                                o2[2] && s2.ops.pop(), s2.trys.pop();
                                continue;
                            }
                            i4 = e.call(t, s2);
                          } catch (t2) {
                            i4 = [6, t2], r2 = 0;
                          } finally {
                            n2 = o2 = 0;
                          }
                        if (5 & i4[0])
                          throw i4[1];
                        return {
                          value: i4[0] ? i4[1] : void 0,
                          done: true
                        };
                      }([i3, a3]);
                    };
                  }
                }
                var o = "__BEACON_", i = "__BEACON_deviceId", s = "last_report_time", a = "sending_event_ids", u = "beacon_config", c = "beacon_config_request_time", l = function() {
                  function t() {
                    var t2 = this;
                    this.emit = function(e, n2) {
                      if (t2) {
                        var r2, o2 = t2.__EventsList[e];
                        if (null == o2 ? void 0 : o2.length) {
                          o2 = o2.slice();
                          for (var i2 = 0; i2 < o2.length; i2++) {
                            r2 = o2[i2];
                            try {
                              var s2 = r2.callback.apply(t2, [n2]);
                              if (1 === r2.type && t2.remove(e, r2.callback), false === s2)
                                break;
                            } catch (t3) {
                              throw t3;
                            }
                          }
                        }
                        return t2;
                      }
                    }, this.__EventsList = {};
                  }
                  return t.prototype.indexOf = function(t2, e) {
                    for (var n2 = 0; n2 < t2.length; n2++)
                      if (t2[n2].callback === e)
                        return n2;
                    return -1;
                  }, t.prototype.on = function(t2, e, n2) {
                    if (void 0 === n2 && (n2 = 0), this) {
                      var r2 = this.__EventsList[t2];
                      if (r2 || (r2 = this.__EventsList[t2] = []), -1 === this.indexOf(r2, e)) {
                        var o2 = {
                          name: t2,
                          type: n2 || 0,
                          callback: e
                        };
                        return r2.push(o2), this;
                      }
                      return this;
                    }
                  }, t.prototype.one = function(t2, e) {
                    this.on(t2, e, 1);
                  }, t.prototype.remove = function(t2, e) {
                    if (this) {
                      var n2 = this.__EventsList[t2];
                      if (!n2)
                        return null;
                      if (!e) {
                        try {
                          delete this.__EventsList[t2];
                        } catch (t3) {
                        }
                        return null;
                      }
                      if (n2.length) {
                        var r2 = this.indexOf(n2, e);
                        n2.splice(r2, 1);
                      }
                      return this;
                    }
                  }, t;
                }();
                function p(t, e) {
                  for (var n2 = {}, r2 = 0, o2 = Object.keys(t); r2 < o2.length; r2++) {
                    var i2 = o2[r2], s2 = t[i2];
                    if ("string" == typeof s2)
                      n2[h(i2)] = h(s2);
                    else {
                      if (e)
                        throw new Error("value mast be string  !!!!");
                      n2[h(String(i2))] = h(String(s2));
                    }
                  }
                  return n2;
                }
                function h(t) {
                  if ("string" != typeof t)
                    return t;
                  try {
                    return t.replace(new RegExp("\\|", "g"), "%7C").replace(new RegExp("\\&", "g"), "%26").replace(new RegExp("\\=", "g"), "%3D").replace(new RegExp("\\+", "g"), "%2B");
                  } catch (t2) {
                    return "";
                  }
                }
                function f(t) {
                  return String(t.A99) + String(t.A100);
                }
                var d = function d2() {
                };
                var v = function() {
                  function t(t2) {
                    var n2 = this;
                    this.lifeCycle = new l(), this.uploadJobQueue = [], this.additionalParams = {}, this.delayTime = 0, this._normalLogPipeline = function(t3) {
                      if (!t3 || !t3.reduce || !t3.length)
                        throw new TypeError("createPipeline 方法需要传入至少有一个 pipe 的数组");
                      return 1 === t3.length ? function(e, n3) {
                        t3[0](e, n3 || d);
                      } : t3.reduce(function(t4, e) {
                        return function(n3, r2) {
                          return void 0 === r2 && (r2 = d), t4(n3, function(t5) {
                            return null == e ? void 0 : e(t5, r2);
                          });
                        };
                      });
                    }([function(t3) {
                      n2.send({
                        url: n2.strategy.getUploadUrl(),
                        data: t3,
                        method: "post",
                        contentType: "application/json;charset=UTF-8"
                      }, function() {
                        var e = n2.config.onReportSuccess;
                        "function" == typeof e && e(JSON.stringify(t3.events));
                      }, function() {
                        var e = n2.config.onReportFail;
                        "function" == typeof e && e(JSON.stringify(t3.events));
                      });
                    }]), function(t3, e) {
                      if (!t3)
                        throw e instanceof Error ? e : new Error(e);
                    }(Boolean(t2.appkey), "appkey must be initial"), this.config = _e({}, t2);
                  }
                  return t.prototype.onUserAction = function(t2, e) {
                    this.preReport(t2, e, false);
                  }, t.prototype.onDirectUserAction = function(t2, e) {
                    this.preReport(t2, e, true);
                  }, t.prototype.preReport = function(t2, e, n2) {
                    t2 ? this.strategy.isEventUpOnOff() && (this.strategy.isBlackEvent(t2) || this.strategy.isSampleEvent(t2) || this.onReport(t2, e, n2)) : this.errorReport.reportError("602", " no eventCode");
                  }, t.prototype.addAdditionalParams = function(t2) {
                    for (var e = 0, n2 = Object.keys(t2); e < n2.length; e++) {
                      var r2 = n2[e];
                      this.additionalParams[r2] = t2[r2];
                    }
                  }, t.prototype.setChannelId = function(t2) {
                    this.commonInfo.channelID = String(t2);
                  }, t.prototype.setOpenId = function(t2) {
                    this.commonInfo.openid = String(t2);
                  }, t.prototype.setUnionid = function(t2) {
                    this.commonInfo.unid = String(t2);
                  }, t.prototype.getDeviceId = function() {
                    return this.commonInfo.deviceId;
                  }, t.prototype.getCommonInfo = function() {
                    return this.commonInfo;
                  }, t.prototype.removeSendingId = function(t2) {
                    try {
                      var e = JSON.parse(this.storage.getItem(a)), n2 = e.indexOf(t2);
                      -1 != n2 && (e.splice(n2, 1), this.storage.setItem(a, JSON.stringify(e)));
                    } catch (t3) {
                    }
                  }, t;
                }(), g = function() {
                  function t(t2, e, n2, r2) {
                    this.requestParams = {}, this.network = r2, this.requestParams.attaid = "00400014144", this.requestParams.token = "6478159937", this.requestParams.product_id = t2.appkey, this.requestParams.platform = n2, this.requestParams.uin = e.deviceId, this.requestParams.model = "", this.requestParams.os = n2, this.requestParams.app_version = t2.appVersion, this.requestParams.sdk_version = e.sdkVersion, this.requestParams.error_stack = "", this.uploadUrl = t2.isOversea ? "https://htrace.wetvinfo.com/kv" : "https://h.trace.qq.com/kv";
                  }
                  return t.prototype.reportError = function(t2, e) {
                    this.requestParams._dc = Math.random(), this.requestParams.error_msg = e, this.requestParams.error_code = t2, this.network.get(this.uploadUrl, {
                      params: this.requestParams
                    }).catch(function(t3) {
                    });
                  }, t;
                }(), y = function() {
                  function t(t2, e, n2, r2, o2) {
                    this.strategy = {
                      isEventUpOnOff: true,
                      httpsUploadUrl: "https://otheve.beacon.qq.com/analytics/v2_upload",
                      requestInterval: 30,
                      blacklist: [],
                      samplelist: []
                    }, this.realSample = {}, this.appkey = "", this.needQueryConfig = true, this.appkey = e.appkey, this.storage = r2, this.needQueryConfig = t2;
                    try {
                      var i2 = JSON.parse(this.storage.getItem(u));
                      i2 && this.processData(i2);
                    } catch (t3) {
                    }
                    e.isOversea && (this.strategy.httpsUploadUrl = "https://svibeacon.onezapp.com/analytics/v2_upload"), !e.isOversea && this.needRequestConfig() && this.requestConfig(e.appVersion, n2, o2);
                  }
                  return t.prototype.requestConfig = function(t2, e, n2) {
                    var r2 = this;
                    this.storage.setItem(c, Date.now().toString()), n2.post("https://oth.str.beacon.qq.com/trpc.beacon.configserver.BeaconConfigService/QueryConfig", {
                      platformId: "undefined" == typeof wx ? "3" : "4",
                      mainAppKey: this.appkey,
                      appVersion: t2,
                      sdkVersion: e.sdkVersion,
                      osVersion: e.userAgent,
                      model: "",
                      packageName: "",
                      params: {
                        A3: e.deviceId
                      }
                    }).then(function(t3) {
                      if (0 == t3.data.ret)
                        try {
                          var e2 = JSON.parse(t3.data.beaconConfig);
                          e2 && (r2.processData(e2), r2.storage.setItem(u, t3.data.beaconConfig));
                        } catch (t4) {
                        }
                      else
                        r2.processData(null), r2.storage.setItem(u, "");
                    }).catch(function(t3) {
                    });
                  }, t.prototype.processData = function(t2) {
                    var e, n2, r2, o2, i2;
                    this.strategy.isEventUpOnOff = null !== (e = null == t2 ? void 0 : t2.isEventUpOnOff) && void 0 !== e ? e : this.strategy.isEventUpOnOff, this.strategy.httpsUploadUrl = null !== (n2 = null == t2 ? void 0 : t2.httpsUploadUrl) && void 0 !== n2 ? n2 : this.strategy.httpsUploadUrl, this.strategy.requestInterval = null !== (r2 = null == t2 ? void 0 : t2.requestInterval) && void 0 !== r2 ? r2 : this.strategy.requestInterval, this.strategy.blacklist = null !== (o2 = null == t2 ? void 0 : t2.blacklist) && void 0 !== o2 ? o2 : this.strategy.blacklist, this.strategy.samplelist = null !== (i2 = null == t2 ? void 0 : t2.samplelist) && void 0 !== i2 ? i2 : this.strategy.samplelist;
                    for (var s2 = 0, a2 = this.strategy.samplelist; s2 < a2.length; s2++) {
                      var u2 = a2[s2].split(",");
                      2 == u2.length && (this.realSample[u2[0]] = u2[1]);
                    }
                  }, t.prototype.needRequestConfig = function() {
                    if (!this.needQueryConfig)
                      return false;
                    var t2 = Number(this.storage.getItem(c));
                    return Date.now() - t2 > 60 * this.strategy.requestInterval * 1e3;
                  }, t.prototype.getUploadUrl = function() {
                    return this.strategy.httpsUploadUrl + "?appkey=" + this.appkey;
                  }, t.prototype.isBlackEvent = function(t2) {
                    return -1 != this.strategy.blacklist.indexOf(t2);
                  }, t.prototype.isEventUpOnOff = function() {
                    return this.strategy.isEventUpOnOff;
                  }, t.prototype.isSampleEvent = function(t2) {
                    return !!Object.prototype.hasOwnProperty.call(this.realSample, t2) && this.realSample[t2] < Math.floor(Math.random() * Math.floor(1e4));
                  }, t;
                }(), m = "session_storage_key", w = function() {
                  function t(t2, e, n2) {
                    this.getSessionStackDepth = 0, this.beacon = n2, this.storage = t2, this.duration = e, this.appkey = n2.config.appkey;
                  }
                  return t.prototype.getSession = function() {
                    this.getSessionStackDepth += 1;
                    var t2 = this.storage.getItem(m);
                    if (!t2)
                      return this.createSession();
                    var e = "", n2 = 0;
                    try {
                      var r2 = JSON.parse(t2) || {
                        sessionId: void 0,
                        sessionStart: void 0
                      };
                      if (!r2.sessionId || !r2.sessionStart)
                        return this.createSession();
                      var o2 = Number(this.storage.getItem(s));
                      if (Date.now() - o2 > this.duration)
                        return this.createSession();
                      e = r2.sessionId, n2 = r2.sessionStart, this.getSessionStackDepth = 0;
                    } catch (t3) {
                    }
                    return {
                      sessionId: e,
                      sessionStart: n2
                    };
                  }, t.prototype.createSession = function() {
                    var t2 = Date.now(), e = {
                      sessionId: this.appkey + "_" + t2.toString(),
                      sessionStart: t2
                    };
                    this.storage.setItem(m, JSON.stringify(e)), this.storage.setItem(s, t2.toString());
                    var n2 = "is_new_user", r2 = this.storage.getItem(n2);
                    return this.getSessionStackDepth <= 1 && this.beacon.onDirectUserAction("rqd_applaunched", {
                      A21: r2 ? "N" : "Y"
                    }), this.storage.setItem(n2, JSON.stringify(false)), e;
                  }, t;
                }();
                function b() {
                  var t = navigator.userAgent, e = t.indexOf("compatible") > -1 && t.indexOf("MSIE") > -1, n2 = t.indexOf("Edge") > -1 && !e, r2 = t.indexOf("Trident") > -1 && t.indexOf("rv:11.0") > -1;
                  if (e) {
                    new RegExp("MSIE (\\d+\\.\\d+);").test(t);
                    var o2 = parseFloat(RegExp.$1);
                    return 7 == o2 ? 7 : 8 == o2 ? 8 : 9 == o2 ? 9 : 10 == o2 ? 10 : 6;
                  }
                  return n2 ? -2 : r2 ? 11 : -1;
                }
                function S(t, e) {
                  var n2, r2;
                  return (n2 = "https://tun-cos-1258344701.file.myqcloud.com/fp.js", void 0 === r2 && (r2 = Date.now() + "-" + Math.random()), new Promise(function(t2, e2) {
                    if (document.getElementById(r2))
                      t2(void 0);
                    else {
                      var o2 = document.getElementsByTagName("head")[0], i2 = document.createElement("script");
                      i2.onload = function() {
                        return function() {
                          i2.onload = null, t2(void 0);
                        };
                      }, i2.onerror = function(t3) {
                        i2.onerror = null, o2.removeChild(i2), e2(t3);
                      }, i2.src = n2, i2.id = r2, o2.appendChild(i2);
                    }
                  })).then(function() {
                    new Fingerprint().getQimei36(t, e);
                  }).catch(function(t2) {
                  }), "";
                }
                var _I = function I() {
                  return (_I = Object.assign || function(t) {
                    for (var e, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
                      for (var o2 in e = arguments[n2])
                        Object.prototype.hasOwnProperty.call(e, o2) && (t[o2] = e[o2]);
                    return t;
                  }).apply(this, arguments);
                };
                var E, k = function() {
                  function t(t2, e) {
                    void 0 === e && (e = {}), this.reportOptions = {}, this.config = t2, this.reportOptions = e;
                  }
                  return t.canUseDB = function() {
                    return !!(null === window || void 0 === window ? void 0 : window.indexedDB);
                  }, t.prototype.openDB = function() {
                    var e = this;
                    return new Promise(function(n2, r2) {
                      if (!t.canUseDB())
                        return r2({
                          message: "当前不支持 indexeddb"
                        });
                      var o2 = e.config, i2 = o2.name, s2 = o2.version, a2 = o2.stores, u2 = indexedDB.open(i2, s2);
                      u2.onsuccess = function() {
                        e.db = u2.result, n2(), _I({
                          result: 1,
                          func: "open",
                          params: JSON.stringify(e.config)
                        }, e.reportOptions);
                      }, u2.onerror = function(t2) {
                        var n3, o3;
                        r2(t2), _I({
                          result: 0,
                          func: "open",
                          params: JSON.stringify(e.config),
                          error_msg: null === (o3 = null === (n3 = t2.target) || void 0 === n3 ? void 0 : n3.error) || void 0 === o3 ? void 0 : o3.message
                        }, e.reportOptions);
                      }, u2.onupgradeneeded = function() {
                        e.db = u2.result;
                        try {
                          null == a2 || a2.forEach(function(t2) {
                            e.createStore(t2);
                          });
                        } catch (t2) {
                          _I({
                            result: 0,
                            func: "open",
                            params: JSON.stringify(e.config),
                            error_msg: t2.message
                          }, e.reportOptions), r2(t2);
                        }
                      };
                    });
                  }, t.prototype.useStore = function(t2) {
                    return this.storeName = t2, this;
                  }, t.prototype.deleteDB = function() {
                    var t2 = this;
                    return this.closeDB(), new Promise(function(e, n2) {
                      var r2 = indexedDB.deleteDatabase(t2.config.name);
                      r2.onsuccess = function() {
                        return e();
                      }, r2.onerror = n2;
                    });
                  }, t.prototype.closeDB = function() {
                    var t2;
                    null === (t2 = this.db) || void 0 === t2 || t2.close(), this.db = null;
                  }, t.prototype.getStoreCount = function() {
                    var t2 = this;
                    return new Promise(function(e, n2) {
                      var r2 = t2.getStore("readonly").count();
                      r2.onsuccess = function() {
                        return e(r2.result);
                      }, r2.onerror = n2;
                    });
                  }, t.prototype.clearStore = function() {
                    var t2 = this;
                    return new Promise(function(e, n2) {
                      var r2 = t2.getStore("readwrite").clear();
                      r2.onsuccess = function() {
                        return e();
                      }, r2.onerror = n2;
                    });
                  }, t.prototype.add = function(t2, e) {
                    var n2 = this;
                    return new Promise(function(r2, o2) {
                      var i2 = n2.getStore("readwrite").add(t2, e);
                      i2.onsuccess = function() {
                        r2(i2.result);
                      }, i2.onerror = o2;
                    });
                  }, t.prototype.put = function(t2, e) {
                    var n2 = this;
                    return new Promise(function(r2, o2) {
                      var i2 = n2.getStore("readwrite").put(t2, e);
                      i2.onsuccess = function() {
                        r2(i2.result);
                      }, i2.onerror = o2;
                    });
                  }, t.prototype.getStoreAllData = function() {
                    var t2 = this;
                    return new Promise(function(e, n2) {
                      var r2 = t2.getStore("readonly").openCursor(), o2 = [];
                      r2.onsuccess = function() {
                        var t3;
                        if (null === (t3 = r2.result) || void 0 === t3 ? void 0 : t3.value) {
                          var n3 = r2.result.value;
                          o2.push(n3), r2.result.continue();
                        } else
                          e(o2);
                      }, r2.onerror = n2;
                    });
                  }, t.prototype.getDataRangeByIndex = function(t2, e, n2, r2, o2) {
                    var i2 = this;
                    return new Promise(function(s2, a2) {
                      var u2 = i2.getStore().index(t2), c2 = IDBKeyRange.bound(e, n2, r2, o2), l2 = [], p2 = u2.openCursor(c2);
                      p2.onsuccess = function() {
                        var t3;
                        (null === (t3 = null == p2 ? void 0 : p2.result) || void 0 === t3 ? void 0 : t3.value) ? (l2.push(null == p2 ? void 0 : p2.result.value), null == p2 || p2.result.continue()) : s2(l2);
                      }, p2.onerror = a2;
                    });
                  }, t.prototype.removeDataByIndex = function(t2, e, n2, r2, o2) {
                    var i2 = this;
                    return new Promise(function(s2, a2) {
                      var u2 = i2.getStore("readwrite").index(t2), c2 = IDBKeyRange.bound(e, n2, r2, o2), l2 = u2.openCursor(c2), p2 = 0;
                      l2.onsuccess = function(t3) {
                        var e2 = t3.target.result;
                        e2 ? (p2 += 1, e2.delete(), e2.continue()) : s2(p2);
                      }, l2.onerror = a2;
                    });
                  }, t.prototype.createStore = function(t2) {
                    var e = t2.name, n2 = t2.indexes, r2 = void 0 === n2 ? [] : n2, o2 = t2.options;
                    if (this.db) {
                      this.db.objectStoreNames.contains(e) && this.db.deleteObjectStore(e);
                      var i2 = this.db.createObjectStore(e, o2);
                      r2.forEach(function(t3) {
                        i2.createIndex(t3.indexName, t3.keyPath, t3.options);
                      });
                    }
                  }, t.prototype.getStore = function(t2) {
                    var e;
                    return void 0 === t2 && (t2 = "readonly"), null === (e = this.db) || void 0 === e ? void 0 : e.transaction(this.storeName, t2).objectStore(this.storeName);
                  }, t;
                }(), O = "event_table_v3", C = "eventId", D = function() {
                  function t(t2) {
                    this.isReady = false, this.taskQueue = Promise.resolve(), this.db = new k({
                      name: "Beacon_" + t2 + "_V3",
                      version: 1,
                      stores: [{
                        name: O,
                        options: {
                          keyPath: C
                        },
                        indexes: [{
                          indexName: C,
                          keyPath: C,
                          options: {
                            unique: true
                          }
                        }]
                      }]
                    }), this.open();
                  }
                  return t.prototype.getCount = function() {
                    var t2 = this;
                    return this.readyExec(function() {
                      return t2.db.getStoreCount();
                    });
                  }, t.prototype.setItem = function(t2, e) {
                    var n2 = this;
                    return this.readyExec(function() {
                      return n2.db.add({
                        eventId: t2,
                        value: e
                      });
                    });
                  }, t.prototype.getItem = function(t2) {
                    return n(this, void 0, void 0, function() {
                      var e = this;
                      return r(this, function(n2) {
                        return [2, this.readyExec(function() {
                          return e.db.getDataRangeByIndex(C, t2, t2);
                        })];
                      });
                    });
                  }, t.prototype.removeItem = function(t2) {
                    var e = this;
                    return this.readyExec(function() {
                      return e.db.removeDataByIndex(C, t2, t2);
                    });
                  }, t.prototype.updateItem = function(t2, e) {
                    var n2 = this;
                    return this.readyExec(function() {
                      return n2.db.put({
                        eventId: t2,
                        value: e
                      });
                    });
                  }, t.prototype.iterate = function(t2) {
                    var e = this;
                    return this.readyExec(function() {
                      return e.db.getStoreAllData().then(function(e2) {
                        e2.forEach(function(e3) {
                          t2(e3.value);
                        });
                      });
                    });
                  }, t.prototype.open = function() {
                    return n(this, void 0, void 0, function() {
                      var t2 = this;
                      return r(this, function(e) {
                        switch (e.label) {
                          case 0:
                            return this.taskQueue = this.taskQueue.then(function() {
                              return t2.db.openDB();
                            }), [4, this.taskQueue];
                          case 1:
                            return e.sent(), this.isReady = true, this.db.useStore(O), [2];
                        }
                      });
                    });
                  }, t.prototype.readyExec = function(t2) {
                    return this.isReady ? t2() : (this.taskQueue = this.taskQueue.then(function() {
                      return t2();
                    }), this.taskQueue);
                  }, t;
                }(), x = function() {
                  function t(t2) {
                    this.keyObject = {}, this.storage = t2;
                  }
                  return t.prototype.getCount = function() {
                    return this.storage.getStoreCount();
                  }, t.prototype.removeItem = function(t2) {
                    this.storage.removeItem(t2), delete this.keyObject[t2];
                  }, t.prototype.setItem = function(t2, e) {
                    var n2 = JSON.stringify(e);
                    this.storage.setItem(t2, n2), this.keyObject[t2] = e;
                  }, t.prototype.iterate = function(t2) {
                    for (var e = Object.keys(this.keyObject), n2 = 0; n2 < e.length; n2++) {
                      var r2 = this.storage.getItem(e[n2]);
                      t2(JSON.parse(r2));
                    }
                  }, t;
                }(), _ = function() {
                  function t(t2, e) {
                    var n2 = this;
                    this.dbEventCount = 0, b() > 0 || !window.indexedDB || /X5Lite/.test(navigator.userAgent) ? (this.store = new x(e), this.dbEventCount = this.store.getCount()) : (this.store = new D(t2), this.getCount().then(function(t3) {
                      n2.dbEventCount = t3;
                    }).catch(function(t3) {
                    }));
                  }
                  return t.prototype.getCount = function() {
                    return n(this, void 0, void 0, function() {
                      return r(this, function(t2) {
                        switch (t2.label) {
                          case 0:
                            return t2.trys.push([0, 2, , 3]), [4, this.store.getCount()];
                          case 1:
                            return [2, t2.sent()];
                          case 2:
                            return t2.sent(), [2, Promise.reject()];
                          case 3:
                            return [2];
                        }
                      });
                    });
                  }, t.prototype.insertEvent = function(t2, e) {
                    return n(this, void 0, void 0, function() {
                      var n2, o2;
                      return r(this, function(r2) {
                        switch (r2.label) {
                          case 0:
                            if (this.dbEventCount >= 1e4)
                              return [2, Promise.reject()];
                            n2 = f(t2.mapValue), r2.label = 1;
                          case 1:
                            return r2.trys.push([1, 3, , 4]), this.dbEventCount++, [4, this.store.setItem(n2, t2)];
                          case 2:
                            return [2, r2.sent()];
                          case 3:
                            return o2 = r2.sent(), e && e(o2, t2), this.dbEventCount--, [2, Promise.reject()];
                          case 4:
                            return [2];
                        }
                      });
                    });
                  }, t.prototype.getEvents = function() {
                    return n(this, void 0, void 0, function() {
                      var t2;
                      return r(this, function(e) {
                        switch (e.label) {
                          case 0:
                            t2 = [], e.label = 1;
                          case 1:
                            return e.trys.push([1, 3, , 4]), [4, this.store.iterate(function(e2) {
                              t2.push(e2);
                            })];
                          case 2:
                            return e.sent(), [2, Promise.all(t2)];
                          case 3:
                            return e.sent(), [2, Promise.all(t2)];
                          case 4:
                            return [2];
                        }
                      });
                    });
                  }, t.prototype.removeEvent = function(t2) {
                    return n(this, void 0, void 0, function() {
                      var e;
                      return r(this, function(n2) {
                        switch (n2.label) {
                          case 0:
                            e = f(t2.mapValue), n2.label = 1;
                          case 1:
                            return n2.trys.push([1, 3, , 4]), this.dbEventCount--, [4, this.store.removeItem(e)];
                          case 2:
                            return [2, n2.sent()];
                          case 3:
                            return n2.sent(), this.dbEventCount++, [2, Promise.reject()];
                          case 4:
                            return [2];
                        }
                      });
                    });
                  }, t;
                }(), _P = function P() {
                  return (_P = Object.assign || function(t) {
                    for (var e, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
                      for (var o2 in e = arguments[n2])
                        Object.prototype.hasOwnProperty.call(e, o2) && (t[o2] = e[o2]);
                    return t;
                  }).apply(this, arguments);
                };
                function T(t) {
                  try {
                    return decodeURIComponent(t.replace(/\+/g, " "));
                  } catch (t2) {
                    return null;
                  }
                }
                function U(t, e) {
                  var n2 = [null, void 0, "", NaN].includes(t);
                  if (e.isSkipEmpty && n2)
                    return null;
                  var r2 = !e.isSkipEmpty && n2 ? "" : t;
                  try {
                    return e.encode ? encodeURIComponent(r2) : r2;
                  } catch (t2) {
                    return null;
                  }
                }
                function N(t, e) {
                  void 0 === e && (e = {
                    encode: true,
                    isSkipEmpty: false
                  });
                  var n2 = t.url, r2 = t.query, o2 = void 0 === r2 ? {} : r2, i2 = t.hash, s2 = n2.split("#"), a2 = s2[0], u2 = s2[1], c2 = void 0 === u2 ? "" : u2, l2 = a2.split("?")[0], p2 = [], h2 = U(i2 || c2, e), f2 = _P(_P({}, function(t2) {
                    var e2 = t2.split("#"), n3 = e2[0], r3 = e2[1], o3 = void 0 === r3 ? "" : r3, i3 = n3.split("?"), s3 = i3[0], a3 = i3[1], u3 = void 0 === a3 ? "" : a3, c3 = T(o3), l3 = /* @__PURE__ */ Object.create(null);
                    return u3.split("&").forEach(function(t3) {
                      var e3 = t3.split("="), n4 = e3[0], r4 = e3[1], o4 = void 0 === r4 ? "" : r4, i4 = T(n4), s4 = T(o4);
                      null === i4 || null === s4 || "" === i4 && "" === s4 || l3[i4] || (l3[i4] = s4);
                    }), {
                      url: s3,
                      query: l3,
                      hash: c3
                    };
                  }(n2).query), o2);
                  return Object.keys(f2).forEach(function(t2) {
                    var n3 = U(t2, e), r3 = U(f2[t2], e);
                    null !== n3 && null !== r3 && p2.push(n3 + "=" + r3);
                  }), l2 + (p2.length ? "?" + p2.join("&") : "") + (h2 ? "#" + h2 : "");
                }
                function j(t, e) {
                  return new Promise(function(n2, r2) {
                    if (e && document.querySelectorAll("script[data-tag=" + e + "]").length)
                      return n2();
                    var o2 = document.createElement("script"), i2 = _P({
                      type: "text/javascript",
                      charset: "utf-8"
                    }, t);
                    Object.keys(i2).forEach(function(t2) {
                      return function(t3, e2, n3) {
                        if (t3)
                          return void 0 === n3 ? t3.getAttribute(e2) : t3.setAttribute(e2, n3);
                      }(o2, t2, i2[t2]);
                    }), e && (o2.dataset.tag = e), o2.onload = function() {
                      return n2();
                    }, o2.onreadystatechange = function() {
                      var t2 = o2.readyState;
                      ["complete", "loaded"].includes(t2) && (o2.onreadystatechange = null, n2());
                    }, o2.onerror = r2, document.body.appendChild(o2);
                  });
                }
                !function(t) {
                  t[t.equal = 0] = "equal", t[t.low = -1] = "low", t[t.high = 1] = "high";
                }(E || (E = {}));
                var _q = function q() {
                  return (_q = Object.assign || function(t) {
                    for (var e, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
                      for (var o2 in e = arguments[n2])
                        Object.prototype.hasOwnProperty.call(e, o2) && (t[o2] = e[o2]);
                    return t;
                  }).apply(this, arguments);
                };
                function A(t, e, n2, r2) {
                  return new (n2 || (n2 = Promise))(function(o2, i2) {
                    function s2(t2) {
                      try {
                        u2(r2.next(t2));
                      } catch (t3) {
                        i2(t3);
                      }
                    }
                    function a2(t2) {
                      try {
                        u2(r2.throw(t2));
                      } catch (t3) {
                        i2(t3);
                      }
                    }
                    function u2(t2) {
                      var e2;
                      t2.done ? o2(t2.value) : (e2 = t2.value, e2 instanceof n2 ? e2 : new n2(function(t3) {
                        t3(e2);
                      })).then(s2, a2);
                    }
                    u2((r2 = r2.apply(t, e || [])).next());
                  });
                }
                function R(t, e) {
                  var n2, r2, o2, i2, s2 = {
                    label: 0,
                    sent: function sent() {
                      if (1 & o2[0])
                        throw o2[1];
                      return o2[1];
                    },
                    trys: [],
                    ops: []
                  };
                  return i2 = {
                    next: a2(0),
                    throw: a2(1),
                    return: a2(2)
                  }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
                    return this;
                  }), i2;
                  function a2(i3) {
                    return function(a3) {
                      return function(i4) {
                        if (n2)
                          throw new TypeError("Generator is already executing.");
                        for (; s2; )
                          try {
                            if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done)
                              return o2;
                            switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
                              case 0:
                              case 1:
                                o2 = i4;
                                break;
                              case 4:
                                return s2.label++, {
                                  value: i4[1],
                                  done: false
                                };
                              case 5:
                                s2.label++, r2 = i4[1], i4 = [0];
                                continue;
                              case 7:
                                i4 = s2.ops.pop(), s2.trys.pop();
                                continue;
                              default:
                                if (!((o2 = (o2 = s2.trys).length > 0 && o2[o2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                                  s2 = 0;
                                  continue;
                                }
                                if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                                  s2.label = i4[1];
                                  break;
                                }
                                if (6 === i4[0] && s2.label < o2[1]) {
                                  s2.label = o2[1], o2 = i4;
                                  break;
                                }
                                if (o2 && s2.label < o2[2]) {
                                  s2.label = o2[2], s2.ops.push(i4);
                                  break;
                                }
                                o2[2] && s2.ops.pop(), s2.trys.pop();
                                continue;
                            }
                            i4 = e.call(t, s2);
                          } catch (t2) {
                            i4 = [6, t2], r2 = 0;
                          } finally {
                            n2 = o2 = 0;
                          }
                        if (5 & i4[0])
                          throw i4[1];
                        return {
                          value: i4[0] ? i4[1] : void 0,
                          done: true
                        };
                      }([i3, a3]);
                    };
                  }
                }
                var B = function() {
                  function t() {
                    this.interceptors = [];
                  }
                  return t.prototype.use = function(t2, e) {
                    return this.interceptors.push({
                      resolved: t2,
                      rejected: e
                    }), this.interceptors.length - 1;
                  }, t.prototype.traverse = function(t2, e) {
                    void 0 === e && (e = false);
                    var n2 = Promise.resolve(t2);
                    return (e ? Array.prototype.reduceRight : Array.prototype.reduce).call(this.interceptors, function(t3, e2) {
                      if (e2) {
                        var r2 = e2.resolved, o2 = e2.rejected;
                        n2 = n2.then(r2, o2);
                      }
                      return t3;
                    }, ""), n2;
                  }, t.prototype.eject = function(t2) {
                    this.interceptors[t2] && (this.interceptors[t2] = null);
                  }, t;
                }(), J = {
                  defaults: {
                    timeout: 0,
                    method: "GET",
                    mode: "cors",
                    redirect: "follow",
                    credentials: "same-origin"
                  },
                  headers: {
                    common: {
                      Accept: "application/json, text/plain, */*"
                    },
                    POST: {
                      "Content-Type": "application/x-www-form-urlencoded"
                    },
                    PUT: {
                      "Content-Type": "application/x-www-form-urlencoded"
                    },
                    PATCH: {
                      "Content-Type": "application/x-www-form-urlencoded"
                    }
                  },
                  baseURL: "",
                  polyfillUrl: "https://vm.gtimg.cn/comps/script/fetch.min.js",
                  interceptors: {
                    request: new B(),
                    response: new B()
                  }
                }, V = /^([a-z][a-z\d+\-.]*:)?\/\//i, Q = Object.prototype.toString;
                function L(t) {
                  return A(this, void 0, void 0, function() {
                    var e;
                    return R(this, function(n2) {
                      switch (n2.label) {
                        case 0:
                          if (window.fetch)
                            return [2];
                          n2.label = 1;
                        case 1:
                          return n2.trys.push([1, 3, , 4]), [4, j({
                            src: t
                          })];
                        case 2:
                          return n2.sent(), [3, 4];
                        case 3:
                          throw e = n2.sent(), new Error("加载 polyfill " + t + " 失败: " + e.message);
                        case 4:
                          return [2];
                      }
                    });
                  });
                }
                function M(t) {
                  return ["Accept", "Content-Type"].forEach(function(e) {
                    return n2 = e, void ((r2 = t.headers) && Object.keys(r2).forEach(function(t2) {
                      t2 !== n2 && t2.toUpperCase() === n2.toUpperCase() && (r2[n2] = r2[t2], delete r2[t2]);
                    }));
                    var n2, r2;
                  }), function(t2) {
                    if ("[object Object]" !== Q.call(t2))
                      return false;
                    var e = Object.getPrototypeOf(t2);
                    return null === e || e === Object.prototype;
                  }(t.body) && (t.body = JSON.stringify(t.body), t.headers && (t.headers["Content-Type"] = "application/json;charset=utf-8")), t;
                }
                function K(t) {
                  return A(this, void 0, void 0, function() {
                    var e, n2, r2, o2, i2, s2, a2, u2, c2, l2, p2, h2, f2, d2, v2, g2, y2;
                    return R(this, function(m2) {
                      switch (m2.label) {
                        case 0:
                          return e = J.baseURL, n2 = J.defaults, r2 = J.interceptors, [4, L(J.polyfillUrl)];
                        case 1:
                          return m2.sent(), (o2 = _q(_q({}, n2), t)).headers || (o2.headers = function(t2) {
                            void 0 === t2 && (t2 = "GET");
                            var e2 = J.headers[t2] || {};
                            return _q(_q({}, J.headers.common), e2);
                          }(o2.method)), M(o2), [4, r2.request.traverse(o2, true)];
                        case 2:
                          if ((i2 = m2.sent()) instanceof Error)
                            throw i2;
                          return i2.url = function(t2, e2) {
                            return !t2 || V.test(e2) ? e2 : t2.replace(/\/+$/, "") + "/" + e2.replace(/^\/+/, "");
                          }(e, i2.url), s2 = i2.url, a2 = i2.timeout, u2 = i2.params, c2 = i2.method, l2 = ["GET", "DELETE", "OPTIONS", "HEAD"].includes(void 0 === c2 ? "GET" : c2) && !!u2, p2 = l2 ? N({
                            url: s2,
                            query: u2
                          }) : s2, h2 = [], a2 && !i2.signal && (v2 = new Promise(function(t2) {
                            f2 = setTimeout(function() {
                              t2(new Error("timeout"));
                            }, a2);
                          }), h2.push(v2), d2 = new AbortController(), i2.signal = d2.signal), h2.push(fetch(p2, i2).catch(function(t2) {
                            return t2;
                          })), [4, Promise.race(h2)];
                        case 3:
                          return g2 = m2.sent(), f2 && clearTimeout(f2), [4, r2.response.traverse(g2)];
                        case 4:
                          if ((y2 = m2.sent()) instanceof Error)
                            throw null == d2 || d2.abort(), y2;
                          return [2, y2];
                      }
                    });
                  });
                }
                var F = function() {
                  function t(t2) {
                    J.interceptors.request.use(function(n2) {
                      var r2 = n2.url, o2 = n2.method, i2 = n2.body, s2 = i2;
                      if (t2.onReportBeforeSend) {
                        var a2 = t2.onReportBeforeSend({
                          url: r2,
                          method: o2,
                          data: i2 ? JSON.parse(i2) : null
                        });
                        s2 = (null == a2 ? void 0 : a2.data) ? JSON.stringify(a2.data) : null;
                      }
                      return "GET" != o2 && s2 ? _e(_e({}, n2), {
                        body: s2
                      }) : n2;
                    });
                  }
                  return t.prototype.get = function(t2, o2) {
                    return n(this, void 0, void 0, function() {
                      var n2, i2;
                      return r(this, function(r2) {
                        switch (r2.label) {
                          case 0:
                            return [4, K(_e({
                              url: t2
                            }, o2))];
                          case 1:
                            return [4, (n2 = r2.sent()).json()];
                          case 2:
                            return i2 = r2.sent(), [2, Promise.resolve({
                              data: i2,
                              status: n2.status,
                              statusText: n2.statusText,
                              headers: n2.headers
                            })];
                        }
                      });
                    });
                  }, t.prototype.post = function(t2, o2, i2) {
                    return n(this, void 0, void 0, function() {
                      var n2, s2;
                      return r(this, function(r2) {
                        switch (r2.label) {
                          case 0:
                            return [4, K(_e({
                              url: t2,
                              body: o2,
                              method: "POST"
                            }, i2))];
                          case 1:
                            return [4, (n2 = r2.sent()).json()];
                          case 2:
                            return s2 = r2.sent(), [2, Promise.resolve({
                              data: s2,
                              status: n2.status,
                              statusText: n2.statusText,
                              headers: n2.headers
                            })];
                        }
                      });
                    });
                  }, t;
                }(), G = function() {
                  function t(t2) {
                    this.appkey = t2;
                  }
                  return t.prototype.getItem = function(t2) {
                    try {
                      return window.localStorage.getItem(this.getStoreKey(t2));
                    } catch (t3) {
                      return "";
                    }
                  }, t.prototype.removeItem = function(t2) {
                    try {
                      window.localStorage.removeItem(this.getStoreKey(t2));
                    } catch (t3) {
                    }
                  }, t.prototype.setItem = function(t2, e) {
                    try {
                      window.localStorage.setItem(this.getStoreKey(t2), e);
                    } catch (t3) {
                    }
                  }, t.prototype.setSessionItem = function(t2, e) {
                    try {
                      window.sessionStorage.setItem(this.getStoreKey(t2), e);
                    } catch (t3) {
                    }
                  }, t.prototype.getSessionItem = function(t2) {
                    try {
                      return window.sessionStorage.getItem(this.getStoreKey(t2));
                    } catch (t3) {
                      return "";
                    }
                  }, t.prototype.getStoreKey = function(t2) {
                    return o + this.appkey + "_" + t2;
                  }, t.prototype.createDeviceId = function() {
                    try {
                      var t2 = window.localStorage.getItem(i);
                      return t2 || (t2 = function(t3) {
                        for (var e = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz0123456789", n2 = "", r2 = 0; r2 < t3; r2++)
                          n2 += e.charAt(Math.floor(Math.random() * e.length));
                        return n2;
                      }(32), window.localStorage.setItem(i, t2)), t2;
                    } catch (t3) {
                      return "";
                    }
                  }, t.prototype.clear = function() {
                    try {
                      for (var t2 = window.localStorage.length, e = 0; e < t2; e++) {
                        var n2 = window.localStorage.key(e);
                        (null == n2 ? void 0 : n2.substr(0, 9)) == o && window.localStorage.removeItem(n2);
                      }
                    } catch (t3) {
                    }
                  }, t.prototype.getStoreCount = function() {
                    var t2 = 0;
                    try {
                      t2 = window.localStorage.length;
                    } catch (t3) {
                    }
                    return t2;
                  }, t;
                }(), z = "logid_start", W = "4.5.14-web";
                return function(n2) {
                  function r2(t) {
                    var e = n2.call(this, t) || this;
                    e.qimei36 = "", e.uselessCycleTaskNum = 0, e.underWeakNet = false, e.pauseSearching = false, e.send = function(t2, n3, r4) {
                      e.storage.setItem(s, Date.now().toString()), e.network.post(e.uploadUrl || e.strategy.getUploadUrl(), t2.data).then(function(r5) {
                        var o3;
                        100 == (null === (o3 = null == r5 ? void 0 : r5.data) || void 0 === o3 ? void 0 : o3.result) ? e.delayTime = 1e3 * r5.data.delayTime : e.delayTime = 0, n3 && n3(t2.data), t2.data.events.forEach(function(t3) {
                          e.store.removeEvent(t3).then(function() {
                            e.removeSendingId(f(t3.mapValue));
                          });
                        }), e.doCustomCycleTask();
                      }).catch(function(n4) {
                        var o3 = t2.data.events;
                        e.errorReport.reportError(n4.code ? n4.code.toString() : "600", n4.message), r4 && r4(t2.data);
                        var i3 = JSON.parse(e.storage.getItem(a));
                        o3.forEach(function(t3) {
                          i3 && -1 != i3.indexOf(f(t3)) && e.store.insertEvent(t3, function(t4, n5) {
                            t4 && e.errorReport.reportError("604", "insertEvent fail!");
                          }), e.removeSendingId(f(t3));
                        }), e.monitorUploadFailed();
                      });
                    };
                    var r3, o2, i2 = b();
                    return e.isUnderIE8 = i2 > 0 && i2 < 8, e.isUnderIE8 || (e.isUnderIE = i2 > 0, t.needInitQimei && S(t.appkey, function(t2) {
                      e.qimei36 = t2.q36;
                    }), e.network = new F(t), e.storage = new G(t.appkey), e.initCommonInfo(t), e.store = new _(t.appkey, e.storage), e.errorReport = new g(e.config, e.commonInfo, "web", e.network), e.strategy = new y(null == t.needQueryConfig || t.needQueryConfig, e.config, e.commonInfo, e.storage, e.network), e.logidStartTime = e.storage.getItem(z), e.logidStartTime || (e.logidStartTime = Date.now().toString(), e.storage.setItem(z, e.logidStartTime)), r3 = e.logidStartTime, o2 = Date.now() - Number.parseFloat(r3), Math.floor(o2 / 864e5) >= 365 && e.storage.clear(), e.initSession(t), e.onDirectUserAction("rqd_js_init", {}), setTimeout(function() {
                      return e.lifeCycle.emit("init");
                    }, 0), e.initDelayTime = t.delay ? t.delay : 1e3, e.cycleTask(e.initDelayTime)), e;
                  }
                  return function(e, n3) {
                    if ("function" != typeof n3 && null !== n3)
                      throw new TypeError("Class extends value " + String(n3) + " is not a constructor or null");
                    function r3() {
                      this.constructor = e;
                    }
                    _t(e, n3), e.prototype = null === n3 ? Object.create(n3) : (r3.prototype = n3.prototype, new r3());
                  }(r2, n2), r2.prototype.initSession = function(t) {
                    var e = 18e5;
                    t.sessionDuration && t.sessionDuration > 3e4 && (e = t.sessionDuration), this.beaconSession = new w(this.storage, e, this);
                  }, r2.prototype.initCommonInfo = function(t) {
                    var e = Number(this.storage.getItem(s));
                    try {
                      var n3 = JSON.parse(this.storage.getItem(a));
                      (Date.now() - e > 3e4 || !n3) && this.storage.setItem(a, JSON.stringify([]));
                    } catch (t2) {
                    }
                    t.uploadUrl && (this.uploadUrl = t.uploadUrl + "?appkey=" + t.appkey);
                    var r3 = [window.screen.width, window.screen.height];
                    window.devicePixelRatio && r3.push(window.devicePixelRatio), this.commonInfo = {
                      deviceId: this.storage.createDeviceId(),
                      language: navigator && navigator.language || "zh_CN",
                      query: window.location.search,
                      userAgent: navigator.userAgent,
                      pixel: r3.join("*"),
                      channelID: t.channelID ? String(t.channelID) : "",
                      openid: t.openid ? String(t.openid) : "",
                      unid: t.unionid ? String(t.unionid) : "",
                      sdkVersion: W
                    }, this.config.appVersion = t.versionCode ? String(t.versionCode) : "", this.config.strictMode = t.strictMode;
                  }, r2.prototype.cycleTask = function(t) {
                    var e = this;
                    this.intervalID = window.setInterval(function() {
                      e.pauseSearching || e.store.getEvents().then(function(t2) {
                        0 == t2.length && (e.pauseSearching = true);
                        var n3 = [], r3 = JSON.parse(e.storage.getItem(a));
                        r3 || (r3 = []), t2 && t2.forEach(function(t3) {
                          var e2 = f(t3.mapValue);
                          -1 == r3.indexOf(e2) && (n3.push(t3), r3.push(e2));
                        }), 0 != n3.length && (e.storage.setItem(a, JSON.stringify(r3)), e._normalLogPipeline(e.assembleData(n3)));
                      }).catch(function(t2) {
                      });
                    }, t);
                  }, r2.prototype.onReport = function(t, e, n3) {
                    var r3 = this;
                    if (this.isUnderIE8)
                      this.errorReport.reportError("601", "UnderIE8");
                    else {
                      this.pauseSearching = false;
                      var o2 = this.generateData(t, e, n3);
                      if (n3 && 0 == this.delayTime && !this.underWeakNet)
                        this._normalLogPipeline(this.assembleData(o2));
                      else {
                        var i2 = o2.shift();
                        i2 && this.store.insertEvent(i2, function(t2) {
                          t2 && r3.errorReport.reportError("604", "insertEvent fail!");
                        }).catch(function(t2) {
                          r3._normalLogPipeline(r3.assembleData(o2));
                        });
                      }
                    }
                  }, r2.prototype.onSendBeacon = function(t, e) {
                    if (this.isUnderIE)
                      this.errorReport.reportError("605", "UnderIE");
                    else {
                      this.pauseSearching = false;
                      var n3 = this.assembleData(this.generateData(t, e, true));
                      "function" == typeof navigator.sendBeacon && navigator.sendBeacon(this.uploadUrl || this.strategy.getUploadUrl(), JSON.stringify(n3));
                    }
                  }, r2.prototype.generateData = function(t, n3, r3) {
                    var o2 = [], i2 = "4.5.14-web_" + (r3 ? "direct_log_id" : "normal_log_id"), s2 = Number(this.storage.getItem(i2));
                    return s2 = s2 || 1, n3 = _e(_e({}, n3), {
                      A99: r3 ? "Y" : "N",
                      A100: s2.toString(),
                      A72: W,
                      A88: this.logidStartTime
                    }), s2++, this.storage.setItem(i2, s2.toString()), o2.push({
                      eventCode: t,
                      eventTime: Date.now().toString(),
                      mapValue: p(n3, this.config.strictMode)
                    }), o2;
                  }, r2.prototype.assembleData = function(t) {
                    var n3 = this.beaconSession.getSession();
                    return {
                      appVersion: this.config.appVersion ? h(this.config.appVersion) : "",
                      sdkId: "js",
                      sdkVersion: W,
                      mainAppKey: this.config.appkey,
                      platformId: 3,
                      common: p(_e(_e({}, this.additionalParams), {
                        A2: this.commonInfo.deviceId,
                        A8: this.commonInfo.openid,
                        A12: this.commonInfo.language,
                        A17: this.commonInfo.pixel,
                        A23: this.commonInfo.channelID,
                        A50: this.commonInfo.unid,
                        A76: n3.sessionId,
                        A101: this.commonInfo.userAgent,
                        A102: window.location.href,
                        A104: document.referrer,
                        A119: this.commonInfo.query,
                        A153: this.qimei36
                      }), false),
                      events: t
                    };
                  }, r2.prototype.monitorUploadFailed = function() {
                    this.uselessCycleTaskNum++, this.uselessCycleTaskNum >= 5 && (window.clearInterval(this.intervalID), this.cycleTask(6e4), this.underWeakNet = true);
                  }, r2.prototype.doCustomCycleTask = function() {
                    this.uselessCycleTaskNum >= 5 && (window.clearInterval(this.intervalID), this.cycleTask(this.initDelayTime)), this.uselessCycleTaskNum = 0, this.underWeakNet = false;
                  }, r2;
                }(v);
              });
            }
          ),
          /***/
          "./lib/crypto.js": (
            /*!***********************!*\
              !*** ./lib/crypto.js ***!
              \***********************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              (function(module3) {
                var _typeof2 = __webpack_require__2(
                  /*! @babel/runtime/helpers/typeof */
                  "./node_modules/@babel/runtime/helpers/typeof.js"
                );
                var CryptoJS = CryptoJS || function(g, l) {
                  var e = {}, d = e.lib = {}, m = function m2() {
                  }, k = d.Base = {
                    extend: function extend(a) {
                      m.prototype = this;
                      var c = new m();
                      a && c.mixIn(a);
                      c.hasOwnProperty("init") || (c.init = function() {
                        c.$super.init.apply(this, arguments);
                      });
                      c.init.prototype = c;
                      c.$super = this;
                      return c;
                    },
                    create: function create() {
                      var a = this.extend();
                      a.init.apply(a, arguments);
                      return a;
                    },
                    init: function init() {
                    },
                    mixIn: function mixIn(a) {
                      for (var c in a)
                        a.hasOwnProperty(c) && (this[c] = a[c]);
                      a.hasOwnProperty("toString") && (this.toString = a.toString);
                    },
                    clone: function clone() {
                      return this.init.prototype.extend(this);
                    }
                  }, p = d.WordArray = k.extend({
                    init: function init(a, c) {
                      a = this.words = a || [];
                      this.sigBytes = c != l ? c : 4 * a.length;
                    },
                    toString: function toString(a) {
                      return (a || n).stringify(this);
                    },
                    concat: function concat(a) {
                      var c = this.words, q = a.words, f = this.sigBytes;
                      a = a.sigBytes;
                      this.clamp();
                      if (f % 4)
                        for (var b2 = 0; b2 < a; b2++)
                          c[f + b2 >>> 2] |= (q[b2 >>> 2] >>> 24 - 8 * (b2 % 4) & 255) << 24 - 8 * ((f + b2) % 4);
                      else if (65535 < q.length)
                        for (b2 = 0; b2 < a; b2 += 4)
                          c[f + b2 >>> 2] = q[b2 >>> 2];
                      else
                        c.push.apply(c, q);
                      this.sigBytes += a;
                      return this;
                    },
                    clamp: function clamp() {
                      var a = this.words, c = this.sigBytes;
                      a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);
                      a.length = g.ceil(c / 4);
                    },
                    clone: function clone() {
                      var a = k.clone.call(this);
                      a.words = this.words.slice(0);
                      return a;
                    },
                    random: function random(a) {
                      for (var c = [], b2 = 0; b2 < a; b2 += 4)
                        c.push(4294967296 * g.random() | 0);
                      return new p.init(c, a);
                    }
                  }), b = e.enc = {}, n = b.Hex = {
                    stringify: function stringify(a) {
                      var c = a.words;
                      a = a.sigBytes;
                      for (var b2 = [], f = 0; f < a; f++) {
                        var d2 = c[f >>> 2] >>> 24 - 8 * (f % 4) & 255;
                        b2.push((d2 >>> 4).toString(16));
                        b2.push((d2 & 15).toString(16));
                      }
                      return b2.join("");
                    },
                    parse: function parse(a) {
                      for (var c = a.length, b2 = [], f = 0; f < c; f += 2)
                        b2[f >>> 3] |= parseInt(a.substr(f, 2), 16) << 24 - 4 * (f % 8);
                      return new p.init(b2, c / 2);
                    }
                  }, j = b.Latin1 = {
                    stringify: function stringify(a) {
                      var c = a.words;
                      a = a.sigBytes;
                      for (var b2 = [], f = 0; f < a; f++)
                        b2.push(String.fromCharCode(c[f >>> 2] >>> 24 - 8 * (f % 4) & 255));
                      return b2.join("");
                    },
                    parse: function parse(a) {
                      for (var c = a.length, b2 = [], f = 0; f < c; f++)
                        b2[f >>> 2] |= (a.charCodeAt(f) & 255) << 24 - 8 * (f % 4);
                      return new p.init(b2, c);
                    }
                  }, h = b.Utf8 = {
                    stringify: function stringify(a) {
                      try {
                        return decodeURIComponent(escape(j.stringify(a)));
                      } catch (c) {
                        throw Error("Malformed UTF-8 data");
                      }
                    },
                    parse: function parse(a) {
                      return j.parse(unescape(encodeURIComponent(a)));
                    }
                  }, r = d.BufferedBlockAlgorithm = k.extend({
                    reset: function reset() {
                      this._data = new p.init();
                      this._nDataBytes = 0;
                    },
                    _append: function _append(a) {
                      "string" == typeof a && (a = h.parse(a));
                      this._data.concat(a);
                      this._nDataBytes += a.sigBytes;
                    },
                    _process: function _process(a) {
                      var c = this._data, b2 = c.words, f = c.sigBytes, d2 = this.blockSize, e2 = f / (4 * d2), e2 = a ? g.ceil(e2) : g.max((e2 | 0) - this._minBufferSize, 0);
                      a = e2 * d2;
                      f = g.min(4 * a, f);
                      if (a) {
                        for (var k2 = 0; k2 < a; k2 += d2)
                          this._doProcessBlock(b2, k2);
                        k2 = b2.splice(0, a);
                        c.sigBytes -= f;
                      }
                      return new p.init(k2, f);
                    },
                    clone: function clone() {
                      var a = k.clone.call(this);
                      a._data = this._data.clone();
                      return a;
                    },
                    _minBufferSize: 0
                  });
                  d.Hasher = r.extend({
                    cfg: k.extend(),
                    init: function init(a) {
                      this.cfg = this.cfg.extend(a);
                      this.reset();
                    },
                    reset: function reset() {
                      r.reset.call(this);
                      this._doReset();
                    },
                    update: function update(a) {
                      this._append(a);
                      this._process();
                      return this;
                    },
                    finalize: function finalize(a) {
                      a && this._append(a);
                      return this._doFinalize();
                    },
                    blockSize: 16,
                    _createHelper: function _createHelper(a) {
                      return function(b2, d2) {
                        return new a.init(d2).finalize(b2);
                      };
                    },
                    _createHmacHelper: function _createHmacHelper(a) {
                      return function(b2, d2) {
                        return new s.HMAC.init(a, d2).finalize(b2);
                      };
                    }
                  });
                  var s = e.algo = {};
                  return e;
                }(Math);
                (function() {
                  var g = CryptoJS, l = g.lib, e = l.WordArray, d = l.Hasher, m = [], l = g.algo.SHA1 = d.extend({
                    _doReset: function _doReset() {
                      this._hash = new e.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
                    },
                    _doProcessBlock: function _doProcessBlock(d2, e2) {
                      for (var b = this._hash.words, n = b[0], j = b[1], h = b[2], g2 = b[3], l2 = b[4], a = 0; 80 > a; a++) {
                        if (16 > a)
                          m[a] = d2[e2 + a] | 0;
                        else {
                          var c = m[a - 3] ^ m[a - 8] ^ m[a - 14] ^ m[a - 16];
                          m[a] = c << 1 | c >>> 31;
                        }
                        c = (n << 5 | n >>> 27) + l2 + m[a];
                        c = 20 > a ? c + ((j & h | ~j & g2) + 1518500249) : 40 > a ? c + ((j ^ h ^ g2) + 1859775393) : 60 > a ? c + ((j & h | j & g2 | h & g2) - 1894007588) : c + ((j ^ h ^ g2) - 899497514);
                        l2 = g2;
                        g2 = h;
                        h = j << 30 | j >>> 2;
                        j = n;
                        n = c;
                      }
                      b[0] = b[0] + n | 0;
                      b[1] = b[1] + j | 0;
                      b[2] = b[2] + h | 0;
                      b[3] = b[3] + g2 | 0;
                      b[4] = b[4] + l2 | 0;
                    },
                    _doFinalize: function _doFinalize() {
                      var d2 = this._data, e2 = d2.words, b = 8 * this._nDataBytes, g2 = 8 * d2.sigBytes;
                      e2[g2 >>> 5] |= 128 << 24 - g2 % 32;
                      e2[(g2 + 64 >>> 9 << 4) + 14] = Math.floor(b / 4294967296);
                      e2[(g2 + 64 >>> 9 << 4) + 15] = b;
                      d2.sigBytes = 4 * e2.length;
                      this._process();
                      return this._hash;
                    },
                    clone: function clone() {
                      var e2 = d.clone.call(this);
                      e2._hash = this._hash.clone();
                      return e2;
                    }
                  });
                  g.SHA1 = d._createHelper(l);
                  g.HmacSHA1 = d._createHmacHelper(l);
                })();
                (function() {
                  var g = CryptoJS, l = g.enc.Utf8;
                  g.algo.HMAC = g.lib.Base.extend({
                    init: function init(e, d) {
                      e = this._hasher = new e.init();
                      "string" == typeof d && (d = l.parse(d));
                      var g2 = e.blockSize, k = 4 * g2;
                      d.sigBytes > k && (d = e.finalize(d));
                      d.clamp();
                      for (var p = this._oKey = d.clone(), b = this._iKey = d.clone(), n = p.words, j = b.words, h = 0; h < g2; h++)
                        n[h] ^= 1549556828, j[h] ^= 909522486;
                      p.sigBytes = b.sigBytes = k;
                      this.reset();
                    },
                    reset: function reset() {
                      var e = this._hasher;
                      e.reset();
                      e.update(this._iKey);
                    },
                    update: function update(e) {
                      this._hasher.update(e);
                      return this;
                    },
                    finalize: function finalize(e) {
                      var d = this._hasher;
                      e = d.finalize(e);
                      d.reset();
                      return d.finalize(this._oKey.clone().concat(e));
                    }
                  });
                })();
                (function() {
                  var C = CryptoJS;
                  var C_lib = C.lib;
                  var WordArray = C_lib.WordArray;
                  var C_enc = C.enc;
                  var Base64 = C_enc.Base64 = {
                    /**
                     * Converts a word array to a Base64 string.
                     *
                     * @param {WordArray} wordArray The word array.
                     *
                     * @return {string} The Base64 string.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
                     */
                    stringify: function stringify(wordArray) {
                      var words = wordArray.words;
                      var sigBytes = wordArray.sigBytes;
                      var map = this._map;
                      wordArray.clamp();
                      var base64Chars = [];
                      for (var i = 0; i < sigBytes; i += 3) {
                        var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
                        var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
                        var triplet = byte1 << 16 | byte2 << 8 | byte3;
                        for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                          base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
                        }
                      }
                      var paddingChar = map.charAt(64);
                      if (paddingChar) {
                        while (base64Chars.length % 4) {
                          base64Chars.push(paddingChar);
                        }
                      }
                      return base64Chars.join("");
                    },
                    /**
                     * Converts a Base64 string to a word array.
                     *
                     * @param {string} base64Str The Base64 string.
                     *
                     * @return {WordArray} The word array.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
                     */
                    parse: function parse(base64Str) {
                      var base64StrLength = base64Str.length;
                      var map = this._map;
                      var paddingChar = map.charAt(64);
                      if (paddingChar) {
                        var paddingIndex = base64Str.indexOf(paddingChar);
                        if (paddingIndex != -1) {
                          base64StrLength = paddingIndex;
                        }
                      }
                      var words = [];
                      var nBytes = 0;
                      for (var i = 0; i < base64StrLength; i++) {
                        if (i % 4) {
                          var bits1 = map.indexOf(base64Str.charAt(i - 1)) << i % 4 * 2;
                          var bits2 = map.indexOf(base64Str.charAt(i)) >>> 6 - i % 4 * 2;
                          words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
                          nBytes++;
                        }
                      }
                      return WordArray.create(words, nBytes);
                    },
                    _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
                  };
                })();
                if ((false ? void 0 : _typeof2(module3)) === "object") {
                  module3.exports = CryptoJS;
                } else {
                  window.CryptoJS = CryptoJS;
                }
              }).call(this, __webpack_require__2(
                /*! ./../node_modules/webpack/buildin/module.js */
                "./node_modules/webpack/buildin/module.js"
              )(module2));
            }
          ),
          /***/
          "./lib/json2xml.js": (
            /*!*************************!*\
              !*** ./lib/json2xml.js ***!
              \*************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var _typeof2 = __webpack_require__2(
                /*! @babel/runtime/helpers/typeof */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              );
              var element_start_char = "a-zA-Z_À-ÖØ-öø-ÿͰ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿿、-퟿豈-﷏ﷰ-�";
              var element_non_start_char = "-.0-9·̀-ͯ‿⁀";
              var element_replace = new RegExp("^([^" + element_start_char + "])|^((x|X)(m|M)(l|L))|([^" + element_start_char + element_non_start_char + "])", "g");
              var not_safe_in_xml = /[^\x09\x0A\x0D\x20-\xFF\x85\xA0-\uD7FF\uE000-\uFDCF\uFDE0-\uFFFD]/gm;
              var objKeys = function objKeys2(obj) {
                var l = [];
                if (obj instanceof Object) {
                  for (var k in obj) {
                    if (obj.hasOwnProperty(k)) {
                      l.push(k);
                    }
                  }
                }
                return l;
              };
              var process_to_xml = function process_to_xml2(node_data, options) {
                var makeNode = function makeNode2(name, content, attributes, level, hasSubNodes) {
                  var indent_value = options.indent !== void 0 ? options.indent : "	";
                  var indent = options.prettyPrint ? "\n" + new Array(level).join(indent_value) : "";
                  if (options.removeIllegalNameCharacters) {
                    name = name.replace(element_replace, "_");
                  }
                  var node = [indent, "<", name, attributes || ""];
                  if (content && content.length > 0) {
                    node.push(">");
                    node.push(content);
                    hasSubNodes && node.push(indent);
                    node.push("</");
                    node.push(name);
                    node.push(">");
                  } else {
                    node.push("/>");
                  }
                  return node.join("");
                };
                return function fn(node_data2, node_descriptor, level) {
                  var type = _typeof2(node_data2);
                  if (Array.isArray ? Array.isArray(node_data2) : node_data2 instanceof Array) {
                    type = "array";
                  } else if (node_data2 instanceof Date) {
                    type = "date";
                  }
                  switch (type) {
                    case "array":
                      var ret = [];
                      node_data2.map(function(v) {
                        ret.push(fn(v, 1, level + 1));
                      });
                      options.prettyPrint && ret.push("\n");
                      return ret.join("");
                      break;
                    case "date":
                      return node_data2.toJSON ? node_data2.toJSON() : node_data2 + "";
                      break;
                    case "object":
                      var nodes = [];
                      for (var name in node_data2) {
                        if (node_data2.hasOwnProperty(name)) {
                          if (node_data2[name] instanceof Array) {
                            for (var j = 0; j < node_data2[name].length; j++) {
                              if (node_data2[name].hasOwnProperty(j)) {
                                nodes.push(makeNode(name, fn(node_data2[name][j], 0, level + 1), null, level + 1, objKeys(node_data2[name][j]).length));
                              }
                            }
                          } else {
                            nodes.push(makeNode(name, fn(node_data2[name], 0, level + 1), null, level + 1));
                          }
                        }
                      }
                      options.prettyPrint && nodes.length > 0 && nodes.push("\n");
                      return nodes.join("");
                      break;
                    case "function":
                      return node_data2();
                      break;
                    default:
                      return options.escape ? esc(node_data2) : "" + node_data2;
                  }
                }(node_data, 0, 0);
              };
              var xml_header = function xml_header2(standalone) {
                var ret = ['<?xml version="1.0" encoding="UTF-8"'];
                if (standalone) {
                  ret.push(' standalone="yes"');
                }
                ret.push("?>");
                return ret.join("");
              };
              function esc(str) {
                return ("" + str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;").replace(not_safe_in_xml, "");
              }
              module2.exports = function(obj, options) {
                if (!options) {
                  options = {
                    xmlHeader: {
                      standalone: true
                    },
                    prettyPrint: true,
                    indent: "  ",
                    escape: true
                  };
                }
                if (typeof obj == "string") {
                  try {
                    obj = JSON.parse(obj.toString());
                  } catch (e) {
                    return false;
                  }
                }
                var xmlheader = "";
                var docType = "";
                if (options) {
                  if (_typeof2(options) == "object") {
                    if (options.xmlHeader) {
                      xmlheader = xml_header(!!options.xmlHeader.standalone);
                    }
                    if (typeof options.docType != "undefined") {
                      docType = "<!DOCTYPE " + options.docType + ">";
                    }
                  } else {
                    xmlheader = xml_header();
                  }
                }
                options = options || {};
                var ret = [xmlheader, options.prettyPrint && docType ? "\n" : "", docType, process_to_xml(obj, options)];
                return ret.join("").replace(/\n{2,}/g, "\n").replace(/\s+$/g, "");
              };
            }
          ),
          /***/
          "./lib/md5.js": (
            /*!********************!*\
              !*** ./lib/md5.js ***!
              \********************/
            /*! no static exports found */
            /***/
            function(module, exports, __webpack_require__) {
              (function(process, global, module) {
                var __WEBPACK_AMD_DEFINE_RESULT__;
                var _typeof = __webpack_require__(
                  /*! @babel/runtime/helpers/typeof */
                  "./node_modules/@babel/runtime/helpers/typeof.js"
                );
                (function() {
                  "use strict";
                  var ERROR = "input is invalid type";
                  var WINDOW = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object";
                  var root = WINDOW ? window : {};
                  if (root.JS_MD5_NO_WINDOW) {
                    WINDOW = false;
                  }
                  var WEB_WORKER = !WINDOW && (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object";
                  var NODE_JS = !root.JS_MD5_NO_NODE_JS && (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process.versions && process.versions.node;
                  if (NODE_JS) {
                    root = global;
                  } else if (WEB_WORKER) {
                    root = self;
                  }
                  var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && (false ? void 0 : _typeof(module)) === "object" && module.exports;
                  var AMD = __webpack_require__(
                    /*! !webpack amd options */
                    "./node_modules/webpack/buildin/amd-options.js"
                  );
                  var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
                  var HEX_CHARS = "0123456789abcdef".split("");
                  var EXTRA = [128, 32768, 8388608, -2147483648];
                  var SHIFT = [0, 8, 16, 24];
                  var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"];
                  var BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
                  var blocks = [], buffer8;
                  if (ARRAY_BUFFER) {
                    var buffer = new ArrayBuffer(68);
                    buffer8 = new Uint8Array(buffer);
                    blocks = new Uint32Array(buffer);
                  }
                  if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {
                    Array.isArray = function(obj) {
                      return Object.prototype.toString.call(obj) === "[object Array]";
                    };
                  }
                  if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
                    ArrayBuffer.isView = function(obj) {
                      return _typeof(obj) === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
                    };
                  }
                  var createOutputMethod = function createOutputMethod2(outputType) {
                    return function(message, isBinStr) {
                      return new Md5(true).update(message, isBinStr)[outputType]();
                    };
                  };
                  var createMethod = function createMethod2() {
                    var method2 = createOutputMethod("hex");
                    if (NODE_JS) {
                      method2 = nodeWrap(method2);
                    }
                    method2.getCtx = method2.create = function() {
                      return new Md5();
                    };
                    method2.update = function(message) {
                      return method2.create().update(message);
                    };
                    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
                      var type = OUTPUT_TYPES[i];
                      method2[type] = createOutputMethod(type);
                    }
                    return method2;
                  };
                  var nodeWrap = function nodeWrap(method) {
                    var crypto = eval("require('crypto')");
                    var Buffer = eval("require('buffer').Buffer");
                    var nodeMethod = function nodeMethod2(message) {
                      if (typeof message === "string") {
                        return crypto.createHash("md5").update(message, "utf8").digest("hex");
                      } else {
                        if (message === null || message === void 0) {
                          throw ERROR;
                        } else if (message.constructor === ArrayBuffer) {
                          message = new Uint8Array(message);
                        }
                      }
                      if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
                        return crypto.createHash("md5").update(new Buffer(message)).digest("hex");
                      } else {
                        return method(message);
                      }
                    };
                    return nodeMethod;
                  };
                  function Md5(sharedMemory) {
                    if (sharedMemory) {
                      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                      this.blocks = blocks;
                      this.buffer8 = buffer8;
                    } else {
                      if (ARRAY_BUFFER) {
                        var buffer2 = new ArrayBuffer(68);
                        this.buffer8 = new Uint8Array(buffer2);
                        this.blocks = new Uint32Array(buffer2);
                      } else {
                        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                      }
                    }
                    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
                    this.finalized = this.hashed = false;
                    this.first = true;
                  }
                  Md5.prototype.update = function(message, isBinStr) {
                    if (this.finalized) {
                      return;
                    }
                    var code, index = 0, i, length = message.length, blocks2 = this.blocks;
                    var buffer82 = this.buffer8;
                    while (index < length) {
                      if (this.hashed) {
                        this.hashed = false;
                        blocks2[0] = blocks2[16];
                        blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
                      }
                      if (ARRAY_BUFFER) {
                        for (i = this.start; index < length && i < 64; ++index) {
                          code = message.charCodeAt(index);
                          if (isBinStr || code < 128) {
                            buffer82[i++] = code;
                          } else if (code < 2048) {
                            buffer82[i++] = 192 | code >> 6;
                            buffer82[i++] = 128 | code & 63;
                          } else if (code < 55296 || code >= 57344) {
                            buffer82[i++] = 224 | code >> 12;
                            buffer82[i++] = 128 | code >> 6 & 63;
                            buffer82[i++] = 128 | code & 63;
                          } else {
                            code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                            buffer82[i++] = 240 | code >> 18;
                            buffer82[i++] = 128 | code >> 12 & 63;
                            buffer82[i++] = 128 | code >> 6 & 63;
                            buffer82[i++] = 128 | code & 63;
                          }
                        }
                      } else {
                        for (i = this.start; index < length && i < 64; ++index) {
                          code = message.charCodeAt(index);
                          if (isBinStr || code < 128) {
                            blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                          } else if (code < 2048) {
                            blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                            blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                          } else if (code < 55296 || code >= 57344) {
                            blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                            blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                            blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                          } else {
                            code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                            blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                            blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                            blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                            blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                          }
                        }
                      }
                      this.lastByteIndex = i;
                      this.bytes += i - this.start;
                      if (i >= 64) {
                        this.start = i - 64;
                        this.hash();
                        this.hashed = true;
                      } else {
                        this.start = i;
                      }
                    }
                    if (this.bytes > 4294967295) {
                      this.hBytes += this.bytes / 4294967296 << 0;
                      this.bytes = this.bytes % 4294967296;
                    }
                    return this;
                  };
                  Md5.prototype.finalize = function() {
                    if (this.finalized) {
                      return;
                    }
                    this.finalized = true;
                    var blocks2 = this.blocks, i = this.lastByteIndex;
                    blocks2[i >> 2] |= EXTRA[i & 3];
                    if (i >= 56) {
                      if (!this.hashed) {
                        this.hash();
                      }
                      blocks2[0] = blocks2[16];
                      blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
                    }
                    blocks2[14] = this.bytes << 3;
                    blocks2[15] = this.hBytes << 3 | this.bytes >>> 29;
                    this.hash();
                  };
                  Md5.prototype.hash = function() {
                    var a, b, c, d, bc, da, blocks2 = this.blocks;
                    if (this.first) {
                      a = blocks2[0] - 680876937;
                      a = (a << 7 | a >>> 25) - 271733879 << 0;
                      d = (-1732584194 ^ a & 2004318071) + blocks2[1] - 117830708;
                      d = (d << 12 | d >>> 20) + a << 0;
                      c = (-271733879 ^ d & (a ^ -271733879)) + blocks2[2] - 1126478375;
                      c = (c << 17 | c >>> 15) + d << 0;
                      b = (a ^ c & (d ^ a)) + blocks2[3] - 1316259209;
                      b = (b << 22 | b >>> 10) + c << 0;
                    } else {
                      a = this.h0;
                      b = this.h1;
                      c = this.h2;
                      d = this.h3;
                      a += (d ^ b & (c ^ d)) + blocks2[0] - 680876936;
                      a = (a << 7 | a >>> 25) + b << 0;
                      d += (c ^ a & (b ^ c)) + blocks2[1] - 389564586;
                      d = (d << 12 | d >>> 20) + a << 0;
                      c += (b ^ d & (a ^ b)) + blocks2[2] + 606105819;
                      c = (c << 17 | c >>> 15) + d << 0;
                      b += (a ^ c & (d ^ a)) + blocks2[3] - 1044525330;
                      b = (b << 22 | b >>> 10) + c << 0;
                    }
                    a += (d ^ b & (c ^ d)) + blocks2[4] - 176418897;
                    a = (a << 7 | a >>> 25) + b << 0;
                    d += (c ^ a & (b ^ c)) + blocks2[5] + 1200080426;
                    d = (d << 12 | d >>> 20) + a << 0;
                    c += (b ^ d & (a ^ b)) + blocks2[6] - 1473231341;
                    c = (c << 17 | c >>> 15) + d << 0;
                    b += (a ^ c & (d ^ a)) + blocks2[7] - 45705983;
                    b = (b << 22 | b >>> 10) + c << 0;
                    a += (d ^ b & (c ^ d)) + blocks2[8] + 1770035416;
                    a = (a << 7 | a >>> 25) + b << 0;
                    d += (c ^ a & (b ^ c)) + blocks2[9] - 1958414417;
                    d = (d << 12 | d >>> 20) + a << 0;
                    c += (b ^ d & (a ^ b)) + blocks2[10] - 42063;
                    c = (c << 17 | c >>> 15) + d << 0;
                    b += (a ^ c & (d ^ a)) + blocks2[11] - 1990404162;
                    b = (b << 22 | b >>> 10) + c << 0;
                    a += (d ^ b & (c ^ d)) + blocks2[12] + 1804603682;
                    a = (a << 7 | a >>> 25) + b << 0;
                    d += (c ^ a & (b ^ c)) + blocks2[13] - 40341101;
                    d = (d << 12 | d >>> 20) + a << 0;
                    c += (b ^ d & (a ^ b)) + blocks2[14] - 1502002290;
                    c = (c << 17 | c >>> 15) + d << 0;
                    b += (a ^ c & (d ^ a)) + blocks2[15] + 1236535329;
                    b = (b << 22 | b >>> 10) + c << 0;
                    a += (c ^ d & (b ^ c)) + blocks2[1] - 165796510;
                    a = (a << 5 | a >>> 27) + b << 0;
                    d += (b ^ c & (a ^ b)) + blocks2[6] - 1069501632;
                    d = (d << 9 | d >>> 23) + a << 0;
                    c += (a ^ b & (d ^ a)) + blocks2[11] + 643717713;
                    c = (c << 14 | c >>> 18) + d << 0;
                    b += (d ^ a & (c ^ d)) + blocks2[0] - 373897302;
                    b = (b << 20 | b >>> 12) + c << 0;
                    a += (c ^ d & (b ^ c)) + blocks2[5] - 701558691;
                    a = (a << 5 | a >>> 27) + b << 0;
                    d += (b ^ c & (a ^ b)) + blocks2[10] + 38016083;
                    d = (d << 9 | d >>> 23) + a << 0;
                    c += (a ^ b & (d ^ a)) + blocks2[15] - 660478335;
                    c = (c << 14 | c >>> 18) + d << 0;
                    b += (d ^ a & (c ^ d)) + blocks2[4] - 405537848;
                    b = (b << 20 | b >>> 12) + c << 0;
                    a += (c ^ d & (b ^ c)) + blocks2[9] + 568446438;
                    a = (a << 5 | a >>> 27) + b << 0;
                    d += (b ^ c & (a ^ b)) + blocks2[14] - 1019803690;
                    d = (d << 9 | d >>> 23) + a << 0;
                    c += (a ^ b & (d ^ a)) + blocks2[3] - 187363961;
                    c = (c << 14 | c >>> 18) + d << 0;
                    b += (d ^ a & (c ^ d)) + blocks2[8] + 1163531501;
                    b = (b << 20 | b >>> 12) + c << 0;
                    a += (c ^ d & (b ^ c)) + blocks2[13] - 1444681467;
                    a = (a << 5 | a >>> 27) + b << 0;
                    d += (b ^ c & (a ^ b)) + blocks2[2] - 51403784;
                    d = (d << 9 | d >>> 23) + a << 0;
                    c += (a ^ b & (d ^ a)) + blocks2[7] + 1735328473;
                    c = (c << 14 | c >>> 18) + d << 0;
                    b += (d ^ a & (c ^ d)) + blocks2[12] - 1926607734;
                    b = (b << 20 | b >>> 12) + c << 0;
                    bc = b ^ c;
                    a += (bc ^ d) + blocks2[5] - 378558;
                    a = (a << 4 | a >>> 28) + b << 0;
                    d += (bc ^ a) + blocks2[8] - 2022574463;
                    d = (d << 11 | d >>> 21) + a << 0;
                    da = d ^ a;
                    c += (da ^ b) + blocks2[11] + 1839030562;
                    c = (c << 16 | c >>> 16) + d << 0;
                    b += (da ^ c) + blocks2[14] - 35309556;
                    b = (b << 23 | b >>> 9) + c << 0;
                    bc = b ^ c;
                    a += (bc ^ d) + blocks2[1] - 1530992060;
                    a = (a << 4 | a >>> 28) + b << 0;
                    d += (bc ^ a) + blocks2[4] + 1272893353;
                    d = (d << 11 | d >>> 21) + a << 0;
                    da = d ^ a;
                    c += (da ^ b) + blocks2[7] - 155497632;
                    c = (c << 16 | c >>> 16) + d << 0;
                    b += (da ^ c) + blocks2[10] - 1094730640;
                    b = (b << 23 | b >>> 9) + c << 0;
                    bc = b ^ c;
                    a += (bc ^ d) + blocks2[13] + 681279174;
                    a = (a << 4 | a >>> 28) + b << 0;
                    d += (bc ^ a) + blocks2[0] - 358537222;
                    d = (d << 11 | d >>> 21) + a << 0;
                    da = d ^ a;
                    c += (da ^ b) + blocks2[3] - 722521979;
                    c = (c << 16 | c >>> 16) + d << 0;
                    b += (da ^ c) + blocks2[6] + 76029189;
                    b = (b << 23 | b >>> 9) + c << 0;
                    bc = b ^ c;
                    a += (bc ^ d) + blocks2[9] - 640364487;
                    a = (a << 4 | a >>> 28) + b << 0;
                    d += (bc ^ a) + blocks2[12] - 421815835;
                    d = (d << 11 | d >>> 21) + a << 0;
                    da = d ^ a;
                    c += (da ^ b) + blocks2[15] + 530742520;
                    c = (c << 16 | c >>> 16) + d << 0;
                    b += (da ^ c) + blocks2[2] - 995338651;
                    b = (b << 23 | b >>> 9) + c << 0;
                    a += (c ^ (b | ~d)) + blocks2[0] - 198630844;
                    a = (a << 6 | a >>> 26) + b << 0;
                    d += (b ^ (a | ~c)) + blocks2[7] + 1126891415;
                    d = (d << 10 | d >>> 22) + a << 0;
                    c += (a ^ (d | ~b)) + blocks2[14] - 1416354905;
                    c = (c << 15 | c >>> 17) + d << 0;
                    b += (d ^ (c | ~a)) + blocks2[5] - 57434055;
                    b = (b << 21 | b >>> 11) + c << 0;
                    a += (c ^ (b | ~d)) + blocks2[12] + 1700485571;
                    a = (a << 6 | a >>> 26) + b << 0;
                    d += (b ^ (a | ~c)) + blocks2[3] - 1894986606;
                    d = (d << 10 | d >>> 22) + a << 0;
                    c += (a ^ (d | ~b)) + blocks2[10] - 1051523;
                    c = (c << 15 | c >>> 17) + d << 0;
                    b += (d ^ (c | ~a)) + blocks2[1] - 2054922799;
                    b = (b << 21 | b >>> 11) + c << 0;
                    a += (c ^ (b | ~d)) + blocks2[8] + 1873313359;
                    a = (a << 6 | a >>> 26) + b << 0;
                    d += (b ^ (a | ~c)) + blocks2[15] - 30611744;
                    d = (d << 10 | d >>> 22) + a << 0;
                    c += (a ^ (d | ~b)) + blocks2[6] - 1560198380;
                    c = (c << 15 | c >>> 17) + d << 0;
                    b += (d ^ (c | ~a)) + blocks2[13] + 1309151649;
                    b = (b << 21 | b >>> 11) + c << 0;
                    a += (c ^ (b | ~d)) + blocks2[4] - 145523070;
                    a = (a << 6 | a >>> 26) + b << 0;
                    d += (b ^ (a | ~c)) + blocks2[11] - 1120210379;
                    d = (d << 10 | d >>> 22) + a << 0;
                    c += (a ^ (d | ~b)) + blocks2[2] + 718787259;
                    c = (c << 15 | c >>> 17) + d << 0;
                    b += (d ^ (c | ~a)) + blocks2[9] - 343485551;
                    b = (b << 21 | b >>> 11) + c << 0;
                    if (this.first) {
                      this.h0 = a + 1732584193 << 0;
                      this.h1 = b - 271733879 << 0;
                      this.h2 = c - 1732584194 << 0;
                      this.h3 = d + 271733878 << 0;
                      this.first = false;
                    } else {
                      this.h0 = this.h0 + a << 0;
                      this.h1 = this.h1 + b << 0;
                      this.h2 = this.h2 + c << 0;
                      this.h3 = this.h3 + d << 0;
                    }
                  };
                  Md5.prototype.hex = function() {
                    this.finalize();
                    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
                    return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
                  };
                  Md5.prototype.toString = Md5.prototype.hex;
                  Md5.prototype.digest = function(format) {
                    if (format === "hex")
                      return this.hex();
                    this.finalize();
                    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
                    var res = [h0 & 255, h0 >> 8 & 255, h0 >> 16 & 255, h0 >> 24 & 255, h1 & 255, h1 >> 8 & 255, h1 >> 16 & 255, h1 >> 24 & 255, h2 & 255, h2 >> 8 & 255, h2 >> 16 & 255, h2 >> 24 & 255, h3 & 255, h3 >> 8 & 255, h3 >> 16 & 255, h3 >> 24 & 255];
                    return res;
                  };
                  Md5.prototype.array = Md5.prototype.digest;
                  Md5.prototype.arrayBuffer = function() {
                    this.finalize();
                    var buffer2 = new ArrayBuffer(16);
                    var blocks2 = new Uint32Array(buffer2);
                    blocks2[0] = this.h0;
                    blocks2[1] = this.h1;
                    blocks2[2] = this.h2;
                    blocks2[3] = this.h3;
                    return buffer2;
                  };
                  Md5.prototype.buffer = Md5.prototype.arrayBuffer;
                  Md5.prototype.base64 = function() {
                    var v1, v2, v3, base64Str = "", bytes = this.array();
                    for (var i = 0; i < 15; ) {
                      v1 = bytes[i++];
                      v2 = bytes[i++];
                      v3 = bytes[i++];
                      base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] + BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] + BASE64_ENCODE_CHAR[v3 & 63];
                    }
                    v1 = bytes[i];
                    base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[v1 << 4 & 63] + "==";
                    return base64Str;
                  };
                  var exports = createMethod();
                  if (COMMON_JS) {
                    module.exports = exports;
                  } else {
                    root.md5 = exports;
                    if (AMD) {
                      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                        return exports;
                      }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                    }
                  }
                })();
              }).call(this, __webpack_require__(
                /*! ./../node_modules/process/browser.js */
                "./node_modules/process/browser.js"
              ), __webpack_require__(
                /*! ./../node_modules/webpack/buildin/global.js */
                "./node_modules/webpack/buildin/global.js"
              ), __webpack_require__(
                /*! ./../node_modules/webpack/buildin/module.js */
                "./node_modules/webpack/buildin/module.js"
              )(module));
            }
          ),
          /***/
          "./lib/request.js": (
            /*!************************!*\
              !*** ./lib/request.js ***!
              \************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var _typeof2 = __webpack_require__2(
                /*! @babel/runtime/helpers/typeof */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              );
              var stringifyPrimitive = function stringifyPrimitive2(v) {
                switch (_typeof2(v)) {
                  case "string":
                    return v;
                  case "boolean":
                    return v ? "true" : "false";
                  case "number":
                    return isFinite(v) ? v : "";
                  default:
                    return "";
                }
              };
              var queryStringify = function queryStringify2(obj, sep, eq, name) {
                sep = sep || "&";
                eq = eq || "=";
                if (obj === null) {
                  obj = void 0;
                }
                if (_typeof2(obj) === "object") {
                  return Object.keys(obj).map(function(k) {
                    var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                    if (Array.isArray(obj[k])) {
                      return obj[k].map(function(v) {
                        return ks + encodeURIComponent(stringifyPrimitive(v));
                      }).join(sep);
                    } else {
                      return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                    }
                  }).filter(Boolean).join(sep);
                }
                if (!name)
                  return "";
                return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
              };
              var xhrRes = function xhrRes2(err, xhr, body) {
                var headers = {};
                xhr.getAllResponseHeaders().trim().split("\n").forEach(function(item) {
                  if (item) {
                    var index = item.indexOf(":");
                    var key = item.substr(0, index).trim().toLowerCase();
                    var val = item.substr(index + 1).trim();
                    headers[key] = val;
                  }
                });
                return {
                  error: err,
                  statusCode: xhr.status,
                  statusMessage: xhr.statusText,
                  headers,
                  body
                };
              };
              var xhrBody = function xhrBody2(xhr, dataType) {
                return !dataType && dataType === "text" ? xhr.responseText : xhr.response;
              };
              var request = function request2(opt, callback) {
                var method2 = (opt.method || "GET").toUpperCase();
                var url = opt.url;
                if (opt.qs) {
                  var qsStr = queryStringify(opt.qs);
                  if (qsStr) {
                    url += (url.indexOf("?") === -1 ? "?" : "&") + qsStr;
                  }
                }
                var xhr = new XMLHttpRequest();
                xhr.open(method2, url, true);
                xhr.responseType = opt.dataType || "text";
                if (opt.xhrFields) {
                  for (var xhrField in opt.xhrFields) {
                    xhr[xhrField] = opt.xhrFields[xhrField];
                  }
                }
                var headers = opt.headers;
                if (headers) {
                  for (var key in headers) {
                    if (headers.hasOwnProperty(key) && key.toLowerCase() !== "content-length" && key.toLowerCase() !== "user-agent" && key.toLowerCase() !== "origin" && key.toLowerCase() !== "host") {
                      xhr.setRequestHeader(key, headers[key]);
                    }
                  }
                }
                if (opt.onProgress && xhr.upload)
                  xhr.upload.onprogress = opt.onProgress;
                if (opt.onDownloadProgress)
                  xhr.onprogress = opt.onDownloadProgress;
                if (opt.timeout)
                  xhr.timeout = opt.timeout;
                xhr.ontimeout = function(event) {
                  var error = new Error("timeout");
                  callback(xhrRes(error, xhr));
                };
                xhr.onload = function() {
                  callback(xhrRes(null, xhr, xhrBody(xhr, opt.dataType)));
                };
                xhr.onerror = function(err) {
                  var body = xhrBody(xhr, opt.dataType);
                  if (body) {
                    callback(xhrRes(null, xhr, body));
                  } else {
                    var error = xhr.statusText;
                    if (!error && xhr.status === 0)
                      error = new Error("CORS blocked or network error");
                    callback(xhrRes(error, xhr, body));
                  }
                };
                xhr.send(opt.body || "");
                return xhr;
              };
              module2.exports = request;
            }
          ),
          /***/
          "./lib/xml2json.js": (
            /*!*************************!*\
              !*** ./lib/xml2json.js ***!
              \*************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var DOMParser = __webpack_require__2(
                /*! @xmldom/xmldom */
                "./node_modules/@xmldom/xmldom/lib/index.js"
              ).DOMParser;
              var xmlToJSON = function() {
                this.version = "1.3.5";
                var options = {
                  // set up the default options
                  mergeCDATA: true,
                  // extract cdata and merge with text
                  normalize: true,
                  // collapse multiple spaces to single space
                  stripElemPrefix: true
                  // for elements of same name in diff namespaces, you can enable namespaces and access the nskey property
                };
                var prefixMatch = new RegExp(/(?!xmlns)^.*:/);
                var trimMatch = new RegExp(/^\s+|\s+$/g);
                this.grokType = function(sValue) {
                  if (/^\s*$/.test(sValue)) {
                    return null;
                  }
                  if (/^(?:true|false)$/i.test(sValue)) {
                    return sValue.toLowerCase() === "true";
                  }
                  if (isFinite(sValue)) {
                    return parseFloat(sValue);
                  }
                  return sValue;
                };
                this.parseString = function(xmlString, opt) {
                  if (xmlString) {
                    var xml = this.stringToXML(xmlString);
                    if (xml.getElementsByTagName("parsererror").length) {
                      return null;
                    } else {
                      return this.parseXML(xml, opt);
                    }
                  } else {
                    return null;
                  }
                };
                this.parseXML = function(oXMLParent, opt) {
                  for (var key in opt) {
                    options[key] = opt[key];
                  }
                  var vResult = {}, nLength = 0, sCollectedTxt = "";
                  var childNum = oXMLParent.childNodes.length;
                  if (childNum) {
                    for (var oNode, sProp, vContent, nItem = 0; nItem < oXMLParent.childNodes.length; nItem++) {
                      oNode = oXMLParent.childNodes.item(nItem);
                      if (oNode.nodeType === 4) {
                        if (options.mergeCDATA) {
                          sCollectedTxt += oNode.nodeValue;
                        }
                      } else if (oNode.nodeType === 3) {
                        sCollectedTxt += oNode.nodeValue;
                      } else if (oNode.nodeType === 1) {
                        if (nLength === 0) {
                          vResult = {};
                        }
                        if (options.stripElemPrefix) {
                          sProp = oNode.nodeName.replace(prefixMatch, "");
                        } else {
                          sProp = oNode.nodeName;
                        }
                        vContent = xmlToJSON.parseXML(oNode);
                        if (vResult.hasOwnProperty(sProp)) {
                          if (vResult[sProp].constructor !== Array) {
                            vResult[sProp] = [vResult[sProp]];
                          }
                          vResult[sProp].push(vContent);
                        } else {
                          vResult[sProp] = vContent;
                          nLength++;
                        }
                      }
                    }
                  }
                  if (!Object.keys(vResult).length) {
                    vResult = sCollectedTxt || "";
                  }
                  return vResult;
                };
                this.xmlToString = function(xmlDoc) {
                  try {
                    var xmlString = xmlDoc.xml ? xmlDoc.xml : new XMLSerializer().serializeToString(xmlDoc);
                    return xmlString;
                  } catch (err) {
                    return null;
                  }
                };
                this.stringToXML = function(xmlString) {
                  try {
                    var xmlDoc = null;
                    if (window.DOMParser) {
                      var parser = new DOMParser();
                      xmlDoc = parser.parseFromString(xmlString, "text/xml");
                      return xmlDoc;
                    } else {
                      xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                      xmlDoc.async = false;
                      xmlDoc.loadXML(xmlString);
                      return xmlDoc;
                    }
                  } catch (e) {
                    return null;
                  }
                };
                return this;
              }.call({});
              var xml2json = function xml2json2(xmlString) {
                return xmlToJSON.parseString(xmlString);
              };
              module2.exports = xml2json;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/classCallCheck.js": (
            /*!***************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
              \***************************************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2) {
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              module2.exports = _classCallCheck, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/createClass.js": (
            /*!************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
              \************************************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var toPropertyKey = __webpack_require__2(
                /*! ./toPropertyKey.js */
                "./node_modules/@babel/runtime/helpers/toPropertyKey.js"
              );
              function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
                }
              }
              function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps)
                  _defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  _defineProperties(Constructor, staticProps);
                Object.defineProperty(Constructor, "prototype", {
                  writable: false
                });
                return Constructor;
              }
              module2.exports = _createClass, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/toPrimitive.js": (
            /*!************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
              \************************************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var _typeof2 = __webpack_require__2(
                /*! ./typeof.js */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              )["default"];
              function _toPrimitive(input, hint) {
                if (_typeof2(input) !== "object" || input === null)
                  return input;
                var prim = input[Symbol.toPrimitive];
                if (prim !== void 0) {
                  var res = prim.call(input, hint || "default");
                  if (_typeof2(res) !== "object")
                    return res;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return (hint === "string" ? String : Number)(input);
              }
              module2.exports = _toPrimitive, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/toPropertyKey.js": (
            /*!**************************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
              \**************************************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var _typeof2 = __webpack_require__2(
                /*! ./typeof.js */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              )["default"];
              var toPrimitive = __webpack_require__2(
                /*! ./toPrimitive.js */
                "./node_modules/@babel/runtime/helpers/toPrimitive.js"
              );
              function _toPropertyKey(arg) {
                var key = toPrimitive(arg, "string");
                return _typeof2(key) === "symbol" ? key : String(key);
              }
              module2.exports = _toPropertyKey, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
            }
          ),
          /***/
          "./node_modules/@babel/runtime/helpers/typeof.js": (
            /*!*******************************************************!*\
              !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
              \*******************************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2) {
              function _typeof2(o) {
                "@babel/helpers - typeof";
                return module2.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
                  return typeof o2;
                } : function(o2) {
                  return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
                }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof2(o);
              }
              module2.exports = _typeof2, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
            }
          ),
          /***/
          "./node_modules/@xmldom/xmldom/lib/conventions.js": (
            /*!********************************************************!*\
              !*** ./node_modules/@xmldom/xmldom/lib/conventions.js ***!
              \********************************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              "use strict";
              function find(list, predicate, ac) {
                if (ac === void 0) {
                  ac = Array.prototype;
                }
                if (list && typeof ac.find === "function") {
                  return ac.find.call(list, predicate);
                }
                for (var i = 0; i < list.length; i++) {
                  if (Object.prototype.hasOwnProperty.call(list, i)) {
                    var item = list[i];
                    if (predicate.call(void 0, item, i, list)) {
                      return item;
                    }
                  }
                }
              }
              function freeze(object, oc) {
                if (oc === void 0) {
                  oc = Object;
                }
                return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
              }
              function assign(target, source) {
                if (target === null || typeof target !== "object") {
                  throw new TypeError("target is not an object");
                }
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
                return target;
              }
              var MIME_TYPE = freeze({
                /**
                 * `text/html`, the only mime type that triggers treating an XML document as HTML.
                 *
                 * @see DOMParser.SupportedType.isHTML
                 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
                 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
                 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
                 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
                 */
                HTML: "text/html",
                /**
                 * Helper method to check a mime type if it indicates an HTML document
                 *
                 * @param {string} [value]
                 * @returns {boolean}
                 *
                 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
                 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
                 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
                 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
                isHTML: function(value) {
                  return value === MIME_TYPE.HTML;
                },
                /**
                 * `application/xml`, the standard mime type for XML documents.
                 *
                 * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
                 * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
                 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
                 */
                XML_APPLICATION: "application/xml",
                /**
                 * `text/html`, an alias for `application/xml`.
                 *
                 * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
                 * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
                 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
                 */
                XML_TEXT: "text/xml",
                /**
                 * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
                 * but is parsed as an XML document.
                 *
                 * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
                 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
                 * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
                 */
                XML_XHTML_APPLICATION: "application/xhtml+xml",
                /**
                 * `image/svg+xml`,
                 *
                 * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
                 * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
                 * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
                 */
                XML_SVG_IMAGE: "image/svg+xml"
              });
              var NAMESPACE = freeze({
                /**
                 * The XHTML namespace.
                 *
                 * @see http://www.w3.org/1999/xhtml
                 */
                HTML: "http://www.w3.org/1999/xhtml",
                /**
                 * Checks if `uri` equals `NAMESPACE.HTML`.
                 *
                 * @param {string} [uri]
                 *
                 * @see NAMESPACE.HTML
                 */
                isHTML: function(uri) {
                  return uri === NAMESPACE.HTML;
                },
                /**
                 * The SVG namespace.
                 *
                 * @see http://www.w3.org/2000/svg
                 */
                SVG: "http://www.w3.org/2000/svg",
                /**
                 * The `xml:` namespace.
                 *
                 * @see http://www.w3.org/XML/1998/namespace
                 */
                XML: "http://www.w3.org/XML/1998/namespace",
                /**
                 * The `xmlns:` namespace
                 *
                 * @see https://www.w3.org/2000/xmlns/
                 */
                XMLNS: "http://www.w3.org/2000/xmlns/"
              });
              exports2.assign = assign;
              exports2.find = find;
              exports2.freeze = freeze;
              exports2.MIME_TYPE = MIME_TYPE;
              exports2.NAMESPACE = NAMESPACE;
            }
          ),
          /***/
          "./node_modules/@xmldom/xmldom/lib/dom-parser.js": (
            /*!*******************************************************!*\
              !*** ./node_modules/@xmldom/xmldom/lib/dom-parser.js ***!
              \*******************************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var conventions = __webpack_require__2(
                /*! ./conventions */
                "./node_modules/@xmldom/xmldom/lib/conventions.js"
              );
              var dom = __webpack_require__2(
                /*! ./dom */
                "./node_modules/@xmldom/xmldom/lib/dom.js"
              );
              var entities = __webpack_require__2(
                /*! ./entities */
                "./node_modules/@xmldom/xmldom/lib/entities.js"
              );
              var sax = __webpack_require__2(
                /*! ./sax */
                "./node_modules/@xmldom/xmldom/lib/sax.js"
              );
              var DOMImplementation = dom.DOMImplementation;
              var NAMESPACE = conventions.NAMESPACE;
              var ParseError = sax.ParseError;
              var XMLReader = sax.XMLReader;
              function normalizeLineEndings(input) {
                return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
              }
              function DOMParser(options) {
                this.options = options || { locator: {} };
              }
              DOMParser.prototype.parseFromString = function(source, mimeType) {
                var options = this.options;
                var sax2 = new XMLReader();
                var domBuilder = options.domBuilder || new DOMHandler();
                var errorHandler = options.errorHandler;
                var locator = options.locator;
                var defaultNSMap = options.xmlns || {};
                var isHTML = /\/x?html?$/.test(mimeType);
                var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
                if (locator) {
                  domBuilder.setDocumentLocator(locator);
                }
                sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
                sax2.domBuilder = options.domBuilder || domBuilder;
                if (isHTML) {
                  defaultNSMap[""] = NAMESPACE.HTML;
                }
                defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
                var normalize = options.normalizeLineEndings || normalizeLineEndings;
                if (source && typeof source === "string") {
                  sax2.parse(
                    normalize(source),
                    defaultNSMap,
                    entityMap
                  );
                } else {
                  sax2.errorHandler.error("invalid doc source");
                }
                return domBuilder.doc;
              };
              function buildErrorHandler(errorImpl, domBuilder, locator) {
                if (!errorImpl) {
                  if (domBuilder instanceof DOMHandler) {
                    return domBuilder;
                  }
                  errorImpl = domBuilder;
                }
                var errorHandler = {};
                var isCallback = errorImpl instanceof Function;
                locator = locator || {};
                function build(key) {
                  var fn = errorImpl[key];
                  if (!fn && isCallback) {
                    fn = errorImpl.length == 2 ? function(msg) {
                      errorImpl(key, msg);
                    } : errorImpl;
                  }
                  errorHandler[key] = fn && function(msg) {
                    fn("[xmldom " + key + "]	" + msg + _locator(locator));
                  } || function() {
                  };
                }
                build("warning");
                build("error");
                build("fatalError");
                return errorHandler;
              }
              function DOMHandler() {
                this.cdata = false;
              }
              function position(locator, node) {
                node.lineNumber = locator.lineNumber;
                node.columnNumber = locator.columnNumber;
              }
              DOMHandler.prototype = {
                startDocument: function() {
                  this.doc = new DOMImplementation().createDocument(null, null, null);
                  if (this.locator) {
                    this.doc.documentURI = this.locator.systemId;
                  }
                },
                startElement: function(namespaceURI, localName, qName, attrs) {
                  var doc = this.doc;
                  var el = doc.createElementNS(namespaceURI, qName || localName);
                  var len = attrs.length;
                  appendElement(this, el);
                  this.currentElement = el;
                  this.locator && position(this.locator, el);
                  for (var i = 0; i < len; i++) {
                    var namespaceURI = attrs.getURI(i);
                    var value = attrs.getValue(i);
                    var qName = attrs.getQName(i);
                    var attr = doc.createAttributeNS(namespaceURI, qName);
                    this.locator && position(attrs.getLocator(i), attr);
                    attr.value = attr.nodeValue = value;
                    el.setAttributeNode(attr);
                  }
                },
                endElement: function(namespaceURI, localName, qName) {
                  var current = this.currentElement;
                  var tagName = current.tagName;
                  this.currentElement = current.parentNode;
                },
                startPrefixMapping: function(prefix, uri) {
                },
                endPrefixMapping: function(prefix) {
                },
                processingInstruction: function(target, data) {
                  var ins = this.doc.createProcessingInstruction(target, data);
                  this.locator && position(this.locator, ins);
                  appendElement(this, ins);
                },
                ignorableWhitespace: function(ch, start, length) {
                },
                characters: function(chars, start, length) {
                  chars = _toString.apply(this, arguments);
                  if (chars) {
                    if (this.cdata) {
                      var charNode = this.doc.createCDATASection(chars);
                    } else {
                      var charNode = this.doc.createTextNode(chars);
                    }
                    if (this.currentElement) {
                      this.currentElement.appendChild(charNode);
                    } else if (/^\s*$/.test(chars)) {
                      this.doc.appendChild(charNode);
                    }
                    this.locator && position(this.locator, charNode);
                  }
                },
                skippedEntity: function(name) {
                },
                endDocument: function() {
                  this.doc.normalize();
                },
                setDocumentLocator: function(locator) {
                  if (this.locator = locator) {
                    locator.lineNumber = 0;
                  }
                },
                //LexicalHandler
                comment: function(chars, start, length) {
                  chars = _toString.apply(this, arguments);
                  var comm = this.doc.createComment(chars);
                  this.locator && position(this.locator, comm);
                  appendElement(this, comm);
                },
                startCDATA: function() {
                  this.cdata = true;
                },
                endCDATA: function() {
                  this.cdata = false;
                },
                startDTD: function(name, publicId, systemId) {
                  var impl = this.doc.implementation;
                  if (impl && impl.createDocumentType) {
                    var dt = impl.createDocumentType(name, publicId, systemId);
                    this.locator && position(this.locator, dt);
                    appendElement(this, dt);
                    this.doc.doctype = dt;
                  }
                },
                /**
                 * @see org.xml.sax.ErrorHandler
                 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
                 */
                warning: function(error) {
                  console.warn("[xmldom warning]	" + error, _locator(this.locator));
                },
                error: function(error) {
                  console.error("[xmldom error]	" + error, _locator(this.locator));
                },
                fatalError: function(error) {
                  throw new ParseError(error, this.locator);
                }
              };
              function _locator(l) {
                if (l) {
                  return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
                }
              }
              function _toString(chars, start, length) {
                if (typeof chars == "string") {
                  return chars.substr(start, length);
                } else {
                  if (chars.length >= start + length || start) {
                    return new java.lang.String(chars, start, length) + "";
                  }
                  return chars;
                }
              }
              "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
                DOMHandler.prototype[key] = function() {
                  return null;
                };
              });
              function appendElement(hander, node) {
                if (!hander.currentElement) {
                  hander.doc.appendChild(node);
                } else {
                  hander.currentElement.appendChild(node);
                }
              }
              exports2.__DOMHandler = DOMHandler;
              exports2.normalizeLineEndings = normalizeLineEndings;
              exports2.DOMParser = DOMParser;
            }
          ),
          /***/
          "./node_modules/@xmldom/xmldom/lib/dom.js": (
            /*!************************************************!*\
              !*** ./node_modules/@xmldom/xmldom/lib/dom.js ***!
              \************************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var conventions = __webpack_require__2(
                /*! ./conventions */
                "./node_modules/@xmldom/xmldom/lib/conventions.js"
              );
              var find = conventions.find;
              var NAMESPACE = conventions.NAMESPACE;
              function notEmptyString(input) {
                return input !== "";
              }
              function splitOnASCIIWhitespace(input) {
                return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
              }
              function orderedSetReducer(current, element) {
                if (!current.hasOwnProperty(element)) {
                  current[element] = true;
                }
                return current;
              }
              function toOrderedSet(input) {
                if (!input)
                  return [];
                var list = splitOnASCIIWhitespace(input);
                return Object.keys(list.reduce(orderedSetReducer, {}));
              }
              function arrayIncludes(list) {
                return function(element) {
                  return list && list.indexOf(element) !== -1;
                };
              }
              function copy(src, dest) {
                for (var p in src) {
                  if (Object.prototype.hasOwnProperty.call(src, p)) {
                    dest[p] = src[p];
                  }
                }
              }
              function _extends(Class, Super) {
                var pt = Class.prototype;
                if (!(pt instanceof Super)) {
                  let t2 = function() {
                  };
                  var t = t2;
                  ;
                  t2.prototype = Super.prototype;
                  t2 = new t2();
                  copy(pt, t2);
                  Class.prototype = pt = t2;
                }
                if (pt.constructor != Class) {
                  if (typeof Class != "function") {
                    console.error("unknown Class:" + Class);
                  }
                  pt.constructor = Class;
                }
              }
              var NodeType = {};
              var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
              var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
              var TEXT_NODE = NodeType.TEXT_NODE = 3;
              var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
              var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
              var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
              var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
              var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
              var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
              var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
              var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
              var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
              var ExceptionCode = {};
              var ExceptionMessage = {};
              var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
              var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
              var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
              var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
              var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
              var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
              var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
              var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
              var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
              var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
              var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
              var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
              var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
              var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
              var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
              function DOMException(code, message) {
                if (message instanceof Error) {
                  var error = message;
                } else {
                  error = this;
                  Error.call(this, ExceptionMessage[code]);
                  this.message = ExceptionMessage[code];
                  if (Error.captureStackTrace)
                    Error.captureStackTrace(this, DOMException);
                }
                error.code = code;
                if (message)
                  this.message = this.message + ": " + message;
                return error;
              }
              ;
              DOMException.prototype = Error.prototype;
              copy(ExceptionCode, DOMException);
              function NodeList() {
              }
              ;
              NodeList.prototype = {
                /**
                 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
                 * @standard level1
                 */
                length: 0,
                /**
                 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
                 * @standard level1
                 * @param index  unsigned long
                 *   Index into the collection.
                 * @return Node
                 * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
                 */
                item: function(index) {
                  return index >= 0 && index < this.length ? this[index] : null;
                },
                toString: function(isHTML, nodeFilter) {
                  for (var buf = [], i = 0; i < this.length; i++) {
                    serializeToString(this[i], buf, isHTML, nodeFilter);
                  }
                  return buf.join("");
                },
                /**
                 * @private
                 * @param {function (Node):boolean} predicate
                 * @returns {Node[]}
                 */
                filter: function(predicate) {
                  return Array.prototype.filter.call(this, predicate);
                },
                /**
                 * @private
                 * @param {Node} item
                 * @returns {number}
                 */
                indexOf: function(item) {
                  return Array.prototype.indexOf.call(this, item);
                }
              };
              function LiveNodeList(node, refresh) {
                this._node = node;
                this._refresh = refresh;
                _updateLiveList(this);
              }
              function _updateLiveList(list) {
                var inc = list._node._inc || list._node.ownerDocument._inc;
                if (list._inc !== inc) {
                  var ls = list._refresh(list._node);
                  __set__(list, "length", ls.length);
                  if (!list.$$length || ls.length < list.$$length) {
                    for (var i = ls.length; i in list; i++) {
                      if (Object.prototype.hasOwnProperty.call(list, i)) {
                        delete list[i];
                      }
                    }
                  }
                  copy(ls, list);
                  list._inc = inc;
                }
              }
              LiveNodeList.prototype.item = function(i) {
                _updateLiveList(this);
                return this[i] || null;
              };
              _extends(LiveNodeList, NodeList);
              function NamedNodeMap() {
              }
              ;
              function _findNodeIndex(list, node) {
                var i = list.length;
                while (i--) {
                  if (list[i] === node) {
                    return i;
                  }
                }
              }
              function _addNamedNode(el, list, newAttr, oldAttr) {
                if (oldAttr) {
                  list[_findNodeIndex(list, oldAttr)] = newAttr;
                } else {
                  list[list.length++] = newAttr;
                }
                if (el) {
                  newAttr.ownerElement = el;
                  var doc = el.ownerDocument;
                  if (doc) {
                    oldAttr && _onRemoveAttribute(doc, el, oldAttr);
                    _onAddAttribute(doc, el, newAttr);
                  }
                }
              }
              function _removeNamedNode(el, list, attr) {
                var i = _findNodeIndex(list, attr);
                if (i >= 0) {
                  var lastIndex = list.length - 1;
                  while (i < lastIndex) {
                    list[i] = list[++i];
                  }
                  list.length = lastIndex;
                  if (el) {
                    var doc = el.ownerDocument;
                    if (doc) {
                      _onRemoveAttribute(doc, el, attr);
                      attr.ownerElement = null;
                    }
                  }
                } else {
                  throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
                }
              }
              NamedNodeMap.prototype = {
                length: 0,
                item: NodeList.prototype.item,
                getNamedItem: function(key) {
                  var i = this.length;
                  while (i--) {
                    var attr = this[i];
                    if (attr.nodeName == key) {
                      return attr;
                    }
                  }
                },
                setNamedItem: function(attr) {
                  var el = attr.ownerElement;
                  if (el && el != this._ownerElement) {
                    throw new DOMException(INUSE_ATTRIBUTE_ERR);
                  }
                  var oldAttr = this.getNamedItem(attr.nodeName);
                  _addNamedNode(this._ownerElement, this, attr, oldAttr);
                  return oldAttr;
                },
                /* returns Node */
                setNamedItemNS: function(attr) {
                  var el = attr.ownerElement, oldAttr;
                  if (el && el != this._ownerElement) {
                    throw new DOMException(INUSE_ATTRIBUTE_ERR);
                  }
                  oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
                  _addNamedNode(this._ownerElement, this, attr, oldAttr);
                  return oldAttr;
                },
                /* returns Node */
                removeNamedItem: function(key) {
                  var attr = this.getNamedItem(key);
                  _removeNamedNode(this._ownerElement, this, attr);
                  return attr;
                },
                // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
                //for level2
                removeNamedItemNS: function(namespaceURI, localName) {
                  var attr = this.getNamedItemNS(namespaceURI, localName);
                  _removeNamedNode(this._ownerElement, this, attr);
                  return attr;
                },
                getNamedItemNS: function(namespaceURI, localName) {
                  var i = this.length;
                  while (i--) {
                    var node = this[i];
                    if (node.localName == localName && node.namespaceURI == namespaceURI) {
                      return node;
                    }
                  }
                  return null;
                }
              };
              function DOMImplementation() {
              }
              DOMImplementation.prototype = {
                /**
                 * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
                 * The different implementations fairly diverged in what kind of features were reported.
                 * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
                 *
                 * @deprecated It is deprecated and modern browsers return true in all cases.
                 *
                 * @param {string} feature
                 * @param {string} [version]
                 * @returns {boolean} always true
                 *
                 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
                 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
                 * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
                 */
                hasFeature: function(feature, version) {
                  return true;
                },
                /**
                 * Creates an XML Document object of the specified type with its document element.
                 *
                 * __It behaves slightly different from the description in the living standard__:
                 * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
                 * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
                 * - this implementation is not validating names or qualified names
                 *   (when parsing XML strings, the SAX parser takes care of that)
                 *
                 * @param {string|null} namespaceURI
                 * @param {string} qualifiedName
                 * @param {DocumentType=null} doctype
                 * @returns {Document}
                 *
                 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
                 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
                 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
                 *
                 * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
                 * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
                 * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
                 */
                createDocument: function(namespaceURI, qualifiedName, doctype) {
                  var doc = new Document();
                  doc.implementation = this;
                  doc.childNodes = new NodeList();
                  doc.doctype = doctype || null;
                  if (doctype) {
                    doc.appendChild(doctype);
                  }
                  if (qualifiedName) {
                    var root2 = doc.createElementNS(namespaceURI, qualifiedName);
                    doc.appendChild(root2);
                  }
                  return doc;
                },
                /**
                 * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
                 *
                 * __This behavior is slightly different from the in the specs__:
                 * - this implementation is not validating names or qualified names
                 *   (when parsing XML strings, the SAX parser takes care of that)
                 *
                 * @param {string} qualifiedName
                 * @param {string} [publicId]
                 * @param {string} [systemId]
                 * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
                 * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
                 *
                 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
                 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
                 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
                 *
                 * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
                 * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
                 * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
                 */
                createDocumentType: function(qualifiedName, publicId, systemId) {
                  var node = new DocumentType();
                  node.name = qualifiedName;
                  node.nodeName = qualifiedName;
                  node.publicId = publicId || "";
                  node.systemId = systemId || "";
                  return node;
                }
              };
              function Node() {
              }
              ;
              Node.prototype = {
                firstChild: null,
                lastChild: null,
                previousSibling: null,
                nextSibling: null,
                attributes: null,
                parentNode: null,
                childNodes: null,
                ownerDocument: null,
                nodeValue: null,
                namespaceURI: null,
                prefix: null,
                localName: null,
                // Modified in DOM Level 2:
                insertBefore: function(newChild, refChild) {
                  return _insertBefore(this, newChild, refChild);
                },
                replaceChild: function(newChild, oldChild) {
                  _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
                  if (oldChild) {
                    this.removeChild(oldChild);
                  }
                },
                removeChild: function(oldChild) {
                  return _removeChild(this, oldChild);
                },
                appendChild: function(newChild) {
                  return this.insertBefore(newChild, null);
                },
                hasChildNodes: function() {
                  return this.firstChild != null;
                },
                cloneNode: function(deep) {
                  return cloneNode(this.ownerDocument || this, this, deep);
                },
                // Modified in DOM Level 2:
                normalize: function() {
                  var child = this.firstChild;
                  while (child) {
                    var next = child.nextSibling;
                    if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
                      this.removeChild(next);
                      child.appendData(next.data);
                    } else {
                      child.normalize();
                      child = next;
                    }
                  }
                },
                // Introduced in DOM Level 2:
                isSupported: function(feature, version) {
                  return this.ownerDocument.implementation.hasFeature(feature, version);
                },
                // Introduced in DOM Level 2:
                hasAttributes: function() {
                  return this.attributes.length > 0;
                },
                /**
                 * Look up the prefix associated to the given namespace URI, starting from this node.
                 * **The default namespace declarations are ignored by this method.**
                 * See Namespace Prefix Lookup for details on the algorithm used by this method.
                 *
                 * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
                 *
                 * @param {string | null} namespaceURI
                 * @returns {string | null}
                 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
                 * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
                 * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
                 * @see https://github.com/xmldom/xmldom/issues/322
                 */
                lookupPrefix: function(namespaceURI) {
                  var el = this;
                  while (el) {
                    var map = el._nsMap;
                    if (map) {
                      for (var n in map) {
                        if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
                          return n;
                        }
                      }
                    }
                    el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
                  }
                  return null;
                },
                // Introduced in DOM Level 3:
                lookupNamespaceURI: function(prefix) {
                  var el = this;
                  while (el) {
                    var map = el._nsMap;
                    if (map) {
                      if (Object.prototype.hasOwnProperty.call(map, prefix)) {
                        return map[prefix];
                      }
                    }
                    el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
                  }
                  return null;
                },
                // Introduced in DOM Level 3:
                isDefaultNamespace: function(namespaceURI) {
                  var prefix = this.lookupPrefix(namespaceURI);
                  return prefix == null;
                }
              };
              function _xmlEncoder(c) {
                return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
              }
              copy(NodeType, Node);
              copy(NodeType, Node.prototype);
              function _visitNode(node, callback) {
                if (callback(node)) {
                  return true;
                }
                if (node = node.firstChild) {
                  do {
                    if (_visitNode(node, callback)) {
                      return true;
                    }
                  } while (node = node.nextSibling);
                }
              }
              function Document() {
                this.ownerDocument = this;
              }
              function _onAddAttribute(doc, el, newAttr) {
                doc && doc._inc++;
                var ns = newAttr.namespaceURI;
                if (ns === NAMESPACE.XMLNS) {
                  el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
                }
              }
              function _onRemoveAttribute(doc, el, newAttr, remove) {
                doc && doc._inc++;
                var ns = newAttr.namespaceURI;
                if (ns === NAMESPACE.XMLNS) {
                  delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
                }
              }
              function _onUpdateChild(doc, el, newChild) {
                if (doc && doc._inc) {
                  doc._inc++;
                  var cs = el.childNodes;
                  if (newChild) {
                    cs[cs.length++] = newChild;
                  } else {
                    var child = el.firstChild;
                    var i = 0;
                    while (child) {
                      cs[i++] = child;
                      child = child.nextSibling;
                    }
                    cs.length = i;
                    delete cs[cs.length];
                  }
                }
              }
              function _removeChild(parentNode, child) {
                var previous = child.previousSibling;
                var next = child.nextSibling;
                if (previous) {
                  previous.nextSibling = next;
                } else {
                  parentNode.firstChild = next;
                }
                if (next) {
                  next.previousSibling = previous;
                } else {
                  parentNode.lastChild = previous;
                }
                child.parentNode = null;
                child.previousSibling = null;
                child.nextSibling = null;
                _onUpdateChild(parentNode.ownerDocument, parentNode);
                return child;
              }
              function hasValidParentNodeType(node) {
                return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
              }
              function hasInsertableNodeType(node) {
                return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
              }
              function isDocTypeNode(node) {
                return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
              }
              function isElementNode(node) {
                return node && node.nodeType === Node.ELEMENT_NODE;
              }
              function isTextNode(node) {
                return node && node.nodeType === Node.TEXT_NODE;
              }
              function isElementInsertionPossible(doc, child) {
                var parentChildNodes = doc.childNodes || [];
                if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
                  return false;
                }
                var docTypeNode = find(parentChildNodes, isDocTypeNode);
                return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
              }
              function isElementReplacementPossible(doc, child) {
                var parentChildNodes = doc.childNodes || [];
                function hasElementChildThatIsNotChild(node) {
                  return isElementNode(node) && node !== child;
                }
                if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
                  return false;
                }
                var docTypeNode = find(parentChildNodes, isDocTypeNode);
                return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
              }
              function assertPreInsertionValidity1to5(parent, node, child) {
                if (!hasValidParentNodeType(parent)) {
                  throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
                }
                if (child && child.parentNode !== parent) {
                  throw new DOMException(NOT_FOUND_ERR, "child not in parent");
                }
                if (
                  // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
                  !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
                  // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
                  // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
                  // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
                  isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
                ) {
                  throw new DOMException(
                    HIERARCHY_REQUEST_ERR,
                    "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
                  );
                }
              }
              function assertPreInsertionValidityInDocument(parent, node, child) {
                var parentChildNodes = parent.childNodes || [];
                var nodeChildNodes = node.childNodes || [];
                if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  var nodeChildElements = nodeChildNodes.filter(isElementNode);
                  if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
                    throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
                  }
                  if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
                    throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
                  }
                }
                if (isElementNode(node)) {
                  if (!isElementInsertionPossible(parent, child)) {
                    throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
                  }
                }
                if (isDocTypeNode(node)) {
                  if (find(parentChildNodes, isDocTypeNode)) {
                    throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
                  }
                  var parentElementChild = find(parentChildNodes, isElementNode);
                  if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
                    throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
                  }
                  if (!child && parentElementChild) {
                    throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
                  }
                }
              }
              function assertPreReplacementValidityInDocument(parent, node, child) {
                var parentChildNodes = parent.childNodes || [];
                var nodeChildNodes = node.childNodes || [];
                if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  var nodeChildElements = nodeChildNodes.filter(isElementNode);
                  if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
                    throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
                  }
                  if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
                    throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
                  }
                }
                if (isElementNode(node)) {
                  if (!isElementReplacementPossible(parent, child)) {
                    throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
                  }
                }
                if (isDocTypeNode(node)) {
                  let hasDoctypeChildThatIsNotChild2 = function(node2) {
                    return isDocTypeNode(node2) && node2 !== child;
                  };
                  var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
                  if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
                    throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
                  }
                  var parentElementChild = find(parentChildNodes, isElementNode);
                  if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
                    throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
                  }
                }
              }
              function _insertBefore(parent, node, child, _inDocumentAssertion) {
                assertPreInsertionValidity1to5(parent, node, child);
                if (parent.nodeType === Node.DOCUMENT_NODE) {
                  (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
                }
                var cp = node.parentNode;
                if (cp) {
                  cp.removeChild(node);
                }
                if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
                  var newFirst = node.firstChild;
                  if (newFirst == null) {
                    return node;
                  }
                  var newLast = node.lastChild;
                } else {
                  newFirst = newLast = node;
                }
                var pre = child ? child.previousSibling : parent.lastChild;
                newFirst.previousSibling = pre;
                newLast.nextSibling = child;
                if (pre) {
                  pre.nextSibling = newFirst;
                } else {
                  parent.firstChild = newFirst;
                }
                if (child == null) {
                  parent.lastChild = newLast;
                } else {
                  child.previousSibling = newLast;
                }
                do {
                  newFirst.parentNode = parent;
                } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
                _onUpdateChild(parent.ownerDocument || parent, parent);
                if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
                  node.firstChild = node.lastChild = null;
                }
                return node;
              }
              function _appendSingleChild(parentNode, newChild) {
                if (newChild.parentNode) {
                  newChild.parentNode.removeChild(newChild);
                }
                newChild.parentNode = parentNode;
                newChild.previousSibling = parentNode.lastChild;
                newChild.nextSibling = null;
                if (newChild.previousSibling) {
                  newChild.previousSibling.nextSibling = newChild;
                } else {
                  parentNode.firstChild = newChild;
                }
                parentNode.lastChild = newChild;
                _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
                return newChild;
              }
              Document.prototype = {
                //implementation : null,
                nodeName: "#document",
                nodeType: DOCUMENT_NODE,
                /**
                 * The DocumentType node of the document.
                 *
                 * @readonly
                 * @type DocumentType
                 */
                doctype: null,
                documentElement: null,
                _inc: 1,
                insertBefore: function(newChild, refChild) {
                  if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
                    var child = newChild.firstChild;
                    while (child) {
                      var next = child.nextSibling;
                      this.insertBefore(child, refChild);
                      child = next;
                    }
                    return newChild;
                  }
                  _insertBefore(this, newChild, refChild);
                  newChild.ownerDocument = this;
                  if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
                    this.documentElement = newChild;
                  }
                  return newChild;
                },
                removeChild: function(oldChild) {
                  if (this.documentElement == oldChild) {
                    this.documentElement = null;
                  }
                  return _removeChild(this, oldChild);
                },
                replaceChild: function(newChild, oldChild) {
                  _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
                  newChild.ownerDocument = this;
                  if (oldChild) {
                    this.removeChild(oldChild);
                  }
                  if (isElementNode(newChild)) {
                    this.documentElement = newChild;
                  }
                },
                // Introduced in DOM Level 2:
                importNode: function(importedNode, deep) {
                  return importNode(this, importedNode, deep);
                },
                // Introduced in DOM Level 2:
                getElementById: function(id) {
                  var rtv = null;
                  _visitNode(this.documentElement, function(node) {
                    if (node.nodeType == ELEMENT_NODE) {
                      if (node.getAttribute("id") == id) {
                        rtv = node;
                        return true;
                      }
                    }
                  });
                  return rtv;
                },
                /**
                 * The `getElementsByClassName` method of `Document` interface returns an array-like object
                 * of all child elements which have **all** of the given class name(s).
                 *
                 * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
                 *
                 *
                 * Warning: This is a live LiveNodeList.
                 * Changes in the DOM will reflect in the array as the changes occur.
                 * If an element selected by this array no longer qualifies for the selector,
                 * it will automatically be removed. Be aware of this for iteration purposes.
                 *
                 * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
                 *
                 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
                 * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
                 */
                getElementsByClassName: function(classNames) {
                  var classNamesSet = toOrderedSet(classNames);
                  return new LiveNodeList(this, function(base) {
                    var ls = [];
                    if (classNamesSet.length > 0) {
                      _visitNode(base.documentElement, function(node) {
                        if (node !== base && node.nodeType === ELEMENT_NODE) {
                          var nodeClassNames = node.getAttribute("class");
                          if (nodeClassNames) {
                            var matches = classNames === nodeClassNames;
                            if (!matches) {
                              var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                              matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                            }
                            if (matches) {
                              ls.push(node);
                            }
                          }
                        }
                      });
                    }
                    return ls;
                  });
                },
                //document factory method:
                createElement: function(tagName) {
                  var node = new Element();
                  node.ownerDocument = this;
                  node.nodeName = tagName;
                  node.tagName = tagName;
                  node.localName = tagName;
                  node.childNodes = new NodeList();
                  var attrs = node.attributes = new NamedNodeMap();
                  attrs._ownerElement = node;
                  return node;
                },
                createDocumentFragment: function() {
                  var node = new DocumentFragment();
                  node.ownerDocument = this;
                  node.childNodes = new NodeList();
                  return node;
                },
                createTextNode: function(data) {
                  var node = new Text();
                  node.ownerDocument = this;
                  node.appendData(data);
                  return node;
                },
                createComment: function(data) {
                  var node = new Comment();
                  node.ownerDocument = this;
                  node.appendData(data);
                  return node;
                },
                createCDATASection: function(data) {
                  var node = new CDATASection();
                  node.ownerDocument = this;
                  node.appendData(data);
                  return node;
                },
                createProcessingInstruction: function(target, data) {
                  var node = new ProcessingInstruction();
                  node.ownerDocument = this;
                  node.tagName = node.nodeName = node.target = target;
                  node.nodeValue = node.data = data;
                  return node;
                },
                createAttribute: function(name) {
                  var node = new Attr();
                  node.ownerDocument = this;
                  node.name = name;
                  node.nodeName = name;
                  node.localName = name;
                  node.specified = true;
                  return node;
                },
                createEntityReference: function(name) {
                  var node = new EntityReference();
                  node.ownerDocument = this;
                  node.nodeName = name;
                  return node;
                },
                // Introduced in DOM Level 2:
                createElementNS: function(namespaceURI, qualifiedName) {
                  var node = new Element();
                  var pl = qualifiedName.split(":");
                  var attrs = node.attributes = new NamedNodeMap();
                  node.childNodes = new NodeList();
                  node.ownerDocument = this;
                  node.nodeName = qualifiedName;
                  node.tagName = qualifiedName;
                  node.namespaceURI = namespaceURI;
                  if (pl.length == 2) {
                    node.prefix = pl[0];
                    node.localName = pl[1];
                  } else {
                    node.localName = qualifiedName;
                  }
                  attrs._ownerElement = node;
                  return node;
                },
                // Introduced in DOM Level 2:
                createAttributeNS: function(namespaceURI, qualifiedName) {
                  var node = new Attr();
                  var pl = qualifiedName.split(":");
                  node.ownerDocument = this;
                  node.nodeName = qualifiedName;
                  node.name = qualifiedName;
                  node.namespaceURI = namespaceURI;
                  node.specified = true;
                  if (pl.length == 2) {
                    node.prefix = pl[0];
                    node.localName = pl[1];
                  } else {
                    node.localName = qualifiedName;
                  }
                  return node;
                }
              };
              _extends(Document, Node);
              function Element() {
                this._nsMap = {};
              }
              ;
              Element.prototype = {
                nodeType: ELEMENT_NODE,
                hasAttribute: function(name) {
                  return this.getAttributeNode(name) != null;
                },
                getAttribute: function(name) {
                  var attr = this.getAttributeNode(name);
                  return attr && attr.value || "";
                },
                getAttributeNode: function(name) {
                  return this.attributes.getNamedItem(name);
                },
                setAttribute: function(name, value) {
                  var attr = this.ownerDocument.createAttribute(name);
                  attr.value = attr.nodeValue = "" + value;
                  this.setAttributeNode(attr);
                },
                removeAttribute: function(name) {
                  var attr = this.getAttributeNode(name);
                  attr && this.removeAttributeNode(attr);
                },
                //four real opeartion method
                appendChild: function(newChild) {
                  if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
                    return this.insertBefore(newChild, null);
                  } else {
                    return _appendSingleChild(this, newChild);
                  }
                },
                setAttributeNode: function(newAttr) {
                  return this.attributes.setNamedItem(newAttr);
                },
                setAttributeNodeNS: function(newAttr) {
                  return this.attributes.setNamedItemNS(newAttr);
                },
                removeAttributeNode: function(oldAttr) {
                  return this.attributes.removeNamedItem(oldAttr.nodeName);
                },
                //get real attribute name,and remove it by removeAttributeNode
                removeAttributeNS: function(namespaceURI, localName) {
                  var old = this.getAttributeNodeNS(namespaceURI, localName);
                  old && this.removeAttributeNode(old);
                },
                hasAttributeNS: function(namespaceURI, localName) {
                  return this.getAttributeNodeNS(namespaceURI, localName) != null;
                },
                getAttributeNS: function(namespaceURI, localName) {
                  var attr = this.getAttributeNodeNS(namespaceURI, localName);
                  return attr && attr.value || "";
                },
                setAttributeNS: function(namespaceURI, qualifiedName, value) {
                  var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
                  attr.value = attr.nodeValue = "" + value;
                  this.setAttributeNode(attr);
                },
                getAttributeNodeNS: function(namespaceURI, localName) {
                  return this.attributes.getNamedItemNS(namespaceURI, localName);
                },
                getElementsByTagName: function(tagName) {
                  return new LiveNodeList(this, function(base) {
                    var ls = [];
                    _visitNode(base, function(node) {
                      if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
                        ls.push(node);
                      }
                    });
                    return ls;
                  });
                },
                getElementsByTagNameNS: function(namespaceURI, localName) {
                  return new LiveNodeList(this, function(base) {
                    var ls = [];
                    _visitNode(base, function(node) {
                      if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
                        ls.push(node);
                      }
                    });
                    return ls;
                  });
                }
              };
              Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
              Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
              _extends(Element, Node);
              function Attr() {
              }
              ;
              Attr.prototype.nodeType = ATTRIBUTE_NODE;
              _extends(Attr, Node);
              function CharacterData() {
              }
              ;
              CharacterData.prototype = {
                data: "",
                substringData: function(offset, count) {
                  return this.data.substring(offset, offset + count);
                },
                appendData: function(text) {
                  text = this.data + text;
                  this.nodeValue = this.data = text;
                  this.length = text.length;
                },
                insertData: function(offset, text) {
                  this.replaceData(offset, 0, text);
                },
                appendChild: function(newChild) {
                  throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
                },
                deleteData: function(offset, count) {
                  this.replaceData(offset, count, "");
                },
                replaceData: function(offset, count, text) {
                  var start = this.data.substring(0, offset);
                  var end = this.data.substring(offset + count);
                  text = start + text + end;
                  this.nodeValue = this.data = text;
                  this.length = text.length;
                }
              };
              _extends(CharacterData, Node);
              function Text() {
              }
              ;
              Text.prototype = {
                nodeName: "#text",
                nodeType: TEXT_NODE,
                splitText: function(offset) {
                  var text = this.data;
                  var newText = text.substring(offset);
                  text = text.substring(0, offset);
                  this.data = this.nodeValue = text;
                  this.length = text.length;
                  var newNode = this.ownerDocument.createTextNode(newText);
                  if (this.parentNode) {
                    this.parentNode.insertBefore(newNode, this.nextSibling);
                  }
                  return newNode;
                }
              };
              _extends(Text, CharacterData);
              function Comment() {
              }
              ;
              Comment.prototype = {
                nodeName: "#comment",
                nodeType: COMMENT_NODE
              };
              _extends(Comment, CharacterData);
              function CDATASection() {
              }
              ;
              CDATASection.prototype = {
                nodeName: "#cdata-section",
                nodeType: CDATA_SECTION_NODE
              };
              _extends(CDATASection, CharacterData);
              function DocumentType() {
              }
              ;
              DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
              _extends(DocumentType, Node);
              function Notation() {
              }
              ;
              Notation.prototype.nodeType = NOTATION_NODE;
              _extends(Notation, Node);
              function Entity() {
              }
              ;
              Entity.prototype.nodeType = ENTITY_NODE;
              _extends(Entity, Node);
              function EntityReference() {
              }
              ;
              EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
              _extends(EntityReference, Node);
              function DocumentFragment() {
              }
              ;
              DocumentFragment.prototype.nodeName = "#document-fragment";
              DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
              _extends(DocumentFragment, Node);
              function ProcessingInstruction() {
              }
              ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
              _extends(ProcessingInstruction, Node);
              function XMLSerializer2() {
              }
              XMLSerializer2.prototype.serializeToString = function(node, isHtml, nodeFilter) {
                return nodeSerializeToString.call(node, isHtml, nodeFilter);
              };
              Node.prototype.toString = nodeSerializeToString;
              function nodeSerializeToString(isHtml, nodeFilter) {
                var buf = [];
                var refNode = this.nodeType == 9 && this.documentElement || this;
                var prefix = refNode.prefix;
                var uri = refNode.namespaceURI;
                if (uri && prefix == null) {
                  var prefix = refNode.lookupPrefix(uri);
                  if (prefix == null) {
                    var visibleNamespaces = [
                      { namespace: uri, prefix: null }
                      //{namespace:uri,prefix:''}
                    ];
                  }
                }
                serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
                return buf.join("");
              }
              function needNamespaceDefine(node, isHTML, visibleNamespaces) {
                var prefix = node.prefix || "";
                var uri = node.namespaceURI;
                if (!uri) {
                  return false;
                }
                if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
                  return false;
                }
                var i = visibleNamespaces.length;
                while (i--) {
                  var ns = visibleNamespaces[i];
                  if (ns.prefix === prefix) {
                    return ns.namespace !== uri;
                  }
                }
                return true;
              }
              function addSerializedAttribute(buf, qualifiedName, value) {
                buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
              }
              function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
                if (!visibleNamespaces) {
                  visibleNamespaces = [];
                }
                if (nodeFilter) {
                  node = nodeFilter(node);
                  if (node) {
                    if (typeof node == "string") {
                      buf.push(node);
                      return;
                    }
                  } else {
                    return;
                  }
                }
                switch (node.nodeType) {
                  case ELEMENT_NODE:
                    var attrs = node.attributes;
                    var len = attrs.length;
                    var child = node.firstChild;
                    var nodeName = node.tagName;
                    isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
                    var prefixedNodeName = nodeName;
                    if (!isHTML && !node.prefix && node.namespaceURI) {
                      var defaultNS;
                      for (var ai = 0; ai < attrs.length; ai++) {
                        if (attrs.item(ai).name === "xmlns") {
                          defaultNS = attrs.item(ai).value;
                          break;
                        }
                      }
                      if (!defaultNS) {
                        for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                          var namespace = visibleNamespaces[nsi];
                          if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                            defaultNS = namespace.namespace;
                            break;
                          }
                        }
                      }
                      if (defaultNS !== node.namespaceURI) {
                        for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                          var namespace = visibleNamespaces[nsi];
                          if (namespace.namespace === node.namespaceURI) {
                            if (namespace.prefix) {
                              prefixedNodeName = namespace.prefix + ":" + nodeName;
                            }
                            break;
                          }
                        }
                      }
                    }
                    buf.push("<", prefixedNodeName);
                    for (var i = 0; i < len; i++) {
                      var attr = attrs.item(i);
                      if (attr.prefix == "xmlns") {
                        visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
                      } else if (attr.nodeName == "xmlns") {
                        visibleNamespaces.push({ prefix: "", namespace: attr.value });
                      }
                    }
                    for (var i = 0; i < len; i++) {
                      var attr = attrs.item(i);
                      if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
                        var prefix = attr.prefix || "";
                        var uri = attr.namespaceURI;
                        addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
                        visibleNamespaces.push({ prefix, namespace: uri });
                      }
                      serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
                    }
                    if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
                      var prefix = node.prefix || "";
                      var uri = node.namespaceURI;
                      addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
                      visibleNamespaces.push({ prefix, namespace: uri });
                    }
                    if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
                      buf.push(">");
                      if (isHTML && /^script$/i.test(nodeName)) {
                        while (child) {
                          if (child.data) {
                            buf.push(child.data);
                          } else {
                            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                          }
                          child = child.nextSibling;
                        }
                      } else {
                        while (child) {
                          serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                          child = child.nextSibling;
                        }
                      }
                      buf.push("</", prefixedNodeName, ">");
                    } else {
                      buf.push("/>");
                    }
                    return;
                  case DOCUMENT_NODE:
                  case DOCUMENT_FRAGMENT_NODE:
                    var child = node.firstChild;
                    while (child) {
                      serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                      child = child.nextSibling;
                    }
                    return;
                  case ATTRIBUTE_NODE:
                    return addSerializedAttribute(buf, node.name, node.value);
                  case TEXT_NODE:
                    return buf.push(
                      node.data.replace(/[<&>]/g, _xmlEncoder)
                    );
                  case CDATA_SECTION_NODE:
                    return buf.push("<![CDATA[", node.data, "]]>");
                  case COMMENT_NODE:
                    return buf.push("<!--", node.data, "-->");
                  case DOCUMENT_TYPE_NODE:
                    var pubid = node.publicId;
                    var sysid = node.systemId;
                    buf.push("<!DOCTYPE ", node.name);
                    if (pubid) {
                      buf.push(" PUBLIC ", pubid);
                      if (sysid && sysid != ".") {
                        buf.push(" ", sysid);
                      }
                      buf.push(">");
                    } else if (sysid && sysid != ".") {
                      buf.push(" SYSTEM ", sysid, ">");
                    } else {
                      var sub = node.internalSubset;
                      if (sub) {
                        buf.push(" [", sub, "]");
                      }
                      buf.push(">");
                    }
                    return;
                  case PROCESSING_INSTRUCTION_NODE:
                    return buf.push("<?", node.target, " ", node.data, "?>");
                  case ENTITY_REFERENCE_NODE:
                    return buf.push("&", node.nodeName, ";");
                  default:
                    buf.push("??", node.nodeName);
                }
              }
              function importNode(doc, node, deep) {
                var node2;
                switch (node.nodeType) {
                  case ELEMENT_NODE:
                    node2 = node.cloneNode(false);
                    node2.ownerDocument = doc;
                  case DOCUMENT_FRAGMENT_NODE:
                    break;
                  case ATTRIBUTE_NODE:
                    deep = true;
                    break;
                }
                if (!node2) {
                  node2 = node.cloneNode(false);
                }
                node2.ownerDocument = doc;
                node2.parentNode = null;
                if (deep) {
                  var child = node.firstChild;
                  while (child) {
                    node2.appendChild(importNode(doc, child, deep));
                    child = child.nextSibling;
                  }
                }
                return node2;
              }
              function cloneNode(doc, node, deep) {
                var node2 = new node.constructor();
                for (var n in node) {
                  if (Object.prototype.hasOwnProperty.call(node, n)) {
                    var v = node[n];
                    if (typeof v != "object") {
                      if (v != node2[n]) {
                        node2[n] = v;
                      }
                    }
                  }
                }
                if (node.childNodes) {
                  node2.childNodes = new NodeList();
                }
                node2.ownerDocument = doc;
                switch (node2.nodeType) {
                  case ELEMENT_NODE:
                    var attrs = node.attributes;
                    var attrs2 = node2.attributes = new NamedNodeMap();
                    var len = attrs.length;
                    attrs2._ownerElement = node2;
                    for (var i = 0; i < len; i++) {
                      node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
                    }
                    break;
                    ;
                  case ATTRIBUTE_NODE:
                    deep = true;
                }
                if (deep) {
                  var child = node.firstChild;
                  while (child) {
                    node2.appendChild(cloneNode(doc, child, deep));
                    child = child.nextSibling;
                  }
                }
                return node2;
              }
              function __set__(object, key, value) {
                object[key] = value;
              }
              try {
                if (Object.defineProperty) {
                  let getTextContent2 = function(node) {
                    switch (node.nodeType) {
                      case ELEMENT_NODE:
                      case DOCUMENT_FRAGMENT_NODE:
                        var buf = [];
                        node = node.firstChild;
                        while (node) {
                          if (node.nodeType !== 7 && node.nodeType !== 8) {
                            buf.push(getTextContent2(node));
                          }
                          node = node.nextSibling;
                        }
                        return buf.join("");
                      default:
                        return node.nodeValue;
                    }
                  };
                  var getTextContent = getTextContent2;
                  Object.defineProperty(LiveNodeList.prototype, "length", {
                    get: function() {
                      _updateLiveList(this);
                      return this.$$length;
                    }
                  });
                  Object.defineProperty(Node.prototype, "textContent", {
                    get: function() {
                      return getTextContent2(this);
                    },
                    set: function(data) {
                      switch (this.nodeType) {
                        case ELEMENT_NODE:
                        case DOCUMENT_FRAGMENT_NODE:
                          while (this.firstChild) {
                            this.removeChild(this.firstChild);
                          }
                          if (data || String(data)) {
                            this.appendChild(this.ownerDocument.createTextNode(data));
                          }
                          break;
                        default:
                          this.data = data;
                          this.value = data;
                          this.nodeValue = data;
                      }
                    }
                  });
                  __set__ = function(object, key, value) {
                    object["$$" + key] = value;
                  };
                }
              } catch (e) {
              }
              exports2.DocumentType = DocumentType;
              exports2.DOMException = DOMException;
              exports2.DOMImplementation = DOMImplementation;
              exports2.Element = Element;
              exports2.Node = Node;
              exports2.NodeList = NodeList;
              exports2.XMLSerializer = XMLSerializer2;
            }
          ),
          /***/
          "./node_modules/@xmldom/xmldom/lib/entities.js": (
            /*!*****************************************************!*\
              !*** ./node_modules/@xmldom/xmldom/lib/entities.js ***!
              \*****************************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              "use strict";
              var freeze = __webpack_require__2(
                /*! ./conventions */
                "./node_modules/@xmldom/xmldom/lib/conventions.js"
              ).freeze;
              exports2.XML_ENTITIES = freeze({
                amp: "&",
                apos: "'",
                gt: ">",
                lt: "<",
                quot: '"'
              });
              exports2.HTML_ENTITIES = freeze({
                Aacute: "Á",
                aacute: "á",
                Abreve: "Ă",
                abreve: "ă",
                ac: "∾",
                acd: "∿",
                acE: "∾̳",
                Acirc: "Â",
                acirc: "â",
                acute: "´",
                Acy: "А",
                acy: "а",
                AElig: "Æ",
                aelig: "æ",
                af: "⁡",
                Afr: "𝔄",
                afr: "𝔞",
                Agrave: "À",
                agrave: "à",
                alefsym: "ℵ",
                aleph: "ℵ",
                Alpha: "Α",
                alpha: "α",
                Amacr: "Ā",
                amacr: "ā",
                amalg: "⨿",
                AMP: "&",
                amp: "&",
                And: "⩓",
                and: "∧",
                andand: "⩕",
                andd: "⩜",
                andslope: "⩘",
                andv: "⩚",
                ang: "∠",
                ange: "⦤",
                angle: "∠",
                angmsd: "∡",
                angmsdaa: "⦨",
                angmsdab: "⦩",
                angmsdac: "⦪",
                angmsdad: "⦫",
                angmsdae: "⦬",
                angmsdaf: "⦭",
                angmsdag: "⦮",
                angmsdah: "⦯",
                angrt: "∟",
                angrtvb: "⊾",
                angrtvbd: "⦝",
                angsph: "∢",
                angst: "Å",
                angzarr: "⍼",
                Aogon: "Ą",
                aogon: "ą",
                Aopf: "𝔸",
                aopf: "𝕒",
                ap: "≈",
                apacir: "⩯",
                apE: "⩰",
                ape: "≊",
                apid: "≋",
                apos: "'",
                ApplyFunction: "⁡",
                approx: "≈",
                approxeq: "≊",
                Aring: "Å",
                aring: "å",
                Ascr: "𝒜",
                ascr: "𝒶",
                Assign: "≔",
                ast: "*",
                asymp: "≈",
                asympeq: "≍",
                Atilde: "Ã",
                atilde: "ã",
                Auml: "Ä",
                auml: "ä",
                awconint: "∳",
                awint: "⨑",
                backcong: "≌",
                backepsilon: "϶",
                backprime: "‵",
                backsim: "∽",
                backsimeq: "⋍",
                Backslash: "∖",
                Barv: "⫧",
                barvee: "⊽",
                Barwed: "⌆",
                barwed: "⌅",
                barwedge: "⌅",
                bbrk: "⎵",
                bbrktbrk: "⎶",
                bcong: "≌",
                Bcy: "Б",
                bcy: "б",
                bdquo: "„",
                becaus: "∵",
                Because: "∵",
                because: "∵",
                bemptyv: "⦰",
                bepsi: "϶",
                bernou: "ℬ",
                Bernoullis: "ℬ",
                Beta: "Β",
                beta: "β",
                beth: "ℶ",
                between: "≬",
                Bfr: "𝔅",
                bfr: "𝔟",
                bigcap: "⋂",
                bigcirc: "◯",
                bigcup: "⋃",
                bigodot: "⨀",
                bigoplus: "⨁",
                bigotimes: "⨂",
                bigsqcup: "⨆",
                bigstar: "★",
                bigtriangledown: "▽",
                bigtriangleup: "△",
                biguplus: "⨄",
                bigvee: "⋁",
                bigwedge: "⋀",
                bkarow: "⤍",
                blacklozenge: "⧫",
                blacksquare: "▪",
                blacktriangle: "▴",
                blacktriangledown: "▾",
                blacktriangleleft: "◂",
                blacktriangleright: "▸",
                blank: "␣",
                blk12: "▒",
                blk14: "░",
                blk34: "▓",
                block: "█",
                bne: "=⃥",
                bnequiv: "≡⃥",
                bNot: "⫭",
                bnot: "⌐",
                Bopf: "𝔹",
                bopf: "𝕓",
                bot: "⊥",
                bottom: "⊥",
                bowtie: "⋈",
                boxbox: "⧉",
                boxDL: "╗",
                boxDl: "╖",
                boxdL: "╕",
                boxdl: "┐",
                boxDR: "╔",
                boxDr: "╓",
                boxdR: "╒",
                boxdr: "┌",
                boxH: "═",
                boxh: "─",
                boxHD: "╦",
                boxHd: "╤",
                boxhD: "╥",
                boxhd: "┬",
                boxHU: "╩",
                boxHu: "╧",
                boxhU: "╨",
                boxhu: "┴",
                boxminus: "⊟",
                boxplus: "⊞",
                boxtimes: "⊠",
                boxUL: "╝",
                boxUl: "╜",
                boxuL: "╛",
                boxul: "┘",
                boxUR: "╚",
                boxUr: "╙",
                boxuR: "╘",
                boxur: "└",
                boxV: "║",
                boxv: "│",
                boxVH: "╬",
                boxVh: "╫",
                boxvH: "╪",
                boxvh: "┼",
                boxVL: "╣",
                boxVl: "╢",
                boxvL: "╡",
                boxvl: "┤",
                boxVR: "╠",
                boxVr: "╟",
                boxvR: "╞",
                boxvr: "├",
                bprime: "‵",
                Breve: "˘",
                breve: "˘",
                brvbar: "¦",
                Bscr: "ℬ",
                bscr: "𝒷",
                bsemi: "⁏",
                bsim: "∽",
                bsime: "⋍",
                bsol: "\\",
                bsolb: "⧅",
                bsolhsub: "⟈",
                bull: "•",
                bullet: "•",
                bump: "≎",
                bumpE: "⪮",
                bumpe: "≏",
                Bumpeq: "≎",
                bumpeq: "≏",
                Cacute: "Ć",
                cacute: "ć",
                Cap: "⋒",
                cap: "∩",
                capand: "⩄",
                capbrcup: "⩉",
                capcap: "⩋",
                capcup: "⩇",
                capdot: "⩀",
                CapitalDifferentialD: "ⅅ",
                caps: "∩︀",
                caret: "⁁",
                caron: "ˇ",
                Cayleys: "ℭ",
                ccaps: "⩍",
                Ccaron: "Č",
                ccaron: "č",
                Ccedil: "Ç",
                ccedil: "ç",
                Ccirc: "Ĉ",
                ccirc: "ĉ",
                Cconint: "∰",
                ccups: "⩌",
                ccupssm: "⩐",
                Cdot: "Ċ",
                cdot: "ċ",
                cedil: "¸",
                Cedilla: "¸",
                cemptyv: "⦲",
                cent: "¢",
                CenterDot: "·",
                centerdot: "·",
                Cfr: "ℭ",
                cfr: "𝔠",
                CHcy: "Ч",
                chcy: "ч",
                check: "✓",
                checkmark: "✓",
                Chi: "Χ",
                chi: "χ",
                cir: "○",
                circ: "ˆ",
                circeq: "≗",
                circlearrowleft: "↺",
                circlearrowright: "↻",
                circledast: "⊛",
                circledcirc: "⊚",
                circleddash: "⊝",
                CircleDot: "⊙",
                circledR: "®",
                circledS: "Ⓢ",
                CircleMinus: "⊖",
                CirclePlus: "⊕",
                CircleTimes: "⊗",
                cirE: "⧃",
                cire: "≗",
                cirfnint: "⨐",
                cirmid: "⫯",
                cirscir: "⧂",
                ClockwiseContourIntegral: "∲",
                CloseCurlyDoubleQuote: "”",
                CloseCurlyQuote: "’",
                clubs: "♣",
                clubsuit: "♣",
                Colon: "∷",
                colon: ":",
                Colone: "⩴",
                colone: "≔",
                coloneq: "≔",
                comma: ",",
                commat: "@",
                comp: "∁",
                compfn: "∘",
                complement: "∁",
                complexes: "ℂ",
                cong: "≅",
                congdot: "⩭",
                Congruent: "≡",
                Conint: "∯",
                conint: "∮",
                ContourIntegral: "∮",
                Copf: "ℂ",
                copf: "𝕔",
                coprod: "∐",
                Coproduct: "∐",
                COPY: "©",
                copy: "©",
                copysr: "℗",
                CounterClockwiseContourIntegral: "∳",
                crarr: "↵",
                Cross: "⨯",
                cross: "✗",
                Cscr: "𝒞",
                cscr: "𝒸",
                csub: "⫏",
                csube: "⫑",
                csup: "⫐",
                csupe: "⫒",
                ctdot: "⋯",
                cudarrl: "⤸",
                cudarrr: "⤵",
                cuepr: "⋞",
                cuesc: "⋟",
                cularr: "↶",
                cularrp: "⤽",
                Cup: "⋓",
                cup: "∪",
                cupbrcap: "⩈",
                CupCap: "≍",
                cupcap: "⩆",
                cupcup: "⩊",
                cupdot: "⊍",
                cupor: "⩅",
                cups: "∪︀",
                curarr: "↷",
                curarrm: "⤼",
                curlyeqprec: "⋞",
                curlyeqsucc: "⋟",
                curlyvee: "⋎",
                curlywedge: "⋏",
                curren: "¤",
                curvearrowleft: "↶",
                curvearrowright: "↷",
                cuvee: "⋎",
                cuwed: "⋏",
                cwconint: "∲",
                cwint: "∱",
                cylcty: "⌭",
                Dagger: "‡",
                dagger: "†",
                daleth: "ℸ",
                Darr: "↡",
                dArr: "⇓",
                darr: "↓",
                dash: "‐",
                Dashv: "⫤",
                dashv: "⊣",
                dbkarow: "⤏",
                dblac: "˝",
                Dcaron: "Ď",
                dcaron: "ď",
                Dcy: "Д",
                dcy: "д",
                DD: "ⅅ",
                dd: "ⅆ",
                ddagger: "‡",
                ddarr: "⇊",
                DDotrahd: "⤑",
                ddotseq: "⩷",
                deg: "°",
                Del: "∇",
                Delta: "Δ",
                delta: "δ",
                demptyv: "⦱",
                dfisht: "⥿",
                Dfr: "𝔇",
                dfr: "𝔡",
                dHar: "⥥",
                dharl: "⇃",
                dharr: "⇂",
                DiacriticalAcute: "´",
                DiacriticalDot: "˙",
                DiacriticalDoubleAcute: "˝",
                DiacriticalGrave: "`",
                DiacriticalTilde: "˜",
                diam: "⋄",
                Diamond: "⋄",
                diamond: "⋄",
                diamondsuit: "♦",
                diams: "♦",
                die: "¨",
                DifferentialD: "ⅆ",
                digamma: "ϝ",
                disin: "⋲",
                div: "÷",
                divide: "÷",
                divideontimes: "⋇",
                divonx: "⋇",
                DJcy: "Ђ",
                djcy: "ђ",
                dlcorn: "⌞",
                dlcrop: "⌍",
                dollar: "$",
                Dopf: "𝔻",
                dopf: "𝕕",
                Dot: "¨",
                dot: "˙",
                DotDot: "⃜",
                doteq: "≐",
                doteqdot: "≑",
                DotEqual: "≐",
                dotminus: "∸",
                dotplus: "∔",
                dotsquare: "⊡",
                doublebarwedge: "⌆",
                DoubleContourIntegral: "∯",
                DoubleDot: "¨",
                DoubleDownArrow: "⇓",
                DoubleLeftArrow: "⇐",
                DoubleLeftRightArrow: "⇔",
                DoubleLeftTee: "⫤",
                DoubleLongLeftArrow: "⟸",
                DoubleLongLeftRightArrow: "⟺",
                DoubleLongRightArrow: "⟹",
                DoubleRightArrow: "⇒",
                DoubleRightTee: "⊨",
                DoubleUpArrow: "⇑",
                DoubleUpDownArrow: "⇕",
                DoubleVerticalBar: "∥",
                DownArrow: "↓",
                Downarrow: "⇓",
                downarrow: "↓",
                DownArrowBar: "⤓",
                DownArrowUpArrow: "⇵",
                DownBreve: "̑",
                downdownarrows: "⇊",
                downharpoonleft: "⇃",
                downharpoonright: "⇂",
                DownLeftRightVector: "⥐",
                DownLeftTeeVector: "⥞",
                DownLeftVector: "↽",
                DownLeftVectorBar: "⥖",
                DownRightTeeVector: "⥟",
                DownRightVector: "⇁",
                DownRightVectorBar: "⥗",
                DownTee: "⊤",
                DownTeeArrow: "↧",
                drbkarow: "⤐",
                drcorn: "⌟",
                drcrop: "⌌",
                Dscr: "𝒟",
                dscr: "𝒹",
                DScy: "Ѕ",
                dscy: "ѕ",
                dsol: "⧶",
                Dstrok: "Đ",
                dstrok: "đ",
                dtdot: "⋱",
                dtri: "▿",
                dtrif: "▾",
                duarr: "⇵",
                duhar: "⥯",
                dwangle: "⦦",
                DZcy: "Џ",
                dzcy: "џ",
                dzigrarr: "⟿",
                Eacute: "É",
                eacute: "é",
                easter: "⩮",
                Ecaron: "Ě",
                ecaron: "ě",
                ecir: "≖",
                Ecirc: "Ê",
                ecirc: "ê",
                ecolon: "≕",
                Ecy: "Э",
                ecy: "э",
                eDDot: "⩷",
                Edot: "Ė",
                eDot: "≑",
                edot: "ė",
                ee: "ⅇ",
                efDot: "≒",
                Efr: "𝔈",
                efr: "𝔢",
                eg: "⪚",
                Egrave: "È",
                egrave: "è",
                egs: "⪖",
                egsdot: "⪘",
                el: "⪙",
                Element: "∈",
                elinters: "⏧",
                ell: "ℓ",
                els: "⪕",
                elsdot: "⪗",
                Emacr: "Ē",
                emacr: "ē",
                empty: "∅",
                emptyset: "∅",
                EmptySmallSquare: "◻",
                emptyv: "∅",
                EmptyVerySmallSquare: "▫",
                emsp: " ",
                emsp13: " ",
                emsp14: " ",
                ENG: "Ŋ",
                eng: "ŋ",
                ensp: " ",
                Eogon: "Ę",
                eogon: "ę",
                Eopf: "𝔼",
                eopf: "𝕖",
                epar: "⋕",
                eparsl: "⧣",
                eplus: "⩱",
                epsi: "ε",
                Epsilon: "Ε",
                epsilon: "ε",
                epsiv: "ϵ",
                eqcirc: "≖",
                eqcolon: "≕",
                eqsim: "≂",
                eqslantgtr: "⪖",
                eqslantless: "⪕",
                Equal: "⩵",
                equals: "=",
                EqualTilde: "≂",
                equest: "≟",
                Equilibrium: "⇌",
                equiv: "≡",
                equivDD: "⩸",
                eqvparsl: "⧥",
                erarr: "⥱",
                erDot: "≓",
                Escr: "ℰ",
                escr: "ℯ",
                esdot: "≐",
                Esim: "⩳",
                esim: "≂",
                Eta: "Η",
                eta: "η",
                ETH: "Ð",
                eth: "ð",
                Euml: "Ë",
                euml: "ë",
                euro: "€",
                excl: "!",
                exist: "∃",
                Exists: "∃",
                expectation: "ℰ",
                ExponentialE: "ⅇ",
                exponentiale: "ⅇ",
                fallingdotseq: "≒",
                Fcy: "Ф",
                fcy: "ф",
                female: "♀",
                ffilig: "ﬃ",
                fflig: "ﬀ",
                ffllig: "ﬄ",
                Ffr: "𝔉",
                ffr: "𝔣",
                filig: "ﬁ",
                FilledSmallSquare: "◼",
                FilledVerySmallSquare: "▪",
                fjlig: "fj",
                flat: "♭",
                fllig: "ﬂ",
                fltns: "▱",
                fnof: "ƒ",
                Fopf: "𝔽",
                fopf: "𝕗",
                ForAll: "∀",
                forall: "∀",
                fork: "⋔",
                forkv: "⫙",
                Fouriertrf: "ℱ",
                fpartint: "⨍",
                frac12: "½",
                frac13: "⅓",
                frac14: "¼",
                frac15: "⅕",
                frac16: "⅙",
                frac18: "⅛",
                frac23: "⅔",
                frac25: "⅖",
                frac34: "¾",
                frac35: "⅗",
                frac38: "⅜",
                frac45: "⅘",
                frac56: "⅚",
                frac58: "⅝",
                frac78: "⅞",
                frasl: "⁄",
                frown: "⌢",
                Fscr: "ℱ",
                fscr: "𝒻",
                gacute: "ǵ",
                Gamma: "Γ",
                gamma: "γ",
                Gammad: "Ϝ",
                gammad: "ϝ",
                gap: "⪆",
                Gbreve: "Ğ",
                gbreve: "ğ",
                Gcedil: "Ģ",
                Gcirc: "Ĝ",
                gcirc: "ĝ",
                Gcy: "Г",
                gcy: "г",
                Gdot: "Ġ",
                gdot: "ġ",
                gE: "≧",
                ge: "≥",
                gEl: "⪌",
                gel: "⋛",
                geq: "≥",
                geqq: "≧",
                geqslant: "⩾",
                ges: "⩾",
                gescc: "⪩",
                gesdot: "⪀",
                gesdoto: "⪂",
                gesdotol: "⪄",
                gesl: "⋛︀",
                gesles: "⪔",
                Gfr: "𝔊",
                gfr: "𝔤",
                Gg: "⋙",
                gg: "≫",
                ggg: "⋙",
                gimel: "ℷ",
                GJcy: "Ѓ",
                gjcy: "ѓ",
                gl: "≷",
                gla: "⪥",
                glE: "⪒",
                glj: "⪤",
                gnap: "⪊",
                gnapprox: "⪊",
                gnE: "≩",
                gne: "⪈",
                gneq: "⪈",
                gneqq: "≩",
                gnsim: "⋧",
                Gopf: "𝔾",
                gopf: "𝕘",
                grave: "`",
                GreaterEqual: "≥",
                GreaterEqualLess: "⋛",
                GreaterFullEqual: "≧",
                GreaterGreater: "⪢",
                GreaterLess: "≷",
                GreaterSlantEqual: "⩾",
                GreaterTilde: "≳",
                Gscr: "𝒢",
                gscr: "ℊ",
                gsim: "≳",
                gsime: "⪎",
                gsiml: "⪐",
                Gt: "≫",
                GT: ">",
                gt: ">",
                gtcc: "⪧",
                gtcir: "⩺",
                gtdot: "⋗",
                gtlPar: "⦕",
                gtquest: "⩼",
                gtrapprox: "⪆",
                gtrarr: "⥸",
                gtrdot: "⋗",
                gtreqless: "⋛",
                gtreqqless: "⪌",
                gtrless: "≷",
                gtrsim: "≳",
                gvertneqq: "≩︀",
                gvnE: "≩︀",
                Hacek: "ˇ",
                hairsp: " ",
                half: "½",
                hamilt: "ℋ",
                HARDcy: "Ъ",
                hardcy: "ъ",
                hArr: "⇔",
                harr: "↔",
                harrcir: "⥈",
                harrw: "↭",
                Hat: "^",
                hbar: "ℏ",
                Hcirc: "Ĥ",
                hcirc: "ĥ",
                hearts: "♥",
                heartsuit: "♥",
                hellip: "…",
                hercon: "⊹",
                Hfr: "ℌ",
                hfr: "𝔥",
                HilbertSpace: "ℋ",
                hksearow: "⤥",
                hkswarow: "⤦",
                hoarr: "⇿",
                homtht: "∻",
                hookleftarrow: "↩",
                hookrightarrow: "↪",
                Hopf: "ℍ",
                hopf: "𝕙",
                horbar: "―",
                HorizontalLine: "─",
                Hscr: "ℋ",
                hscr: "𝒽",
                hslash: "ℏ",
                Hstrok: "Ħ",
                hstrok: "ħ",
                HumpDownHump: "≎",
                HumpEqual: "≏",
                hybull: "⁃",
                hyphen: "‐",
                Iacute: "Í",
                iacute: "í",
                ic: "⁣",
                Icirc: "Î",
                icirc: "î",
                Icy: "И",
                icy: "и",
                Idot: "İ",
                IEcy: "Е",
                iecy: "е",
                iexcl: "¡",
                iff: "⇔",
                Ifr: "ℑ",
                ifr: "𝔦",
                Igrave: "Ì",
                igrave: "ì",
                ii: "ⅈ",
                iiiint: "⨌",
                iiint: "∭",
                iinfin: "⧜",
                iiota: "℩",
                IJlig: "Ĳ",
                ijlig: "ĳ",
                Im: "ℑ",
                Imacr: "Ī",
                imacr: "ī",
                image: "ℑ",
                ImaginaryI: "ⅈ",
                imagline: "ℐ",
                imagpart: "ℑ",
                imath: "ı",
                imof: "⊷",
                imped: "Ƶ",
                Implies: "⇒",
                in: "∈",
                incare: "℅",
                infin: "∞",
                infintie: "⧝",
                inodot: "ı",
                Int: "∬",
                int: "∫",
                intcal: "⊺",
                integers: "ℤ",
                Integral: "∫",
                intercal: "⊺",
                Intersection: "⋂",
                intlarhk: "⨗",
                intprod: "⨼",
                InvisibleComma: "⁣",
                InvisibleTimes: "⁢",
                IOcy: "Ё",
                iocy: "ё",
                Iogon: "Į",
                iogon: "į",
                Iopf: "𝕀",
                iopf: "𝕚",
                Iota: "Ι",
                iota: "ι",
                iprod: "⨼",
                iquest: "¿",
                Iscr: "ℐ",
                iscr: "𝒾",
                isin: "∈",
                isindot: "⋵",
                isinE: "⋹",
                isins: "⋴",
                isinsv: "⋳",
                isinv: "∈",
                it: "⁢",
                Itilde: "Ĩ",
                itilde: "ĩ",
                Iukcy: "І",
                iukcy: "і",
                Iuml: "Ï",
                iuml: "ï",
                Jcirc: "Ĵ",
                jcirc: "ĵ",
                Jcy: "Й",
                jcy: "й",
                Jfr: "𝔍",
                jfr: "𝔧",
                jmath: "ȷ",
                Jopf: "𝕁",
                jopf: "𝕛",
                Jscr: "𝒥",
                jscr: "𝒿",
                Jsercy: "Ј",
                jsercy: "ј",
                Jukcy: "Є",
                jukcy: "є",
                Kappa: "Κ",
                kappa: "κ",
                kappav: "ϰ",
                Kcedil: "Ķ",
                kcedil: "ķ",
                Kcy: "К",
                kcy: "к",
                Kfr: "𝔎",
                kfr: "𝔨",
                kgreen: "ĸ",
                KHcy: "Х",
                khcy: "х",
                KJcy: "Ќ",
                kjcy: "ќ",
                Kopf: "𝕂",
                kopf: "𝕜",
                Kscr: "𝒦",
                kscr: "𝓀",
                lAarr: "⇚",
                Lacute: "Ĺ",
                lacute: "ĺ",
                laemptyv: "⦴",
                lagran: "ℒ",
                Lambda: "Λ",
                lambda: "λ",
                Lang: "⟪",
                lang: "⟨",
                langd: "⦑",
                langle: "⟨",
                lap: "⪅",
                Laplacetrf: "ℒ",
                laquo: "«",
                Larr: "↞",
                lArr: "⇐",
                larr: "←",
                larrb: "⇤",
                larrbfs: "⤟",
                larrfs: "⤝",
                larrhk: "↩",
                larrlp: "↫",
                larrpl: "⤹",
                larrsim: "⥳",
                larrtl: "↢",
                lat: "⪫",
                lAtail: "⤛",
                latail: "⤙",
                late: "⪭",
                lates: "⪭︀",
                lBarr: "⤎",
                lbarr: "⤌",
                lbbrk: "❲",
                lbrace: "{",
                lbrack: "[",
                lbrke: "⦋",
                lbrksld: "⦏",
                lbrkslu: "⦍",
                Lcaron: "Ľ",
                lcaron: "ľ",
                Lcedil: "Ļ",
                lcedil: "ļ",
                lceil: "⌈",
                lcub: "{",
                Lcy: "Л",
                lcy: "л",
                ldca: "⤶",
                ldquo: "“",
                ldquor: "„",
                ldrdhar: "⥧",
                ldrushar: "⥋",
                ldsh: "↲",
                lE: "≦",
                le: "≤",
                LeftAngleBracket: "⟨",
                LeftArrow: "←",
                Leftarrow: "⇐",
                leftarrow: "←",
                LeftArrowBar: "⇤",
                LeftArrowRightArrow: "⇆",
                leftarrowtail: "↢",
                LeftCeiling: "⌈",
                LeftDoubleBracket: "⟦",
                LeftDownTeeVector: "⥡",
                LeftDownVector: "⇃",
                LeftDownVectorBar: "⥙",
                LeftFloor: "⌊",
                leftharpoondown: "↽",
                leftharpoonup: "↼",
                leftleftarrows: "⇇",
                LeftRightArrow: "↔",
                Leftrightarrow: "⇔",
                leftrightarrow: "↔",
                leftrightarrows: "⇆",
                leftrightharpoons: "⇋",
                leftrightsquigarrow: "↭",
                LeftRightVector: "⥎",
                LeftTee: "⊣",
                LeftTeeArrow: "↤",
                LeftTeeVector: "⥚",
                leftthreetimes: "⋋",
                LeftTriangle: "⊲",
                LeftTriangleBar: "⧏",
                LeftTriangleEqual: "⊴",
                LeftUpDownVector: "⥑",
                LeftUpTeeVector: "⥠",
                LeftUpVector: "↿",
                LeftUpVectorBar: "⥘",
                LeftVector: "↼",
                LeftVectorBar: "⥒",
                lEg: "⪋",
                leg: "⋚",
                leq: "≤",
                leqq: "≦",
                leqslant: "⩽",
                les: "⩽",
                lescc: "⪨",
                lesdot: "⩿",
                lesdoto: "⪁",
                lesdotor: "⪃",
                lesg: "⋚︀",
                lesges: "⪓",
                lessapprox: "⪅",
                lessdot: "⋖",
                lesseqgtr: "⋚",
                lesseqqgtr: "⪋",
                LessEqualGreater: "⋚",
                LessFullEqual: "≦",
                LessGreater: "≶",
                lessgtr: "≶",
                LessLess: "⪡",
                lesssim: "≲",
                LessSlantEqual: "⩽",
                LessTilde: "≲",
                lfisht: "⥼",
                lfloor: "⌊",
                Lfr: "𝔏",
                lfr: "𝔩",
                lg: "≶",
                lgE: "⪑",
                lHar: "⥢",
                lhard: "↽",
                lharu: "↼",
                lharul: "⥪",
                lhblk: "▄",
                LJcy: "Љ",
                ljcy: "љ",
                Ll: "⋘",
                ll: "≪",
                llarr: "⇇",
                llcorner: "⌞",
                Lleftarrow: "⇚",
                llhard: "⥫",
                lltri: "◺",
                Lmidot: "Ŀ",
                lmidot: "ŀ",
                lmoust: "⎰",
                lmoustache: "⎰",
                lnap: "⪉",
                lnapprox: "⪉",
                lnE: "≨",
                lne: "⪇",
                lneq: "⪇",
                lneqq: "≨",
                lnsim: "⋦",
                loang: "⟬",
                loarr: "⇽",
                lobrk: "⟦",
                LongLeftArrow: "⟵",
                Longleftarrow: "⟸",
                longleftarrow: "⟵",
                LongLeftRightArrow: "⟷",
                Longleftrightarrow: "⟺",
                longleftrightarrow: "⟷",
                longmapsto: "⟼",
                LongRightArrow: "⟶",
                Longrightarrow: "⟹",
                longrightarrow: "⟶",
                looparrowleft: "↫",
                looparrowright: "↬",
                lopar: "⦅",
                Lopf: "𝕃",
                lopf: "𝕝",
                loplus: "⨭",
                lotimes: "⨴",
                lowast: "∗",
                lowbar: "_",
                LowerLeftArrow: "↙",
                LowerRightArrow: "↘",
                loz: "◊",
                lozenge: "◊",
                lozf: "⧫",
                lpar: "(",
                lparlt: "⦓",
                lrarr: "⇆",
                lrcorner: "⌟",
                lrhar: "⇋",
                lrhard: "⥭",
                lrm: "‎",
                lrtri: "⊿",
                lsaquo: "‹",
                Lscr: "ℒ",
                lscr: "𝓁",
                Lsh: "↰",
                lsh: "↰",
                lsim: "≲",
                lsime: "⪍",
                lsimg: "⪏",
                lsqb: "[",
                lsquo: "‘",
                lsquor: "‚",
                Lstrok: "Ł",
                lstrok: "ł",
                Lt: "≪",
                LT: "<",
                lt: "<",
                ltcc: "⪦",
                ltcir: "⩹",
                ltdot: "⋖",
                lthree: "⋋",
                ltimes: "⋉",
                ltlarr: "⥶",
                ltquest: "⩻",
                ltri: "◃",
                ltrie: "⊴",
                ltrif: "◂",
                ltrPar: "⦖",
                lurdshar: "⥊",
                luruhar: "⥦",
                lvertneqq: "≨︀",
                lvnE: "≨︀",
                macr: "¯",
                male: "♂",
                malt: "✠",
                maltese: "✠",
                Map: "⤅",
                map: "↦",
                mapsto: "↦",
                mapstodown: "↧",
                mapstoleft: "↤",
                mapstoup: "↥",
                marker: "▮",
                mcomma: "⨩",
                Mcy: "М",
                mcy: "м",
                mdash: "—",
                mDDot: "∺",
                measuredangle: "∡",
                MediumSpace: " ",
                Mellintrf: "ℳ",
                Mfr: "𝔐",
                mfr: "𝔪",
                mho: "℧",
                micro: "µ",
                mid: "∣",
                midast: "*",
                midcir: "⫰",
                middot: "·",
                minus: "−",
                minusb: "⊟",
                minusd: "∸",
                minusdu: "⨪",
                MinusPlus: "∓",
                mlcp: "⫛",
                mldr: "…",
                mnplus: "∓",
                models: "⊧",
                Mopf: "𝕄",
                mopf: "𝕞",
                mp: "∓",
                Mscr: "ℳ",
                mscr: "𝓂",
                mstpos: "∾",
                Mu: "Μ",
                mu: "μ",
                multimap: "⊸",
                mumap: "⊸",
                nabla: "∇",
                Nacute: "Ń",
                nacute: "ń",
                nang: "∠⃒",
                nap: "≉",
                napE: "⩰̸",
                napid: "≋̸",
                napos: "ŉ",
                napprox: "≉",
                natur: "♮",
                natural: "♮",
                naturals: "ℕ",
                nbsp: " ",
                nbump: "≎̸",
                nbumpe: "≏̸",
                ncap: "⩃",
                Ncaron: "Ň",
                ncaron: "ň",
                Ncedil: "Ņ",
                ncedil: "ņ",
                ncong: "≇",
                ncongdot: "⩭̸",
                ncup: "⩂",
                Ncy: "Н",
                ncy: "н",
                ndash: "–",
                ne: "≠",
                nearhk: "⤤",
                neArr: "⇗",
                nearr: "↗",
                nearrow: "↗",
                nedot: "≐̸",
                NegativeMediumSpace: "​",
                NegativeThickSpace: "​",
                NegativeThinSpace: "​",
                NegativeVeryThinSpace: "​",
                nequiv: "≢",
                nesear: "⤨",
                nesim: "≂̸",
                NestedGreaterGreater: "≫",
                NestedLessLess: "≪",
                NewLine: "\n",
                nexist: "∄",
                nexists: "∄",
                Nfr: "𝔑",
                nfr: "𝔫",
                ngE: "≧̸",
                nge: "≱",
                ngeq: "≱",
                ngeqq: "≧̸",
                ngeqslant: "⩾̸",
                nges: "⩾̸",
                nGg: "⋙̸",
                ngsim: "≵",
                nGt: "≫⃒",
                ngt: "≯",
                ngtr: "≯",
                nGtv: "≫̸",
                nhArr: "⇎",
                nharr: "↮",
                nhpar: "⫲",
                ni: "∋",
                nis: "⋼",
                nisd: "⋺",
                niv: "∋",
                NJcy: "Њ",
                njcy: "њ",
                nlArr: "⇍",
                nlarr: "↚",
                nldr: "‥",
                nlE: "≦̸",
                nle: "≰",
                nLeftarrow: "⇍",
                nleftarrow: "↚",
                nLeftrightarrow: "⇎",
                nleftrightarrow: "↮",
                nleq: "≰",
                nleqq: "≦̸",
                nleqslant: "⩽̸",
                nles: "⩽̸",
                nless: "≮",
                nLl: "⋘̸",
                nlsim: "≴",
                nLt: "≪⃒",
                nlt: "≮",
                nltri: "⋪",
                nltrie: "⋬",
                nLtv: "≪̸",
                nmid: "∤",
                NoBreak: "⁠",
                NonBreakingSpace: " ",
                Nopf: "ℕ",
                nopf: "𝕟",
                Not: "⫬",
                not: "¬",
                NotCongruent: "≢",
                NotCupCap: "≭",
                NotDoubleVerticalBar: "∦",
                NotElement: "∉",
                NotEqual: "≠",
                NotEqualTilde: "≂̸",
                NotExists: "∄",
                NotGreater: "≯",
                NotGreaterEqual: "≱",
                NotGreaterFullEqual: "≧̸",
                NotGreaterGreater: "≫̸",
                NotGreaterLess: "≹",
                NotGreaterSlantEqual: "⩾̸",
                NotGreaterTilde: "≵",
                NotHumpDownHump: "≎̸",
                NotHumpEqual: "≏̸",
                notin: "∉",
                notindot: "⋵̸",
                notinE: "⋹̸",
                notinva: "∉",
                notinvb: "⋷",
                notinvc: "⋶",
                NotLeftTriangle: "⋪",
                NotLeftTriangleBar: "⧏̸",
                NotLeftTriangleEqual: "⋬",
                NotLess: "≮",
                NotLessEqual: "≰",
                NotLessGreater: "≸",
                NotLessLess: "≪̸",
                NotLessSlantEqual: "⩽̸",
                NotLessTilde: "≴",
                NotNestedGreaterGreater: "⪢̸",
                NotNestedLessLess: "⪡̸",
                notni: "∌",
                notniva: "∌",
                notnivb: "⋾",
                notnivc: "⋽",
                NotPrecedes: "⊀",
                NotPrecedesEqual: "⪯̸",
                NotPrecedesSlantEqual: "⋠",
                NotReverseElement: "∌",
                NotRightTriangle: "⋫",
                NotRightTriangleBar: "⧐̸",
                NotRightTriangleEqual: "⋭",
                NotSquareSubset: "⊏̸",
                NotSquareSubsetEqual: "⋢",
                NotSquareSuperset: "⊐̸",
                NotSquareSupersetEqual: "⋣",
                NotSubset: "⊂⃒",
                NotSubsetEqual: "⊈",
                NotSucceeds: "⊁",
                NotSucceedsEqual: "⪰̸",
                NotSucceedsSlantEqual: "⋡",
                NotSucceedsTilde: "≿̸",
                NotSuperset: "⊃⃒",
                NotSupersetEqual: "⊉",
                NotTilde: "≁",
                NotTildeEqual: "≄",
                NotTildeFullEqual: "≇",
                NotTildeTilde: "≉",
                NotVerticalBar: "∤",
                npar: "∦",
                nparallel: "∦",
                nparsl: "⫽⃥",
                npart: "∂̸",
                npolint: "⨔",
                npr: "⊀",
                nprcue: "⋠",
                npre: "⪯̸",
                nprec: "⊀",
                npreceq: "⪯̸",
                nrArr: "⇏",
                nrarr: "↛",
                nrarrc: "⤳̸",
                nrarrw: "↝̸",
                nRightarrow: "⇏",
                nrightarrow: "↛",
                nrtri: "⋫",
                nrtrie: "⋭",
                nsc: "⊁",
                nsccue: "⋡",
                nsce: "⪰̸",
                Nscr: "𝒩",
                nscr: "𝓃",
                nshortmid: "∤",
                nshortparallel: "∦",
                nsim: "≁",
                nsime: "≄",
                nsimeq: "≄",
                nsmid: "∤",
                nspar: "∦",
                nsqsube: "⋢",
                nsqsupe: "⋣",
                nsub: "⊄",
                nsubE: "⫅̸",
                nsube: "⊈",
                nsubset: "⊂⃒",
                nsubseteq: "⊈",
                nsubseteqq: "⫅̸",
                nsucc: "⊁",
                nsucceq: "⪰̸",
                nsup: "⊅",
                nsupE: "⫆̸",
                nsupe: "⊉",
                nsupset: "⊃⃒",
                nsupseteq: "⊉",
                nsupseteqq: "⫆̸",
                ntgl: "≹",
                Ntilde: "Ñ",
                ntilde: "ñ",
                ntlg: "≸",
                ntriangleleft: "⋪",
                ntrianglelefteq: "⋬",
                ntriangleright: "⋫",
                ntrianglerighteq: "⋭",
                Nu: "Ν",
                nu: "ν",
                num: "#",
                numero: "№",
                numsp: " ",
                nvap: "≍⃒",
                nVDash: "⊯",
                nVdash: "⊮",
                nvDash: "⊭",
                nvdash: "⊬",
                nvge: "≥⃒",
                nvgt: ">⃒",
                nvHarr: "⤄",
                nvinfin: "⧞",
                nvlArr: "⤂",
                nvle: "≤⃒",
                nvlt: "<⃒",
                nvltrie: "⊴⃒",
                nvrArr: "⤃",
                nvrtrie: "⊵⃒",
                nvsim: "∼⃒",
                nwarhk: "⤣",
                nwArr: "⇖",
                nwarr: "↖",
                nwarrow: "↖",
                nwnear: "⤧",
                Oacute: "Ó",
                oacute: "ó",
                oast: "⊛",
                ocir: "⊚",
                Ocirc: "Ô",
                ocirc: "ô",
                Ocy: "О",
                ocy: "о",
                odash: "⊝",
                Odblac: "Ő",
                odblac: "ő",
                odiv: "⨸",
                odot: "⊙",
                odsold: "⦼",
                OElig: "Œ",
                oelig: "œ",
                ofcir: "⦿",
                Ofr: "𝔒",
                ofr: "𝔬",
                ogon: "˛",
                Ograve: "Ò",
                ograve: "ò",
                ogt: "⧁",
                ohbar: "⦵",
                ohm: "Ω",
                oint: "∮",
                olarr: "↺",
                olcir: "⦾",
                olcross: "⦻",
                oline: "‾",
                olt: "⧀",
                Omacr: "Ō",
                omacr: "ō",
                Omega: "Ω",
                omega: "ω",
                Omicron: "Ο",
                omicron: "ο",
                omid: "⦶",
                ominus: "⊖",
                Oopf: "𝕆",
                oopf: "𝕠",
                opar: "⦷",
                OpenCurlyDoubleQuote: "“",
                OpenCurlyQuote: "‘",
                operp: "⦹",
                oplus: "⊕",
                Or: "⩔",
                or: "∨",
                orarr: "↻",
                ord: "⩝",
                order: "ℴ",
                orderof: "ℴ",
                ordf: "ª",
                ordm: "º",
                origof: "⊶",
                oror: "⩖",
                orslope: "⩗",
                orv: "⩛",
                oS: "Ⓢ",
                Oscr: "𝒪",
                oscr: "ℴ",
                Oslash: "Ø",
                oslash: "ø",
                osol: "⊘",
                Otilde: "Õ",
                otilde: "õ",
                Otimes: "⨷",
                otimes: "⊗",
                otimesas: "⨶",
                Ouml: "Ö",
                ouml: "ö",
                ovbar: "⌽",
                OverBar: "‾",
                OverBrace: "⏞",
                OverBracket: "⎴",
                OverParenthesis: "⏜",
                par: "∥",
                para: "¶",
                parallel: "∥",
                parsim: "⫳",
                parsl: "⫽",
                part: "∂",
                PartialD: "∂",
                Pcy: "П",
                pcy: "п",
                percnt: "%",
                period: ".",
                permil: "‰",
                perp: "⊥",
                pertenk: "‱",
                Pfr: "𝔓",
                pfr: "𝔭",
                Phi: "Φ",
                phi: "φ",
                phiv: "ϕ",
                phmmat: "ℳ",
                phone: "☎",
                Pi: "Π",
                pi: "π",
                pitchfork: "⋔",
                piv: "ϖ",
                planck: "ℏ",
                planckh: "ℎ",
                plankv: "ℏ",
                plus: "+",
                plusacir: "⨣",
                plusb: "⊞",
                pluscir: "⨢",
                plusdo: "∔",
                plusdu: "⨥",
                pluse: "⩲",
                PlusMinus: "±",
                plusmn: "±",
                plussim: "⨦",
                plustwo: "⨧",
                pm: "±",
                Poincareplane: "ℌ",
                pointint: "⨕",
                Popf: "ℙ",
                popf: "𝕡",
                pound: "£",
                Pr: "⪻",
                pr: "≺",
                prap: "⪷",
                prcue: "≼",
                prE: "⪳",
                pre: "⪯",
                prec: "≺",
                precapprox: "⪷",
                preccurlyeq: "≼",
                Precedes: "≺",
                PrecedesEqual: "⪯",
                PrecedesSlantEqual: "≼",
                PrecedesTilde: "≾",
                preceq: "⪯",
                precnapprox: "⪹",
                precneqq: "⪵",
                precnsim: "⋨",
                precsim: "≾",
                Prime: "″",
                prime: "′",
                primes: "ℙ",
                prnap: "⪹",
                prnE: "⪵",
                prnsim: "⋨",
                prod: "∏",
                Product: "∏",
                profalar: "⌮",
                profline: "⌒",
                profsurf: "⌓",
                prop: "∝",
                Proportion: "∷",
                Proportional: "∝",
                propto: "∝",
                prsim: "≾",
                prurel: "⊰",
                Pscr: "𝒫",
                pscr: "𝓅",
                Psi: "Ψ",
                psi: "ψ",
                puncsp: " ",
                Qfr: "𝔔",
                qfr: "𝔮",
                qint: "⨌",
                Qopf: "ℚ",
                qopf: "𝕢",
                qprime: "⁗",
                Qscr: "𝒬",
                qscr: "𝓆",
                quaternions: "ℍ",
                quatint: "⨖",
                quest: "?",
                questeq: "≟",
                QUOT: '"',
                quot: '"',
                rAarr: "⇛",
                race: "∽̱",
                Racute: "Ŕ",
                racute: "ŕ",
                radic: "√",
                raemptyv: "⦳",
                Rang: "⟫",
                rang: "⟩",
                rangd: "⦒",
                range: "⦥",
                rangle: "⟩",
                raquo: "»",
                Rarr: "↠",
                rArr: "⇒",
                rarr: "→",
                rarrap: "⥵",
                rarrb: "⇥",
                rarrbfs: "⤠",
                rarrc: "⤳",
                rarrfs: "⤞",
                rarrhk: "↪",
                rarrlp: "↬",
                rarrpl: "⥅",
                rarrsim: "⥴",
                Rarrtl: "⤖",
                rarrtl: "↣",
                rarrw: "↝",
                rAtail: "⤜",
                ratail: "⤚",
                ratio: "∶",
                rationals: "ℚ",
                RBarr: "⤐",
                rBarr: "⤏",
                rbarr: "⤍",
                rbbrk: "❳",
                rbrace: "}",
                rbrack: "]",
                rbrke: "⦌",
                rbrksld: "⦎",
                rbrkslu: "⦐",
                Rcaron: "Ř",
                rcaron: "ř",
                Rcedil: "Ŗ",
                rcedil: "ŗ",
                rceil: "⌉",
                rcub: "}",
                Rcy: "Р",
                rcy: "р",
                rdca: "⤷",
                rdldhar: "⥩",
                rdquo: "”",
                rdquor: "”",
                rdsh: "↳",
                Re: "ℜ",
                real: "ℜ",
                realine: "ℛ",
                realpart: "ℜ",
                reals: "ℝ",
                rect: "▭",
                REG: "®",
                reg: "®",
                ReverseElement: "∋",
                ReverseEquilibrium: "⇋",
                ReverseUpEquilibrium: "⥯",
                rfisht: "⥽",
                rfloor: "⌋",
                Rfr: "ℜ",
                rfr: "𝔯",
                rHar: "⥤",
                rhard: "⇁",
                rharu: "⇀",
                rharul: "⥬",
                Rho: "Ρ",
                rho: "ρ",
                rhov: "ϱ",
                RightAngleBracket: "⟩",
                RightArrow: "→",
                Rightarrow: "⇒",
                rightarrow: "→",
                RightArrowBar: "⇥",
                RightArrowLeftArrow: "⇄",
                rightarrowtail: "↣",
                RightCeiling: "⌉",
                RightDoubleBracket: "⟧",
                RightDownTeeVector: "⥝",
                RightDownVector: "⇂",
                RightDownVectorBar: "⥕",
                RightFloor: "⌋",
                rightharpoondown: "⇁",
                rightharpoonup: "⇀",
                rightleftarrows: "⇄",
                rightleftharpoons: "⇌",
                rightrightarrows: "⇉",
                rightsquigarrow: "↝",
                RightTee: "⊢",
                RightTeeArrow: "↦",
                RightTeeVector: "⥛",
                rightthreetimes: "⋌",
                RightTriangle: "⊳",
                RightTriangleBar: "⧐",
                RightTriangleEqual: "⊵",
                RightUpDownVector: "⥏",
                RightUpTeeVector: "⥜",
                RightUpVector: "↾",
                RightUpVectorBar: "⥔",
                RightVector: "⇀",
                RightVectorBar: "⥓",
                ring: "˚",
                risingdotseq: "≓",
                rlarr: "⇄",
                rlhar: "⇌",
                rlm: "‏",
                rmoust: "⎱",
                rmoustache: "⎱",
                rnmid: "⫮",
                roang: "⟭",
                roarr: "⇾",
                robrk: "⟧",
                ropar: "⦆",
                Ropf: "ℝ",
                ropf: "𝕣",
                roplus: "⨮",
                rotimes: "⨵",
                RoundImplies: "⥰",
                rpar: ")",
                rpargt: "⦔",
                rppolint: "⨒",
                rrarr: "⇉",
                Rrightarrow: "⇛",
                rsaquo: "›",
                Rscr: "ℛ",
                rscr: "𝓇",
                Rsh: "↱",
                rsh: "↱",
                rsqb: "]",
                rsquo: "’",
                rsquor: "’",
                rthree: "⋌",
                rtimes: "⋊",
                rtri: "▹",
                rtrie: "⊵",
                rtrif: "▸",
                rtriltri: "⧎",
                RuleDelayed: "⧴",
                ruluhar: "⥨",
                rx: "℞",
                Sacute: "Ś",
                sacute: "ś",
                sbquo: "‚",
                Sc: "⪼",
                sc: "≻",
                scap: "⪸",
                Scaron: "Š",
                scaron: "š",
                sccue: "≽",
                scE: "⪴",
                sce: "⪰",
                Scedil: "Ş",
                scedil: "ş",
                Scirc: "Ŝ",
                scirc: "ŝ",
                scnap: "⪺",
                scnE: "⪶",
                scnsim: "⋩",
                scpolint: "⨓",
                scsim: "≿",
                Scy: "С",
                scy: "с",
                sdot: "⋅",
                sdotb: "⊡",
                sdote: "⩦",
                searhk: "⤥",
                seArr: "⇘",
                searr: "↘",
                searrow: "↘",
                sect: "§",
                semi: ";",
                seswar: "⤩",
                setminus: "∖",
                setmn: "∖",
                sext: "✶",
                Sfr: "𝔖",
                sfr: "𝔰",
                sfrown: "⌢",
                sharp: "♯",
                SHCHcy: "Щ",
                shchcy: "щ",
                SHcy: "Ш",
                shcy: "ш",
                ShortDownArrow: "↓",
                ShortLeftArrow: "←",
                shortmid: "∣",
                shortparallel: "∥",
                ShortRightArrow: "→",
                ShortUpArrow: "↑",
                shy: "­",
                Sigma: "Σ",
                sigma: "σ",
                sigmaf: "ς",
                sigmav: "ς",
                sim: "∼",
                simdot: "⩪",
                sime: "≃",
                simeq: "≃",
                simg: "⪞",
                simgE: "⪠",
                siml: "⪝",
                simlE: "⪟",
                simne: "≆",
                simplus: "⨤",
                simrarr: "⥲",
                slarr: "←",
                SmallCircle: "∘",
                smallsetminus: "∖",
                smashp: "⨳",
                smeparsl: "⧤",
                smid: "∣",
                smile: "⌣",
                smt: "⪪",
                smte: "⪬",
                smtes: "⪬︀",
                SOFTcy: "Ь",
                softcy: "ь",
                sol: "/",
                solb: "⧄",
                solbar: "⌿",
                Sopf: "𝕊",
                sopf: "𝕤",
                spades: "♠",
                spadesuit: "♠",
                spar: "∥",
                sqcap: "⊓",
                sqcaps: "⊓︀",
                sqcup: "⊔",
                sqcups: "⊔︀",
                Sqrt: "√",
                sqsub: "⊏",
                sqsube: "⊑",
                sqsubset: "⊏",
                sqsubseteq: "⊑",
                sqsup: "⊐",
                sqsupe: "⊒",
                sqsupset: "⊐",
                sqsupseteq: "⊒",
                squ: "□",
                Square: "□",
                square: "□",
                SquareIntersection: "⊓",
                SquareSubset: "⊏",
                SquareSubsetEqual: "⊑",
                SquareSuperset: "⊐",
                SquareSupersetEqual: "⊒",
                SquareUnion: "⊔",
                squarf: "▪",
                squf: "▪",
                srarr: "→",
                Sscr: "𝒮",
                sscr: "𝓈",
                ssetmn: "∖",
                ssmile: "⌣",
                sstarf: "⋆",
                Star: "⋆",
                star: "☆",
                starf: "★",
                straightepsilon: "ϵ",
                straightphi: "ϕ",
                strns: "¯",
                Sub: "⋐",
                sub: "⊂",
                subdot: "⪽",
                subE: "⫅",
                sube: "⊆",
                subedot: "⫃",
                submult: "⫁",
                subnE: "⫋",
                subne: "⊊",
                subplus: "⪿",
                subrarr: "⥹",
                Subset: "⋐",
                subset: "⊂",
                subseteq: "⊆",
                subseteqq: "⫅",
                SubsetEqual: "⊆",
                subsetneq: "⊊",
                subsetneqq: "⫋",
                subsim: "⫇",
                subsub: "⫕",
                subsup: "⫓",
                succ: "≻",
                succapprox: "⪸",
                succcurlyeq: "≽",
                Succeeds: "≻",
                SucceedsEqual: "⪰",
                SucceedsSlantEqual: "≽",
                SucceedsTilde: "≿",
                succeq: "⪰",
                succnapprox: "⪺",
                succneqq: "⪶",
                succnsim: "⋩",
                succsim: "≿",
                SuchThat: "∋",
                Sum: "∑",
                sum: "∑",
                sung: "♪",
                Sup: "⋑",
                sup: "⊃",
                sup1: "¹",
                sup2: "²",
                sup3: "³",
                supdot: "⪾",
                supdsub: "⫘",
                supE: "⫆",
                supe: "⊇",
                supedot: "⫄",
                Superset: "⊃",
                SupersetEqual: "⊇",
                suphsol: "⟉",
                suphsub: "⫗",
                suplarr: "⥻",
                supmult: "⫂",
                supnE: "⫌",
                supne: "⊋",
                supplus: "⫀",
                Supset: "⋑",
                supset: "⊃",
                supseteq: "⊇",
                supseteqq: "⫆",
                supsetneq: "⊋",
                supsetneqq: "⫌",
                supsim: "⫈",
                supsub: "⫔",
                supsup: "⫖",
                swarhk: "⤦",
                swArr: "⇙",
                swarr: "↙",
                swarrow: "↙",
                swnwar: "⤪",
                szlig: "ß",
                Tab: "	",
                target: "⌖",
                Tau: "Τ",
                tau: "τ",
                tbrk: "⎴",
                Tcaron: "Ť",
                tcaron: "ť",
                Tcedil: "Ţ",
                tcedil: "ţ",
                Tcy: "Т",
                tcy: "т",
                tdot: "⃛",
                telrec: "⌕",
                Tfr: "𝔗",
                tfr: "𝔱",
                there4: "∴",
                Therefore: "∴",
                therefore: "∴",
                Theta: "Θ",
                theta: "θ",
                thetasym: "ϑ",
                thetav: "ϑ",
                thickapprox: "≈",
                thicksim: "∼",
                ThickSpace: "  ",
                thinsp: " ",
                ThinSpace: " ",
                thkap: "≈",
                thksim: "∼",
                THORN: "Þ",
                thorn: "þ",
                Tilde: "∼",
                tilde: "˜",
                TildeEqual: "≃",
                TildeFullEqual: "≅",
                TildeTilde: "≈",
                times: "×",
                timesb: "⊠",
                timesbar: "⨱",
                timesd: "⨰",
                tint: "∭",
                toea: "⤨",
                top: "⊤",
                topbot: "⌶",
                topcir: "⫱",
                Topf: "𝕋",
                topf: "𝕥",
                topfork: "⫚",
                tosa: "⤩",
                tprime: "‴",
                TRADE: "™",
                trade: "™",
                triangle: "▵",
                triangledown: "▿",
                triangleleft: "◃",
                trianglelefteq: "⊴",
                triangleq: "≜",
                triangleright: "▹",
                trianglerighteq: "⊵",
                tridot: "◬",
                trie: "≜",
                triminus: "⨺",
                TripleDot: "⃛",
                triplus: "⨹",
                trisb: "⧍",
                tritime: "⨻",
                trpezium: "⏢",
                Tscr: "𝒯",
                tscr: "𝓉",
                TScy: "Ц",
                tscy: "ц",
                TSHcy: "Ћ",
                tshcy: "ћ",
                Tstrok: "Ŧ",
                tstrok: "ŧ",
                twixt: "≬",
                twoheadleftarrow: "↞",
                twoheadrightarrow: "↠",
                Uacute: "Ú",
                uacute: "ú",
                Uarr: "↟",
                uArr: "⇑",
                uarr: "↑",
                Uarrocir: "⥉",
                Ubrcy: "Ў",
                ubrcy: "ў",
                Ubreve: "Ŭ",
                ubreve: "ŭ",
                Ucirc: "Û",
                ucirc: "û",
                Ucy: "У",
                ucy: "у",
                udarr: "⇅",
                Udblac: "Ű",
                udblac: "ű",
                udhar: "⥮",
                ufisht: "⥾",
                Ufr: "𝔘",
                ufr: "𝔲",
                Ugrave: "Ù",
                ugrave: "ù",
                uHar: "⥣",
                uharl: "↿",
                uharr: "↾",
                uhblk: "▀",
                ulcorn: "⌜",
                ulcorner: "⌜",
                ulcrop: "⌏",
                ultri: "◸",
                Umacr: "Ū",
                umacr: "ū",
                uml: "¨",
                UnderBar: "_",
                UnderBrace: "⏟",
                UnderBracket: "⎵",
                UnderParenthesis: "⏝",
                Union: "⋃",
                UnionPlus: "⊎",
                Uogon: "Ų",
                uogon: "ų",
                Uopf: "𝕌",
                uopf: "𝕦",
                UpArrow: "↑",
                Uparrow: "⇑",
                uparrow: "↑",
                UpArrowBar: "⤒",
                UpArrowDownArrow: "⇅",
                UpDownArrow: "↕",
                Updownarrow: "⇕",
                updownarrow: "↕",
                UpEquilibrium: "⥮",
                upharpoonleft: "↿",
                upharpoonright: "↾",
                uplus: "⊎",
                UpperLeftArrow: "↖",
                UpperRightArrow: "↗",
                Upsi: "ϒ",
                upsi: "υ",
                upsih: "ϒ",
                Upsilon: "Υ",
                upsilon: "υ",
                UpTee: "⊥",
                UpTeeArrow: "↥",
                upuparrows: "⇈",
                urcorn: "⌝",
                urcorner: "⌝",
                urcrop: "⌎",
                Uring: "Ů",
                uring: "ů",
                urtri: "◹",
                Uscr: "𝒰",
                uscr: "𝓊",
                utdot: "⋰",
                Utilde: "Ũ",
                utilde: "ũ",
                utri: "▵",
                utrif: "▴",
                uuarr: "⇈",
                Uuml: "Ü",
                uuml: "ü",
                uwangle: "⦧",
                vangrt: "⦜",
                varepsilon: "ϵ",
                varkappa: "ϰ",
                varnothing: "∅",
                varphi: "ϕ",
                varpi: "ϖ",
                varpropto: "∝",
                vArr: "⇕",
                varr: "↕",
                varrho: "ϱ",
                varsigma: "ς",
                varsubsetneq: "⊊︀",
                varsubsetneqq: "⫋︀",
                varsupsetneq: "⊋︀",
                varsupsetneqq: "⫌︀",
                vartheta: "ϑ",
                vartriangleleft: "⊲",
                vartriangleright: "⊳",
                Vbar: "⫫",
                vBar: "⫨",
                vBarv: "⫩",
                Vcy: "В",
                vcy: "в",
                VDash: "⊫",
                Vdash: "⊩",
                vDash: "⊨",
                vdash: "⊢",
                Vdashl: "⫦",
                Vee: "⋁",
                vee: "∨",
                veebar: "⊻",
                veeeq: "≚",
                vellip: "⋮",
                Verbar: "‖",
                verbar: "|",
                Vert: "‖",
                vert: "|",
                VerticalBar: "∣",
                VerticalLine: "|",
                VerticalSeparator: "❘",
                VerticalTilde: "≀",
                VeryThinSpace: " ",
                Vfr: "𝔙",
                vfr: "𝔳",
                vltri: "⊲",
                vnsub: "⊂⃒",
                vnsup: "⊃⃒",
                Vopf: "𝕍",
                vopf: "𝕧",
                vprop: "∝",
                vrtri: "⊳",
                Vscr: "𝒱",
                vscr: "𝓋",
                vsubnE: "⫋︀",
                vsubne: "⊊︀",
                vsupnE: "⫌︀",
                vsupne: "⊋︀",
                Vvdash: "⊪",
                vzigzag: "⦚",
                Wcirc: "Ŵ",
                wcirc: "ŵ",
                wedbar: "⩟",
                Wedge: "⋀",
                wedge: "∧",
                wedgeq: "≙",
                weierp: "℘",
                Wfr: "𝔚",
                wfr: "𝔴",
                Wopf: "𝕎",
                wopf: "𝕨",
                wp: "℘",
                wr: "≀",
                wreath: "≀",
                Wscr: "𝒲",
                wscr: "𝓌",
                xcap: "⋂",
                xcirc: "◯",
                xcup: "⋃",
                xdtri: "▽",
                Xfr: "𝔛",
                xfr: "𝔵",
                xhArr: "⟺",
                xharr: "⟷",
                Xi: "Ξ",
                xi: "ξ",
                xlArr: "⟸",
                xlarr: "⟵",
                xmap: "⟼",
                xnis: "⋻",
                xodot: "⨀",
                Xopf: "𝕏",
                xopf: "𝕩",
                xoplus: "⨁",
                xotime: "⨂",
                xrArr: "⟹",
                xrarr: "⟶",
                Xscr: "𝒳",
                xscr: "𝓍",
                xsqcup: "⨆",
                xuplus: "⨄",
                xutri: "△",
                xvee: "⋁",
                xwedge: "⋀",
                Yacute: "Ý",
                yacute: "ý",
                YAcy: "Я",
                yacy: "я",
                Ycirc: "Ŷ",
                ycirc: "ŷ",
                Ycy: "Ы",
                ycy: "ы",
                yen: "¥",
                Yfr: "𝔜",
                yfr: "𝔶",
                YIcy: "Ї",
                yicy: "ї",
                Yopf: "𝕐",
                yopf: "𝕪",
                Yscr: "𝒴",
                yscr: "𝓎",
                YUcy: "Ю",
                yucy: "ю",
                Yuml: "Ÿ",
                yuml: "ÿ",
                Zacute: "Ź",
                zacute: "ź",
                Zcaron: "Ž",
                zcaron: "ž",
                Zcy: "З",
                zcy: "з",
                Zdot: "Ż",
                zdot: "ż",
                zeetrf: "ℨ",
                ZeroWidthSpace: "​",
                Zeta: "Ζ",
                zeta: "ζ",
                Zfr: "ℨ",
                zfr: "𝔷",
                ZHcy: "Ж",
                zhcy: "ж",
                zigrarr: "⇝",
                Zopf: "ℤ",
                zopf: "𝕫",
                Zscr: "𝒵",
                zscr: "𝓏",
                zwj: "‍",
                zwnj: "‌"
              });
              exports2.entityMap = exports2.HTML_ENTITIES;
            }
          ),
          /***/
          "./node_modules/@xmldom/xmldom/lib/index.js": (
            /*!**************************************************!*\
              !*** ./node_modules/@xmldom/xmldom/lib/index.js ***!
              \**************************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var dom = __webpack_require__2(
                /*! ./dom */
                "./node_modules/@xmldom/xmldom/lib/dom.js"
              );
              exports2.DOMImplementation = dom.DOMImplementation;
              exports2.XMLSerializer = dom.XMLSerializer;
              exports2.DOMParser = __webpack_require__2(
                /*! ./dom-parser */
                "./node_modules/@xmldom/xmldom/lib/dom-parser.js"
              ).DOMParser;
            }
          ),
          /***/
          "./node_modules/@xmldom/xmldom/lib/sax.js": (
            /*!************************************************!*\
              !*** ./node_modules/@xmldom/xmldom/lib/sax.js ***!
              \************************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var NAMESPACE = __webpack_require__2(
                /*! ./conventions */
                "./node_modules/@xmldom/xmldom/lib/conventions.js"
              ).NAMESPACE;
              var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
              var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
              var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
              var S_TAG = 0;
              var S_ATTR = 1;
              var S_ATTR_SPACE = 2;
              var S_EQ = 3;
              var S_ATTR_NOQUOT_VALUE = 4;
              var S_ATTR_END = 5;
              var S_TAG_SPACE = 6;
              var S_TAG_CLOSE = 7;
              function ParseError(message, locator) {
                this.message = message;
                this.locator = locator;
                if (Error.captureStackTrace)
                  Error.captureStackTrace(this, ParseError);
              }
              ParseError.prototype = new Error();
              ParseError.prototype.name = ParseError.name;
              function XMLReader() {
              }
              XMLReader.prototype = {
                parse: function(source, defaultNSMap, entityMap) {
                  var domBuilder = this.domBuilder;
                  domBuilder.startDocument();
                  _copy(defaultNSMap, defaultNSMap = {});
                  parse(
                    source,
                    defaultNSMap,
                    entityMap,
                    domBuilder,
                    this.errorHandler
                  );
                  domBuilder.endDocument();
                }
              };
              function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
                function fixedFromCharCode(code) {
                  if (code > 65535) {
                    code -= 65536;
                    var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
                    return String.fromCharCode(surrogate1, surrogate2);
                  } else {
                    return String.fromCharCode(code);
                  }
                }
                function entityReplacer(a2) {
                  var k = a2.slice(1, -1);
                  if (Object.hasOwnProperty.call(entityMap, k)) {
                    return entityMap[k];
                  } else if (k.charAt(0) === "#") {
                    return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
                  } else {
                    errorHandler.error("entity not found:" + a2);
                    return a2;
                  }
                }
                function appendText(end2) {
                  if (end2 > start) {
                    var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
                    locator && position(start);
                    domBuilder.characters(xt, 0, end2 - start);
                    start = end2;
                  }
                }
                function position(p, m) {
                  while (p >= lineEnd && (m = linePattern.exec(source))) {
                    lineStart = m.index;
                    lineEnd = lineStart + m[0].length;
                    locator.lineNumber++;
                  }
                  locator.columnNumber = p - lineStart + 1;
                }
                var lineStart = 0;
                var lineEnd = 0;
                var linePattern = /.*(?:\r\n?|\n)|.*$/g;
                var locator = domBuilder.locator;
                var parseStack = [{ currentNSMap: defaultNSMapCopy }];
                var closeMap = {};
                var start = 0;
                while (true) {
                  try {
                    var tagStart = source.indexOf("<", start);
                    if (tagStart < 0) {
                      if (!source.substr(start).match(/^\s*$/)) {
                        var doc = domBuilder.doc;
                        var text = doc.createTextNode(source.substr(start));
                        doc.appendChild(text);
                        domBuilder.currentElement = text;
                      }
                      return;
                    }
                    if (tagStart > start) {
                      appendText(tagStart);
                    }
                    switch (source.charAt(tagStart + 1)) {
                      case "/":
                        var end = source.indexOf(">", tagStart + 3);
                        var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
                        var config = parseStack.pop();
                        if (end < 0) {
                          tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                          errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                          end = tagStart + 1 + tagName.length;
                        } else if (tagName.match(/\s</)) {
                          tagName = tagName.replace(/[\s<].*/, "");
                          errorHandler.error("end tag name: " + tagName + " maybe not complete");
                          end = tagStart + 1 + tagName.length;
                        }
                        var localNSMap = config.localNSMap;
                        var endMatch = config.tagName == tagName;
                        var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
                        if (endIgnoreCaseMach) {
                          domBuilder.endElement(config.uri, config.localName, tagName);
                          if (localNSMap) {
                            for (var prefix in localNSMap) {
                              if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                                domBuilder.endPrefixMapping(prefix);
                              }
                            }
                          }
                          if (!endMatch) {
                            errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                          }
                        } else {
                          parseStack.push(config);
                        }
                        end++;
                        break;
                      case "?":
                        locator && position(tagStart);
                        end = parseInstruction(source, tagStart, domBuilder);
                        break;
                      case "!":
                        locator && position(tagStart);
                        end = parseDCC(source, tagStart, domBuilder, errorHandler);
                        break;
                      default:
                        locator && position(tagStart);
                        var el = new ElementAttributes();
                        var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
                        var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
                        var len = el.length;
                        if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                          el.closed = true;
                          if (!entityMap.nbsp) {
                            errorHandler.warning("unclosed xml attribute");
                          }
                        }
                        if (locator && len) {
                          var locator2 = copyLocator(locator, {});
                          for (var i = 0; i < len; i++) {
                            var a = el[i];
                            position(a.offset);
                            a.locator = copyLocator(locator, {});
                          }
                          domBuilder.locator = locator2;
                          if (appendElement(el, domBuilder, currentNSMap)) {
                            parseStack.push(el);
                          }
                          domBuilder.locator = locator;
                        } else {
                          if (appendElement(el, domBuilder, currentNSMap)) {
                            parseStack.push(el);
                          }
                        }
                        if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                          end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
                        } else {
                          end++;
                        }
                    }
                  } catch (e) {
                    if (e instanceof ParseError) {
                      throw e;
                    }
                    errorHandler.error("element parse error: " + e);
                    end = -1;
                  }
                  if (end > start) {
                    start = end;
                  } else {
                    appendText(Math.max(tagStart, start) + 1);
                  }
                }
              }
              function copyLocator(f, t) {
                t.lineNumber = f.lineNumber;
                t.columnNumber = f.columnNumber;
                return t;
              }
              function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
                function addAttribute(qname, value2, startIndex) {
                  if (el.attributeNames.hasOwnProperty(qname)) {
                    errorHandler.fatalError("Attribute " + qname + " redefined");
                  }
                  el.addValue(
                    qname,
                    // @see https://www.w3.org/TR/xml/#AVNormalize
                    // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
                    // - recursive replacement of (DTD) entity references
                    // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
                    value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
                    startIndex
                  );
                }
                var attrName;
                var value;
                var p = ++start;
                var s = S_TAG;
                while (true) {
                  var c = source.charAt(p);
                  switch (c) {
                    case "=":
                      if (s === S_ATTR) {
                        attrName = source.slice(start, p);
                        s = S_EQ;
                      } else if (s === S_ATTR_SPACE) {
                        s = S_EQ;
                      } else {
                        throw new Error("attribute equal must after attrName");
                      }
                      break;
                    case "'":
                    case '"':
                      if (s === S_EQ || s === S_ATTR) {
                        if (s === S_ATTR) {
                          errorHandler.warning('attribute value must after "="');
                          attrName = source.slice(start, p);
                        }
                        start = p + 1;
                        p = source.indexOf(c, start);
                        if (p > 0) {
                          value = source.slice(start, p);
                          addAttribute(attrName, value, start - 1);
                          s = S_ATTR_END;
                        } else {
                          throw new Error("attribute value no end '" + c + "' match");
                        }
                      } else if (s == S_ATTR_NOQUOT_VALUE) {
                        value = source.slice(start, p);
                        addAttribute(attrName, value, start);
                        errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
                        start = p + 1;
                        s = S_ATTR_END;
                      } else {
                        throw new Error('attribute value must after "="');
                      }
                      break;
                    case "/":
                      switch (s) {
                        case S_TAG:
                          el.setTagName(source.slice(start, p));
                        case S_ATTR_END:
                        case S_TAG_SPACE:
                        case S_TAG_CLOSE:
                          s = S_TAG_CLOSE;
                          el.closed = true;
                        case S_ATTR_NOQUOT_VALUE:
                        case S_ATTR:
                          break;
                        case S_ATTR_SPACE:
                          el.closed = true;
                          break;
                        default:
                          throw new Error("attribute invalid close char('/')");
                      }
                      break;
                    case "":
                      errorHandler.error("unexpected end of input");
                      if (s == S_TAG) {
                        el.setTagName(source.slice(start, p));
                      }
                      return p;
                    case ">":
                      switch (s) {
                        case S_TAG:
                          el.setTagName(source.slice(start, p));
                        case S_ATTR_END:
                        case S_TAG_SPACE:
                        case S_TAG_CLOSE:
                          break;
                        case S_ATTR_NOQUOT_VALUE:
                        case S_ATTR:
                          value = source.slice(start, p);
                          if (value.slice(-1) === "/") {
                            el.closed = true;
                            value = value.slice(0, -1);
                          }
                        case S_ATTR_SPACE:
                          if (s === S_ATTR_SPACE) {
                            value = attrName;
                          }
                          if (s == S_ATTR_NOQUOT_VALUE) {
                            errorHandler.warning('attribute "' + value + '" missed quot(")!');
                            addAttribute(attrName, value, start);
                          } else {
                            if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                              errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                            }
                            addAttribute(value, value, start);
                          }
                          break;
                        case S_EQ:
                          throw new Error("attribute value missed!!");
                      }
                      return p;
                    case "":
                      c = " ";
                    default:
                      if (c <= " ") {
                        switch (s) {
                          case S_TAG:
                            el.setTagName(source.slice(start, p));
                            s = S_TAG_SPACE;
                            break;
                          case S_ATTR:
                            attrName = source.slice(start, p);
                            s = S_ATTR_SPACE;
                            break;
                          case S_ATTR_NOQUOT_VALUE:
                            var value = source.slice(start, p);
                            errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                            addAttribute(attrName, value, start);
                          case S_ATTR_END:
                            s = S_TAG_SPACE;
                            break;
                        }
                      } else {
                        switch (s) {
                          case S_ATTR_SPACE:
                            var tagName = el.tagName;
                            if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                              errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                            }
                            addAttribute(attrName, attrName, start);
                            start = p;
                            s = S_ATTR;
                            break;
                          case S_ATTR_END:
                            errorHandler.warning('attribute space is required"' + attrName + '"!!');
                          case S_TAG_SPACE:
                            s = S_ATTR;
                            start = p;
                            break;
                          case S_EQ:
                            s = S_ATTR_NOQUOT_VALUE;
                            start = p;
                            break;
                          case S_TAG_CLOSE:
                            throw new Error("elements closed character '/' and '>' must be connected to");
                        }
                      }
                  }
                  p++;
                }
              }
              function appendElement(el, domBuilder, currentNSMap) {
                var tagName = el.tagName;
                var localNSMap = null;
                var i = el.length;
                while (i--) {
                  var a = el[i];
                  var qName = a.qName;
                  var value = a.value;
                  var nsp = qName.indexOf(":");
                  if (nsp > 0) {
                    var prefix = a.prefix = qName.slice(0, nsp);
                    var localName = qName.slice(nsp + 1);
                    var nsPrefix = prefix === "xmlns" && localName;
                  } else {
                    localName = qName;
                    prefix = null;
                    nsPrefix = qName === "xmlns" && "";
                  }
                  a.localName = localName;
                  if (nsPrefix !== false) {
                    if (localNSMap == null) {
                      localNSMap = {};
                      _copy(currentNSMap, currentNSMap = {});
                    }
                    currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
                    a.uri = NAMESPACE.XMLNS;
                    domBuilder.startPrefixMapping(nsPrefix, value);
                  }
                }
                var i = el.length;
                while (i--) {
                  a = el[i];
                  var prefix = a.prefix;
                  if (prefix) {
                    if (prefix === "xml") {
                      a.uri = NAMESPACE.XML;
                    }
                    if (prefix !== "xmlns") {
                      a.uri = currentNSMap[prefix || ""];
                    }
                  }
                }
                var nsp = tagName.indexOf(":");
                if (nsp > 0) {
                  prefix = el.prefix = tagName.slice(0, nsp);
                  localName = el.localName = tagName.slice(nsp + 1);
                } else {
                  prefix = null;
                  localName = el.localName = tagName;
                }
                var ns = el.uri = currentNSMap[prefix || ""];
                domBuilder.startElement(ns, localName, tagName, el);
                if (el.closed) {
                  domBuilder.endElement(ns, localName, tagName);
                  if (localNSMap) {
                    for (prefix in localNSMap) {
                      if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                        domBuilder.endPrefixMapping(prefix);
                      }
                    }
                  }
                } else {
                  el.currentNSMap = currentNSMap;
                  el.localNSMap = localNSMap;
                  return true;
                }
              }
              function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
                if (/^(?:script|textarea)$/i.test(tagName)) {
                  var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
                  var text = source.substring(elStartEnd + 1, elEndStart);
                  if (/[&<]/.test(text)) {
                    if (/^script$/i.test(tagName)) {
                      domBuilder.characters(text, 0, text.length);
                      return elEndStart;
                    }
                    text = text.replace(/&#?\w+;/g, entityReplacer);
                    domBuilder.characters(text, 0, text.length);
                    return elEndStart;
                  }
                }
                return elStartEnd + 1;
              }
              function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
                var pos = closeMap[tagName];
                if (pos == null) {
                  pos = source.lastIndexOf("</" + tagName + ">");
                  if (pos < elStartEnd) {
                    pos = source.lastIndexOf("</" + tagName);
                  }
                  closeMap[tagName] = pos;
                }
                return pos < elStartEnd;
              }
              function _copy(source, target) {
                for (var n in source) {
                  if (Object.prototype.hasOwnProperty.call(source, n)) {
                    target[n] = source[n];
                  }
                }
              }
              function parseDCC(source, start, domBuilder, errorHandler) {
                var next = source.charAt(start + 2);
                switch (next) {
                  case "-":
                    if (source.charAt(start + 3) === "-") {
                      var end = source.indexOf("-->", start + 4);
                      if (end > start) {
                        domBuilder.comment(source, start + 4, end - start - 4);
                        return end + 3;
                      } else {
                        errorHandler.error("Unclosed comment");
                        return -1;
                      }
                    } else {
                      return -1;
                    }
                  default:
                    if (source.substr(start + 3, 6) == "CDATA[") {
                      var end = source.indexOf("]]>", start + 9);
                      domBuilder.startCDATA();
                      domBuilder.characters(source, start + 9, end - start - 9);
                      domBuilder.endCDATA();
                      return end + 3;
                    }
                    var matchs = split(source, start);
                    var len = matchs.length;
                    if (len > 1 && /!doctype/i.test(matchs[0][0])) {
                      var name = matchs[1][0];
                      var pubid = false;
                      var sysid = false;
                      if (len > 3) {
                        if (/^public$/i.test(matchs[2][0])) {
                          pubid = matchs[3][0];
                          sysid = len > 4 && matchs[4][0];
                        } else if (/^system$/i.test(matchs[2][0])) {
                          sysid = matchs[3][0];
                        }
                      }
                      var lastMatch = matchs[len - 1];
                      domBuilder.startDTD(name, pubid, sysid);
                      domBuilder.endDTD();
                      return lastMatch.index + lastMatch[0].length;
                    }
                }
                return -1;
              }
              function parseInstruction(source, start, domBuilder) {
                var end = source.indexOf("?>", start);
                if (end) {
                  var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
                  if (match) {
                    var len = match[0].length;
                    domBuilder.processingInstruction(match[1], match[2]);
                    return end + 2;
                  } else {
                    return -1;
                  }
                }
                return -1;
              }
              function ElementAttributes() {
                this.attributeNames = {};
              }
              ElementAttributes.prototype = {
                setTagName: function(tagName) {
                  if (!tagNamePattern.test(tagName)) {
                    throw new Error("invalid tagName:" + tagName);
                  }
                  this.tagName = tagName;
                },
                addValue: function(qName, value, offset) {
                  if (!tagNamePattern.test(qName)) {
                    throw new Error("invalid attribute:" + qName);
                  }
                  this.attributeNames[qName] = this.length;
                  this[this.length++] = { qName, value, offset };
                },
                length: 0,
                getLocalName: function(i) {
                  return this[i].localName;
                },
                getLocator: function(i) {
                  return this[i].locator;
                },
                getQName: function(i) {
                  return this[i].qName;
                },
                getURI: function(i) {
                  return this[i].uri;
                },
                getValue: function(i) {
                  return this[i].value;
                }
                //	,getIndex:function(uri, localName)){
                //		if(localName){
                //
                //		}else{
                //			var qName = uri
                //		}
                //	},
                //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
                //	getType:function(uri,localName){}
                //	getType:function(i){},
              };
              function split(source, start) {
                var match;
                var buf = [];
                var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
                reg.lastIndex = start;
                reg.exec(source);
                while (match = reg.exec(source)) {
                  buf.push(match);
                  if (match[1])
                    return buf;
                }
              }
              exports2.XMLReader = XMLReader;
              exports2.ParseError = ParseError;
            }
          ),
          /***/
          "./node_modules/process/browser.js": (
            /*!*****************************************!*\
              !*** ./node_modules/process/browser.js ***!
              \*****************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2) {
              var process2 = module2.exports = {};
              var cachedSetTimeout;
              var cachedClearTimeout;
              function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
              }
              function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
              }
              (function() {
                try {
                  if (typeof setTimeout === "function") {
                    cachedSetTimeout = setTimeout;
                  } else {
                    cachedSetTimeout = defaultSetTimout;
                  }
                } catch (e) {
                  cachedSetTimeout = defaultSetTimout;
                }
                try {
                  if (typeof clearTimeout === "function") {
                    cachedClearTimeout = clearTimeout;
                  } else {
                    cachedClearTimeout = defaultClearTimeout;
                  }
                } catch (e) {
                  cachedClearTimeout = defaultClearTimeout;
                }
              })();
              function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) {
                  return setTimeout(fun, 0);
                }
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                  cachedSetTimeout = setTimeout;
                  return setTimeout(fun, 0);
                }
                try {
                  return cachedSetTimeout(fun, 0);
                } catch (e) {
                  try {
                    return cachedSetTimeout.call(null, fun, 0);
                  } catch (e2) {
                    return cachedSetTimeout.call(this, fun, 0);
                  }
                }
              }
              function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) {
                  return clearTimeout(marker);
                }
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                  cachedClearTimeout = clearTimeout;
                  return clearTimeout(marker);
                }
                try {
                  return cachedClearTimeout(marker);
                } catch (e) {
                  try {
                    return cachedClearTimeout.call(null, marker);
                  } catch (e2) {
                    return cachedClearTimeout.call(this, marker);
                  }
                }
              }
              var queue = [];
              var draining = false;
              var currentQueue;
              var queueIndex = -1;
              function cleanUpNextTick() {
                if (!draining || !currentQueue) {
                  return;
                }
                draining = false;
                if (currentQueue.length) {
                  queue = currentQueue.concat(queue);
                } else {
                  queueIndex = -1;
                }
                if (queue.length) {
                  drainQueue();
                }
              }
              function drainQueue() {
                if (draining) {
                  return;
                }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;
                var len = queue.length;
                while (len) {
                  currentQueue = queue;
                  queue = [];
                  while (++queueIndex < len) {
                    if (currentQueue) {
                      currentQueue[queueIndex].run();
                    }
                  }
                  queueIndex = -1;
                  len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
              }
              process2.nextTick = function(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                  for (var i = 1; i < arguments.length; i++) {
                    args[i - 1] = arguments[i];
                  }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                  runTimeout(drainQueue);
                }
              };
              function Item(fun, array) {
                this.fun = fun;
                this.array = array;
              }
              Item.prototype.run = function() {
                this.fun.apply(null, this.array);
              };
              process2.title = "browser";
              process2.browser = true;
              process2.env = {};
              process2.argv = [];
              process2.version = "";
              process2.versions = {};
              function noop() {
              }
              process2.on = noop;
              process2.addListener = noop;
              process2.once = noop;
              process2.off = noop;
              process2.removeListener = noop;
              process2.removeAllListeners = noop;
              process2.emit = noop;
              process2.prependListener = noop;
              process2.prependOnceListener = noop;
              process2.listeners = function(name) {
                return [];
              };
              process2.binding = function(name) {
                throw new Error("process.binding is not supported");
              };
              process2.cwd = function() {
                return "/";
              };
              process2.chdir = function(dir) {
                throw new Error("process.chdir is not supported");
              };
              process2.umask = function() {
                return 0;
              };
            }
          ),
          /***/
          "./node_modules/webpack/buildin/amd-options.js": (
            /*!****************************************!*\
              !*** (webpack)/buildin/amd-options.js ***!
              \****************************************/
            /*! no static exports found */
            /***/
            function(module2, exports2) {
              (function(__webpack_amd_options__) {
                module2.exports = __webpack_amd_options__;
              }).call(this, {});
            }
          ),
          /***/
          "./node_modules/webpack/buildin/global.js": (
            /*!***********************************!*\
              !*** (webpack)/buildin/global.js ***!
              \***********************************/
            /*! no static exports found */
            /***/
            function(module2, exports2) {
              var g;
              g = function() {
                return this;
              }();
              try {
                g = g || new Function("return this")();
              } catch (e) {
                if (typeof window === "object")
                  g = window;
              }
              module2.exports = g;
            }
          ),
          /***/
          "./node_modules/webpack/buildin/module.js": (
            /*!***********************************!*\
              !*** (webpack)/buildin/module.js ***!
              \***********************************/
            /*! no static exports found */
            /***/
            function(module2, exports2) {
              module2.exports = function(module3) {
                if (!module3.webpackPolyfill) {
                  module3.deprecate = function() {
                  };
                  module3.paths = [];
                  if (!module3.children)
                    module3.children = [];
                  Object.defineProperty(module3, "loaded", {
                    enumerable: true,
                    get: function() {
                      return module3.l;
                    }
                  });
                  Object.defineProperty(module3, "id", {
                    enumerable: true,
                    get: function() {
                      return module3.i;
                    }
                  });
                  module3.webpackPolyfill = 1;
                }
                return module3;
              };
            }
          ),
          /***/
          "./package.json": (
            /*!**********************!*\
              !*** ./package.json ***!
              \**********************/
            /*! exports provided: name, version, description, main, types, scripts, repository, keywords, author, license, bugs, homepage, dependencies, devDependencies, default */
            /***/
            function(module2) {
              module2.exports = JSON.parse('{"name":"cos-js-sdk-v5","version":"1.4.21","description":"JavaScript SDK for [腾讯云对象存储](https://cloud.tencent.com/product/cos)","main":"dist/cos-js-sdk-v5.js","types":"index.d.ts","scripts":{"prettier":"prettier --write src demo/demo.js test/test.js server/sts.js index.d.ts","server":"node server/sts.js","dev":"cross-env NODE_ENV=development webpack -w --mode=development","build":"cross-env NODE_ENV=production webpack --mode=production","cos-auth.min.js":"uglifyjs ./demo/common/cos-auth.js -o ./demo/common/cos-auth.min.js -c -m","test":"jest --runInBand --coverage"},"repository":{"type":"git","url":"git+https://github.com/tencentyun/cos-js-sdk-v5.git"},"keywords":[],"author":"carsonxu","license":"ISC","bugs":{"url":"https://github.com/tencentyun/cos-js-sdk-v5/issues"},"homepage":"https://github.com/tencentyun/cos-js-sdk-v5#readme","dependencies":{"@xmldom/xmldom":"^0.8.6"},"devDependencies":{"@babel/core":"7.17.9","@babel/plugin-transform-runtime":"7.18.10","@babel/preset-env":"7.16.11","babel-loader":"8.2.5","body-parser":"^1.18.3","cross-env":"^5.2.0","express":"^4.16.4","jest":"^29.3.1","jest-environment-jsdom":"^29.3.1","prettier":"^3.0.1","qcloud-cos-sts":"^3.0.2","request":"^2.87.0","terser-webpack-plugin":"4.2.3","uglifyjs":"^2.4.11","webpack":"4.46.0","webpack-cli":"4.10.0"}}');
            }
          ),
          /***/
          "./src/advance.js": (
            /*!************************!*\
              !*** ./src/advance.js ***!
              \************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var _typeof2 = __webpack_require__2(
                /*! @babel/runtime/helpers/typeof */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              );
              var session = __webpack_require__2(
                /*! ./session */
                "./src/session.js"
              );
              var Async = __webpack_require__2(
                /*! ./async */
                "./src/async.js"
              );
              var EventProxy = __webpack_require__2(
                /*! ./event */
                "./src/event.js"
              ).EventProxy;
              var util = __webpack_require__2(
                /*! ./util */
                "./src/util.js"
              );
              var Tracker = __webpack_require__2(
                /*! ./tracker */
                "./src/tracker.js"
              );
              function sliceUploadFile(params, callback) {
                var self2 = this;
                var ep = new EventProxy();
                var TaskId = params.TaskId;
                var Bucket = params.Bucket;
                var Region = params.Region;
                var Key = params.Key;
                var Body = params.Body;
                var ChunkSize = params.ChunkSize || params.SliceSize || self2.options.ChunkSize;
                var AsyncLimit = params.AsyncLimit;
                var StorageClass = params.StorageClass;
                var ServerSideEncryption = params.ServerSideEncryption;
                var FileSize;
                var onProgress;
                var onHashProgress = params.onHashProgress;
                var tracker = params.tracker;
                tracker && tracker.setParams({
                  chunkSize: ChunkSize
                });
                ep.on("error", function(err) {
                  if (!self2._isRunningTask(TaskId))
                    return;
                  err.UploadId = params.UploadData.UploadId || "";
                  return callback(err);
                });
                ep.on("upload_complete", function(UploadCompleteData) {
                  var _UploadCompleteData = util.extend({
                    UploadId: params.UploadData.UploadId || ""
                  }, UploadCompleteData);
                  callback(null, _UploadCompleteData);
                });
                ep.on("upload_slice_complete", function(UploadData) {
                  var metaHeaders = {};
                  util.each(params.Headers, function(val, k) {
                    var shortKey = k.toLowerCase();
                    if (shortKey.indexOf("x-cos-meta-") === 0 || shortKey === "pic-operations")
                      metaHeaders[k] = val;
                  });
                  uploadSliceComplete.call(self2, {
                    Bucket,
                    Region,
                    Key,
                    UploadId: UploadData.UploadId,
                    SliceList: UploadData.SliceList,
                    Headers: metaHeaders,
                    tracker
                  }, function(err, data) {
                    if (!self2._isRunningTask(TaskId))
                      return;
                    session.removeUsing(UploadData.UploadId);
                    if (err) {
                      onProgress(null, true);
                      return ep.emit("error", err);
                    }
                    session.removeUploadId.call(self2, UploadData.UploadId);
                    onProgress({
                      loaded: FileSize,
                      total: FileSize
                    }, true);
                    ep.emit("upload_complete", data);
                  });
                });
                ep.on("get_upload_data_finish", function(UploadData) {
                  var uuid = session.getFileId(Body, params.ChunkSize, Bucket, Key);
                  uuid && session.saveUploadId.call(self2, uuid, UploadData.UploadId, self2.options.UploadIdCacheLimit);
                  session.setUsing(UploadData.UploadId);
                  onProgress(null, true);
                  uploadSliceList.call(self2, {
                    TaskId,
                    Bucket,
                    Region,
                    Key,
                    Body,
                    FileSize,
                    SliceSize: ChunkSize,
                    AsyncLimit,
                    ServerSideEncryption,
                    UploadData,
                    Headers: params.Headers,
                    onProgress,
                    tracker
                  }, function(err, data) {
                    if (!self2._isRunningTask(TaskId))
                      return;
                    if (err) {
                      onProgress(null, true);
                      return ep.emit("error", err);
                    }
                    ep.emit("upload_slice_complete", data);
                  });
                });
                ep.on("get_file_size_finish", function() {
                  onProgress = util.throttleOnProgress.call(self2, FileSize, params.onProgress);
                  if (params.UploadData.UploadId) {
                    ep.emit("get_upload_data_finish", params.UploadData);
                  } else {
                    var _params = util.extend({
                      TaskId,
                      Bucket,
                      Region,
                      Key,
                      Headers: params.Headers,
                      StorageClass,
                      Body,
                      FileSize,
                      SliceSize: ChunkSize,
                      onHashProgress,
                      tracker
                    }, params);
                    getUploadIdAndPartList.call(self2, _params, function(err, UploadData) {
                      if (!self2._isRunningTask(TaskId))
                        return;
                      if (err)
                        return ep.emit("error", err);
                      params.UploadData.UploadId = UploadData.UploadId;
                      params.UploadData.PartList = UploadData.PartList;
                      ep.emit("get_upload_data_finish", params.UploadData);
                    });
                  }
                });
                FileSize = params.ContentLength;
                delete params.ContentLength;
                !params.Headers && (params.Headers = {});
                util.each(params.Headers, function(item, key) {
                  if (key.toLowerCase() === "content-length") {
                    delete params.Headers[key];
                  }
                });
                (function() {
                  var SIZE = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 1024 * 2, 1024 * 4, 1024 * 5];
                  var AutoChunkSize = 1024 * 1024;
                  for (var i = 0; i < SIZE.length; i++) {
                    AutoChunkSize = SIZE[i] * 1024 * 1024;
                    if (FileSize / AutoChunkSize <= self2.options.MaxPartNumber)
                      break;
                  }
                  params.ChunkSize = params.SliceSize = ChunkSize = Math.max(ChunkSize, AutoChunkSize);
                })();
                if (FileSize === 0) {
                  params.Body = "";
                  params.ContentLength = 0;
                  params.SkipTask = true;
                  self2.putObject(params, callback);
                } else {
                  ep.emit("get_file_size_finish");
                }
              }
              function getUploadIdAndPartList(params, callback) {
                var TaskId = params.TaskId;
                var Bucket = params.Bucket;
                var Region = params.Region;
                var Key = params.Key;
                var StorageClass = params.StorageClass;
                var self2 = this;
                var ETagMap = {};
                var FileSize = params.FileSize;
                var SliceSize = params.SliceSize;
                var SliceCount = Math.ceil(FileSize / SliceSize);
                var FinishSliceCount = 0;
                var FinishSize = 0;
                var onHashProgress = util.throttleOnProgress.call(self2, FileSize, params.onHashProgress);
                var getChunkETag = function getChunkETag2(PartNumber, callback2) {
                  var start = SliceSize * (PartNumber - 1);
                  var end = Math.min(start + SliceSize, FileSize);
                  var ChunkSize = end - start;
                  if (ETagMap[PartNumber]) {
                    callback2(null, {
                      PartNumber,
                      ETag: ETagMap[PartNumber],
                      Size: ChunkSize
                    });
                  } else {
                    util.fileSlice(params.Body, start, end, false, function(chunkItem) {
                      util.getFileMd5(chunkItem, function(err, md5) {
                        if (err)
                          return callback2(util.error(err));
                        var ETag = '"' + md5 + '"';
                        ETagMap[PartNumber] = ETag;
                        FinishSliceCount += 1;
                        FinishSize += ChunkSize;
                        onHashProgress({
                          loaded: FinishSize,
                          total: FileSize
                        });
                        callback2(null, {
                          PartNumber,
                          ETag,
                          Size: ChunkSize
                        });
                      });
                    });
                  }
                };
                var isAvailableUploadList = function isAvailableUploadList2(PartList, callback2) {
                  var PartCount = PartList.length;
                  if (PartCount === 0) {
                    return callback2(null, true);
                  }
                  if (PartCount > SliceCount) {
                    return callback2(null, false);
                  }
                  if (PartCount > 1) {
                    var PartSliceSize = Math.max(PartList[0].Size, PartList[1].Size);
                    if (PartSliceSize !== SliceSize) {
                      return callback2(null, false);
                    }
                  }
                  var next = function next2(index) {
                    if (index < PartCount) {
                      var Part = PartList[index];
                      getChunkETag(Part.PartNumber, function(err, chunk) {
                        if (chunk && chunk.ETag === Part.ETag && chunk.Size === Part.Size) {
                          next2(index + 1);
                        } else {
                          callback2(null, false);
                        }
                      });
                    } else {
                      callback2(null, true);
                    }
                  };
                  next(0);
                };
                var ep = new EventProxy();
                ep.on("error", function(errData) {
                  if (!self2._isRunningTask(TaskId))
                    return;
                  return callback(errData);
                });
                ep.on("upload_id_available", function(UploadData) {
                  var map = {};
                  var list = [];
                  util.each(UploadData.PartList, function(item2) {
                    map[item2.PartNumber] = item2;
                  });
                  for (var PartNumber = 1; PartNumber <= SliceCount; PartNumber++) {
                    var item = map[PartNumber];
                    if (item) {
                      item.PartNumber = PartNumber;
                      item.Uploaded = true;
                    } else {
                      item = {
                        PartNumber,
                        ETag: null,
                        Uploaded: false
                      };
                    }
                    list.push(item);
                  }
                  UploadData.PartList = list;
                  callback(null, UploadData);
                });
                ep.on("no_available_upload_id", function() {
                  if (!self2._isRunningTask(TaskId))
                    return;
                  var _params = util.extend({
                    Bucket,
                    Region,
                    Key,
                    Query: util.clone(params.Query),
                    StorageClass,
                    Body: params.Body,
                    calledBySdk: "sliceUploadFile",
                    tracker: params.tracker
                  }, params);
                  var headers = util.clone(params.Headers);
                  delete headers["x-cos-mime-limit"];
                  _params.Headers = headers;
                  self2.multipartInit(_params, function(err, data) {
                    if (!self2._isRunningTask(TaskId))
                      return;
                    if (err)
                      return ep.emit("error", err);
                    var UploadId = data.UploadId;
                    if (!UploadId) {
                      return callback(util.error(new Error("no such upload id")));
                    }
                    ep.emit("upload_id_available", {
                      UploadId,
                      PartList: []
                    });
                  });
                });
                ep.on("has_and_check_upload_id", function(UploadIdList) {
                  UploadIdList = UploadIdList.reverse();
                  Async.eachLimit(UploadIdList, 1, function(UploadId, asyncCallback) {
                    if (!self2._isRunningTask(TaskId))
                      return;
                    if (session.using[UploadId]) {
                      asyncCallback();
                      return;
                    }
                    wholeMultipartListPart.call(self2, {
                      Bucket,
                      Region,
                      Key,
                      UploadId,
                      tracker: params.tracker
                    }, function(err, PartListData) {
                      if (!self2._isRunningTask(TaskId))
                        return;
                      if (err) {
                        session.removeUsing(UploadId);
                        return ep.emit("error", err);
                      }
                      var PartList = PartListData.PartList;
                      PartList.forEach(function(item) {
                        item.PartNumber *= 1;
                        item.Size *= 1;
                        item.ETag = item.ETag || "";
                      });
                      isAvailableUploadList(PartList, function(err2, isAvailable) {
                        if (!self2._isRunningTask(TaskId))
                          return;
                        if (err2)
                          return ep.emit("error", err2);
                        if (isAvailable) {
                          asyncCallback({
                            UploadId,
                            PartList
                          });
                        } else {
                          asyncCallback();
                        }
                      });
                    });
                  }, function(AvailableUploadData) {
                    if (!self2._isRunningTask(TaskId))
                      return;
                    onHashProgress(null, true);
                    if (AvailableUploadData && AvailableUploadData.UploadId) {
                      ep.emit("upload_id_available", AvailableUploadData);
                    } else {
                      ep.emit("no_available_upload_id");
                    }
                  });
                });
                ep.on("seek_local_avail_upload_id", function(RemoteUploadIdList) {
                  var uuid = session.getFileId(params.Body, params.ChunkSize, Bucket, Key);
                  var LocalUploadIdList = session.getUploadIdList.call(self2, uuid);
                  if (!uuid || !LocalUploadIdList) {
                    ep.emit("has_and_check_upload_id", RemoteUploadIdList);
                    return;
                  }
                  var next = function next2(index) {
                    if (index >= LocalUploadIdList.length) {
                      ep.emit("has_and_check_upload_id", RemoteUploadIdList);
                      return;
                    }
                    var UploadId = LocalUploadIdList[index];
                    if (!util.isInArray(RemoteUploadIdList, UploadId)) {
                      session.removeUploadId.call(self2, UploadId);
                      next2(index + 1);
                      return;
                    }
                    if (session.using[UploadId]) {
                      next2(index + 1);
                      return;
                    }
                    wholeMultipartListPart.call(self2, {
                      Bucket,
                      Region,
                      Key,
                      UploadId,
                      tracker: params.tracker
                    }, function(err, PartListData) {
                      if (!self2._isRunningTask(TaskId))
                        return;
                      if (err) {
                        session.removeUploadId.call(self2, UploadId);
                        next2(index + 1);
                      } else {
                        ep.emit("upload_id_available", {
                          UploadId,
                          PartList: PartListData.PartList
                        });
                      }
                    });
                  };
                  next(0);
                });
                ep.on("get_remote_upload_id_list", function() {
                  wholeMultipartList.call(self2, {
                    Bucket,
                    Region,
                    Key,
                    tracker: params.tracker
                  }, function(err, data) {
                    if (!self2._isRunningTask(TaskId))
                      return;
                    if (err)
                      return ep.emit("error", err);
                    var RemoteUploadIdList = util.filter(data.UploadList, function(item) {
                      return item.Key === Key && (!StorageClass || item.StorageClass.toUpperCase() === StorageClass.toUpperCase());
                    }).reverse().map(function(item) {
                      return item.UploadId || item.UploadID;
                    });
                    if (RemoteUploadIdList.length) {
                      ep.emit("seek_local_avail_upload_id", RemoteUploadIdList);
                    } else {
                      var uuid = session.getFileId(params.Body, params.ChunkSize, Bucket, Key), LocalUploadIdList;
                      if (uuid && (LocalUploadIdList = session.getUploadIdList.call(self2, uuid))) {
                        util.each(LocalUploadIdList, function(UploadId) {
                          session.removeUploadId.call(self2, UploadId);
                        });
                      }
                      ep.emit("no_available_upload_id");
                    }
                  });
                });
                ep.emit("get_remote_upload_id_list");
              }
              function wholeMultipartList(params, callback) {
                var self2 = this;
                var UploadList = [];
                var sendParams = {
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Prefix: params.Key,
                  calledBySdk: params.calledBySdk || "sliceUploadFile",
                  tracker: params.tracker
                };
                var next = function next2() {
                  self2.multipartList(sendParams, function(err, data) {
                    if (err)
                      return callback(err);
                    UploadList.push.apply(UploadList, data.Upload || []);
                    if (data.IsTruncated === "true") {
                      sendParams.KeyMarker = data.NextKeyMarker;
                      sendParams.UploadIdMarker = data.NextUploadIdMarker;
                      next2();
                    } else {
                      callback(null, {
                        UploadList
                      });
                    }
                  });
                };
                next();
              }
              function wholeMultipartListPart(params, callback) {
                var self2 = this;
                var PartList = [];
                var sendParams = {
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  UploadId: params.UploadId,
                  calledBySdk: "sliceUploadFile",
                  tracker: params.tracker
                };
                var next = function next2() {
                  self2.multipartListPart(sendParams, function(err, data) {
                    if (err)
                      return callback(err);
                    PartList.push.apply(PartList, data.Part || []);
                    if (data.IsTruncated === "true") {
                      sendParams.PartNumberMarker = data.NextPartNumberMarker;
                      next2();
                    } else {
                      callback(null, {
                        PartList
                      });
                    }
                  });
                };
                next();
              }
              function uploadSliceList(params, cb) {
                var self2 = this;
                var TaskId = params.TaskId;
                var Bucket = params.Bucket;
                var Region = params.Region;
                var Key = params.Key;
                var UploadData = params.UploadData;
                var FileSize = params.FileSize;
                var SliceSize = params.SliceSize;
                var ChunkParallel = Math.min(params.AsyncLimit || self2.options.ChunkParallelLimit || 1, 256);
                var Body = params.Body;
                var SliceCount = Math.ceil(FileSize / SliceSize);
                var FinishSize = 0;
                var ServerSideEncryption = params.ServerSideEncryption;
                var Headers = params.Headers;
                var needUploadSlices = util.filter(UploadData.PartList, function(SliceItem) {
                  if (SliceItem["Uploaded"]) {
                    FinishSize += SliceItem["PartNumber"] >= SliceCount ? FileSize % SliceSize || SliceSize : SliceSize;
                  }
                  return !SliceItem["Uploaded"];
                });
                var _onProgress2 = params.onProgress;
                Async.eachLimit(needUploadSlices, ChunkParallel, function(SliceItem, asyncCallback) {
                  if (!self2._isRunningTask(TaskId))
                    return;
                  var PartNumber = SliceItem["PartNumber"];
                  var currentSize = Math.min(FileSize, SliceItem["PartNumber"] * SliceSize) - (SliceItem["PartNumber"] - 1) * SliceSize;
                  var preAddSize = 0;
                  uploadSliceItem.call(self2, {
                    TaskId,
                    Bucket,
                    Region,
                    Key,
                    SliceSize,
                    FileSize,
                    PartNumber,
                    ServerSideEncryption,
                    Body,
                    UploadData,
                    Headers,
                    onProgress: function onProgress(data) {
                      FinishSize += data.loaded - preAddSize;
                      preAddSize = data.loaded;
                      _onProgress2({
                        loaded: FinishSize,
                        total: FileSize
                      });
                    },
                    tracker: params.tracker
                  }, function(err, data) {
                    if (!self2._isRunningTask(TaskId))
                      return;
                    if (!err && !data.ETag)
                      err = 'get ETag error, please add "ETag" to CORS ExposeHeader setting.( 获取ETag失败，请在CORS ExposeHeader设置中添加ETag，请参考文档：https://cloud.tencent.com/document/product/436/13318 )';
                    if (err) {
                      FinishSize -= preAddSize;
                    } else {
                      FinishSize += currentSize - preAddSize;
                      SliceItem.ETag = data.ETag;
                    }
                    _onProgress2({
                      loaded: FinishSize,
                      total: FileSize
                    });
                    asyncCallback(err || null, data);
                  });
                }, function(err) {
                  if (!self2._isRunningTask(TaskId))
                    return;
                  if (err)
                    return cb(err);
                  cb(null, {
                    UploadId: UploadData.UploadId,
                    SliceList: UploadData.PartList
                  });
                });
              }
              function uploadSliceItem(params, callback) {
                var self2 = this;
                var TaskId = params.TaskId;
                var Bucket = params.Bucket;
                var Region = params.Region;
                var Key = params.Key;
                var FileSize = params.FileSize;
                var FileBody = params.Body;
                var PartNumber = params.PartNumber * 1;
                var SliceSize = params.SliceSize;
                var ServerSideEncryption = params.ServerSideEncryption;
                var UploadData = params.UploadData;
                var Headers = params.Headers || {};
                var ChunkRetryTimes = self2.options.ChunkRetryTimes + 1;
                var start = SliceSize * (PartNumber - 1);
                var ContentLength = SliceSize;
                var end = start + SliceSize;
                if (end > FileSize) {
                  end = FileSize;
                  ContentLength = end - start;
                }
                var headersWhiteList = ["x-cos-traffic-limit", "x-cos-mime-limit"];
                var headers = {};
                util.each(Headers, function(v, k) {
                  if (headersWhiteList.indexOf(k) > -1) {
                    headers[k] = v;
                  }
                });
                var PartItem = UploadData.PartList[PartNumber - 1];
                Async.retry(ChunkRetryTimes, function(tryCallback) {
                  if (!self2._isRunningTask(TaskId))
                    return;
                  util.fileSlice(FileBody, start, end, true, function(Body) {
                    self2.multipartUpload({
                      TaskId,
                      Bucket,
                      Region,
                      Key,
                      ContentLength,
                      PartNumber,
                      UploadId: UploadData.UploadId,
                      ServerSideEncryption,
                      Body,
                      Headers: headers,
                      onProgress: params.onProgress,
                      calledBySdk: "sliceUploadFile",
                      tracker: params.tracker
                    }, function(err, data) {
                      if (!self2._isRunningTask(TaskId))
                        return;
                      if (err)
                        return tryCallback(err);
                      PartItem.Uploaded = true;
                      return tryCallback(null, data);
                    });
                  });
                }, function(err, data) {
                  if (!self2._isRunningTask(TaskId))
                    return;
                  return callback(err, data);
                });
              }
              function uploadSliceComplete(params, callback) {
                var Bucket = params.Bucket;
                var Region = params.Region;
                var Key = params.Key;
                var UploadId = params.UploadId;
                var SliceList = params.SliceList;
                var self2 = this;
                var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;
                var Headers = params.Headers;
                var Parts = SliceList.map(function(item) {
                  return {
                    PartNumber: item.PartNumber,
                    ETag: item.ETag
                  };
                });
                Async.retry(ChunkRetryTimes, function(tryCallback) {
                  self2.multipartComplete({
                    Bucket,
                    Region,
                    Key,
                    UploadId,
                    Parts,
                    Headers,
                    calledBySdk: "sliceUploadFile",
                    tracker: params.tracker
                  }, tryCallback);
                }, function(err, data) {
                  callback(err, data);
                });
              }
              function abortUploadTask(params, callback) {
                var Bucket = params.Bucket;
                var Region = params.Region;
                var Key = params.Key;
                var UploadId = params.UploadId;
                var Level = params.Level || "task";
                var AsyncLimit = params.AsyncLimit;
                var self2 = this;
                var ep = new EventProxy();
                ep.on("error", function(errData) {
                  return callback(errData);
                });
                ep.on("get_abort_array", function(AbortArray) {
                  abortUploadTaskArray.call(self2, {
                    Bucket,
                    Region,
                    Key,
                    Headers: params.Headers,
                    AsyncLimit,
                    AbortArray
                  }, callback);
                });
                if (Level === "bucket") {
                  wholeMultipartList.call(self2, {
                    Bucket,
                    Region,
                    calledBySdk: "abortUploadTask"
                  }, function(err, data) {
                    if (err)
                      return callback(err);
                    ep.emit("get_abort_array", data.UploadList || []);
                  });
                } else if (Level === "file") {
                  if (!Key)
                    return callback(util.error(new Error("abort_upload_task_no_key")));
                  wholeMultipartList.call(self2, {
                    Bucket,
                    Region,
                    Key,
                    calledBySdk: "abortUploadTask"
                  }, function(err, data) {
                    if (err)
                      return callback(err);
                    ep.emit("get_abort_array", data.UploadList || []);
                  });
                } else if (Level === "task") {
                  if (!UploadId)
                    return callback(util.error(new Error("abort_upload_task_no_id")));
                  if (!Key)
                    return callback(util.error(new Error("abort_upload_task_no_key")));
                  ep.emit("get_abort_array", [{
                    Key,
                    UploadId
                  }]);
                } else {
                  return callback(util.error(new Error("abort_unknown_level")));
                }
              }
              function abortUploadTaskArray(params, callback) {
                var Bucket = params.Bucket;
                var Region = params.Region;
                var Key = params.Key;
                var AbortArray = params.AbortArray;
                var AsyncLimit = params.AsyncLimit || 1;
                var self2 = this;
                var index = 0;
                var resultList = new Array(AbortArray.length);
                Async.eachLimit(AbortArray, AsyncLimit, function(AbortItem, nextItem) {
                  var eachIndex = index;
                  if (Key && Key !== AbortItem.Key) {
                    resultList[eachIndex] = {
                      error: {
                        KeyNotMatch: true
                      }
                    };
                    nextItem(null);
                    return;
                  }
                  var UploadId = AbortItem.UploadId || AbortItem.UploadID;
                  self2.multipartAbort({
                    Bucket,
                    Region,
                    Key: AbortItem.Key,
                    Headers: params.Headers,
                    UploadId
                  }, function(err) {
                    var task = {
                      Bucket,
                      Region,
                      Key: AbortItem.Key,
                      UploadId
                    };
                    resultList[eachIndex] = {
                      error: err,
                      task
                    };
                    nextItem(null);
                  });
                  index++;
                }, function(err) {
                  if (err)
                    return callback(err);
                  var successList = [];
                  var errorList = [];
                  for (var i = 0, len = resultList.length; i < len; i++) {
                    var item = resultList[i];
                    if (item["task"]) {
                      if (item["error"]) {
                        errorList.push(item["task"]);
                      } else {
                        successList.push(item["task"]);
                      }
                    }
                  }
                  return callback(null, {
                    successList,
                    errorList
                  });
                });
              }
              function uploadFile(params, callback) {
                var self2 = this;
                var SliceSize = params.SliceSize === void 0 ? self2.options.SliceSize : params.SliceSize;
                var taskList = [];
                var Body = params.Body;
                var FileSize = Body.size || Body.length || 0;
                var fileInfo = {
                  TaskId: ""
                };
                if (self2.options.EnableTracker) {
                  var accelerate = self2.options.UseAccelerate || typeof self2.options.Domain === "string" && self2.options.Domain.includes("accelerate.");
                  params.tracker = new Tracker({
                    bucket: params.Bucket,
                    region: params.Region,
                    apiName: "uploadFile",
                    fileKey: params.Key,
                    fileSize: FileSize,
                    accelerate,
                    deepTracker: self2.options.DeepTracker,
                    customId: self2.options.CustomId,
                    delay: self2.options.TrackerDelay
                  });
                }
                util.each(params, function(v, k) {
                  if (_typeof2(v) !== "object" && typeof v !== "function") {
                    fileInfo[k] = v;
                  }
                });
                var _onTaskReady = params.onTaskReady;
                var onTaskReady = function onTaskReady2(tid) {
                  fileInfo.TaskId = tid;
                  _onTaskReady && _onTaskReady(tid);
                };
                params.onTaskReady = onTaskReady;
                var api = FileSize > SliceSize ? "sliceUploadFile" : "putObject";
                var _onFileFinish = params.onFileFinish;
                var onFileFinish = function onFileFinish2(err, data) {
                  params.tracker && params.tracker.formatResult(err, data);
                  _onFileFinish && _onFileFinish(err, data, fileInfo);
                  callback && callback(err, data);
                };
                taskList.push({
                  api,
                  params,
                  callback: onFileFinish
                });
                self2._addTasks(taskList);
              }
              function uploadFiles(params, callback) {
                var self2 = this;
                var SliceSize = params.SliceSize === void 0 ? self2.options.SliceSize : params.SliceSize;
                var TotalSize = 0;
                var TotalFinish = 0;
                var onTotalProgress = util.throttleOnProgress.call(self2, TotalFinish, params.onProgress);
                var unFinishCount = params.files.length;
                var _onTotalFileFinish = params.onFileFinish;
                var resultList = Array(unFinishCount);
                var onTotalFileFinish = function onTotalFileFinish2(err, data, options) {
                  onTotalProgress(null, true);
                  _onTotalFileFinish && _onTotalFileFinish(err, data, options);
                  resultList[options.Index] = {
                    options,
                    error: err,
                    data
                  };
                  if (--unFinishCount <= 0 && callback) {
                    callback(null, {
                      files: resultList
                    });
                  }
                };
                var taskList = [];
                util.each(params.files, function(fileParams, index) {
                  (function() {
                    var Body = fileParams.Body;
                    var FileSize = Body.size || Body.length || 0;
                    var fileInfo = {
                      Index: index,
                      TaskId: ""
                    };
                    if (!self2.options.UseRawKey && fileParams.Key && fileParams.Key.substr(0, 1) === "/") {
                      fileParams.Key = fileParams.Key.substr(1);
                    }
                    TotalSize += FileSize;
                    if (self2.options.EnableTracker) {
                      var accelerate = self2.options.UseAccelerate || typeof self2.options.Domain === "string" && self2.options.Domain.includes("accelerate.");
                      fileParams.tracker = new Tracker({
                        bucket: fileParams.Bucket,
                        region: fileParams.Region,
                        apiName: "uploadFiles",
                        fileKey: fileParams.Key,
                        fileSize: FileSize,
                        accelerate,
                        deepTracker: self2.options.DeepTracker,
                        customId: self2.options.CustomId,
                        delay: self2.options.TrackerDelay
                      });
                    }
                    util.each(fileParams, function(v, k) {
                      if (_typeof2(v) !== "object" && typeof v !== "function") {
                        fileInfo[k] = v;
                      }
                    });
                    var _onTaskReady = fileParams.onTaskReady;
                    var onTaskReady = function onTaskReady2(tid) {
                      fileInfo.TaskId = tid;
                      _onTaskReady && _onTaskReady(tid);
                    };
                    fileParams.onTaskReady = onTaskReady;
                    var PreAddSize = 0;
                    var _onProgress = fileParams.onProgress;
                    var onProgress = function onProgress2(info) {
                      TotalFinish = TotalFinish - PreAddSize + info.loaded;
                      PreAddSize = info.loaded;
                      _onProgress && _onProgress(info);
                      onTotalProgress({
                        loaded: TotalFinish,
                        total: TotalSize
                      });
                    };
                    fileParams.onProgress = onProgress;
                    var api = FileSize > SliceSize ? "sliceUploadFile" : "putObject";
                    var _onFileFinish = fileParams.onFileFinish;
                    var onFileFinish = function onFileFinish2(err, data) {
                      fileParams.tracker && fileParams.tracker.formatResult(err, data);
                      _onFileFinish && _onFileFinish(err, data);
                      onTotalFileFinish && onTotalFileFinish(err, data, fileInfo);
                    };
                    taskList.push({
                      api,
                      params: fileParams,
                      callback: onFileFinish
                    });
                  })();
                });
                self2._addTasks(taskList);
              }
              function sliceCopyFile(params, callback) {
                var ep = new EventProxy();
                var self2 = this;
                var Bucket = params.Bucket;
                var Region = params.Region;
                var Key = params.Key;
                var CopySource = params.CopySource;
                var m = util.getSourceParams.call(this, CopySource);
                if (!m) {
                  callback(util.error(new Error("CopySource format error")));
                  return;
                }
                var SourceBucket = m.Bucket;
                var SourceRegion = m.Region;
                var SourceKey = decodeURIComponent(m.Key);
                var CopySliceSize = params.CopySliceSize === void 0 ? self2.options.CopySliceSize : params.CopySliceSize;
                CopySliceSize = Math.max(0, CopySliceSize);
                var ChunkSize = params.CopyChunkSize || this.options.CopyChunkSize;
                var ChunkParallel = this.options.CopyChunkParallelLimit;
                var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;
                var ChunkCount = 0;
                var FinishSize = 0;
                var FileSize;
                var onProgress;
                var SourceResHeaders = {};
                var SourceHeaders = {};
                var TargetHeader = {};
                ep.on("copy_slice_complete", function(UploadData) {
                  var metaHeaders = {};
                  util.each(params.Headers, function(val, k) {
                    if (k.toLowerCase().indexOf("x-cos-meta-") === 0)
                      metaHeaders[k] = val;
                  });
                  var Parts = util.map(UploadData.PartList, function(item) {
                    return {
                      PartNumber: item.PartNumber,
                      ETag: item.ETag
                    };
                  });
                  Async.retry(ChunkRetryTimes, function(tryCallback) {
                    self2.multipartComplete({
                      Bucket,
                      Region,
                      Key,
                      UploadId: UploadData.UploadId,
                      Parts,
                      calledBySdk: "sliceCopyFile"
                    }, tryCallback);
                  }, function(err, data) {
                    session.removeUsing(UploadData.UploadId);
                    if (err) {
                      onProgress(null, true);
                      return callback(err);
                    }
                    session.removeUploadId(UploadData.UploadId);
                    onProgress({
                      loaded: FileSize,
                      total: FileSize
                    }, true);
                    callback(null, data);
                  });
                });
                ep.on("get_copy_data_finish", function(UploadData) {
                  var uuid = session.getCopyFileId(CopySource, SourceResHeaders, ChunkSize, Bucket, Key);
                  uuid && session.saveUploadId(uuid, UploadData.UploadId, self2.options.UploadIdCacheLimit);
                  session.setUsing(UploadData.UploadId);
                  var needCopySlices = util.filter(UploadData.PartList, function(SliceItem) {
                    if (SliceItem["Uploaded"]) {
                      FinishSize += SliceItem["PartNumber"] >= ChunkCount ? FileSize % ChunkSize || ChunkSize : ChunkSize;
                    }
                    return !SliceItem["Uploaded"];
                  });
                  Async.eachLimit(needCopySlices, ChunkParallel, function(SliceItem, asyncCallback) {
                    var PartNumber = SliceItem.PartNumber;
                    var CopySourceRange = SliceItem.CopySourceRange;
                    var currentSize = SliceItem.end - SliceItem.start;
                    Async.retry(ChunkRetryTimes, function(tryCallback) {
                      copySliceItem.call(self2, {
                        Bucket,
                        Region,
                        Key,
                        CopySource,
                        UploadId: UploadData.UploadId,
                        PartNumber,
                        CopySourceRange
                      }, tryCallback);
                    }, function(err, data) {
                      if (err)
                        return asyncCallback(err);
                      FinishSize += currentSize;
                      onProgress({
                        loaded: FinishSize,
                        total: FileSize
                      });
                      SliceItem.ETag = data.ETag;
                      asyncCallback(err || null, data);
                    });
                  }, function(err) {
                    if (err) {
                      session.removeUsing(UploadData.UploadId);
                      onProgress(null, true);
                      return callback(err);
                    }
                    ep.emit("copy_slice_complete", UploadData);
                  });
                });
                ep.on("get_chunk_size_finish", function() {
                  var createNewUploadId = function createNewUploadId2() {
                    self2.multipartInit({
                      Bucket,
                      Region,
                      Key,
                      Headers: TargetHeader
                    }, function(err, data) {
                      if (err)
                        return callback(err);
                      params.UploadId = data.UploadId;
                      ep.emit("get_copy_data_finish", {
                        UploadId: params.UploadId,
                        PartList: params.PartList
                      });
                    });
                  };
                  var uuid = session.getCopyFileId(CopySource, SourceResHeaders, ChunkSize, Bucket, Key);
                  var LocalUploadIdList = session.getUploadIdList(uuid);
                  if (!uuid || !LocalUploadIdList)
                    return createNewUploadId();
                  var next = function next2(index) {
                    if (index >= LocalUploadIdList.length)
                      return createNewUploadId();
                    var UploadId = LocalUploadIdList[index];
                    if (session.using[UploadId])
                      return next2(index + 1);
                    wholeMultipartListPart.call(self2, {
                      Bucket,
                      Region,
                      Key,
                      UploadId
                    }, function(err, PartListData) {
                      if (err) {
                        session.removeUploadId(UploadId);
                        next2(index + 1);
                      } else {
                        if (session.using[UploadId])
                          return next2(index + 1);
                        var finishETagMap = {};
                        var offset = 0;
                        util.each(PartListData.PartList, function(PartItem) {
                          var size = parseInt(PartItem.Size);
                          var end = offset + size - 1;
                          finishETagMap[PartItem.PartNumber + "|" + offset + "|" + end] = PartItem.ETag;
                          offset += size;
                        });
                        util.each(params.PartList, function(PartItem) {
                          var ETag = finishETagMap[PartItem.PartNumber + "|" + PartItem.start + "|" + PartItem.end];
                          if (ETag) {
                            PartItem.ETag = ETag;
                            PartItem.Uploaded = true;
                          }
                        });
                        ep.emit("get_copy_data_finish", {
                          UploadId,
                          PartList: params.PartList
                        });
                      }
                    });
                  };
                  next(0);
                });
                ep.on("get_file_size_finish", function() {
                  (function() {
                    var SIZE = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 1024 * 2, 1024 * 4, 1024 * 5];
                    var AutoChunkSize = 1024 * 1024;
                    for (var i = 0; i < SIZE.length; i++) {
                      AutoChunkSize = SIZE[i] * 1024 * 1024;
                      if (FileSize / AutoChunkSize <= self2.options.MaxPartNumber)
                        break;
                    }
                    params.ChunkSize = ChunkSize = Math.max(ChunkSize, AutoChunkSize);
                    ChunkCount = Math.ceil(FileSize / ChunkSize);
                    var list = [];
                    for (var partNumber = 1; partNumber <= ChunkCount; partNumber++) {
                      var start = (partNumber - 1) * ChunkSize;
                      var end = partNumber * ChunkSize < FileSize ? partNumber * ChunkSize - 1 : FileSize - 1;
                      var item = {
                        PartNumber: partNumber,
                        start,
                        end,
                        CopySourceRange: "bytes=" + start + "-" + end
                      };
                      list.push(item);
                    }
                    params.PartList = list;
                  })();
                  if (params.Headers["x-cos-metadata-directive"] === "Replaced") {
                    TargetHeader = params.Headers;
                  } else {
                    TargetHeader = SourceHeaders;
                  }
                  TargetHeader["x-cos-storage-class"] = params.Headers["x-cos-storage-class"] || SourceHeaders["x-cos-storage-class"];
                  TargetHeader = util.clearKey(TargetHeader);
                  if (SourceHeaders["x-cos-storage-class"] === "ARCHIVE" || SourceHeaders["x-cos-storage-class"] === "DEEP_ARCHIVE") {
                    var restoreHeader = SourceHeaders["x-cos-restore"];
                    if (!restoreHeader || restoreHeader === 'ongoing-request="true"') {
                      callback(util.error(new Error("Unrestored archive object is not allowed to be copied")));
                      return;
                    }
                  }
                  delete TargetHeader["x-cos-copy-source"];
                  delete TargetHeader["x-cos-metadata-directive"];
                  delete TargetHeader["x-cos-copy-source-If-Modified-Since"];
                  delete TargetHeader["x-cos-copy-source-If-Unmodified-Since"];
                  delete TargetHeader["x-cos-copy-source-If-Match"];
                  delete TargetHeader["x-cos-copy-source-If-None-Match"];
                  ep.emit("get_chunk_size_finish");
                });
                self2.headObject({
                  Bucket: SourceBucket,
                  Region: SourceRegion,
                  Key: SourceKey
                }, function(err, data) {
                  if (err) {
                    if (err.statusCode && err.statusCode === 404) {
                      callback(util.error(err, {
                        ErrorStatus: SourceKey + " Not Exist"
                      }));
                    } else {
                      callback(err);
                    }
                    return;
                  }
                  FileSize = params.FileSize = data.headers["content-length"];
                  if (FileSize === void 0 || !FileSize) {
                    callback(util.error(new Error('get Content-Length error, please add "Content-Length" to CORS ExposeHeader setting.（ 获取Content-Length失败，请在CORS ExposeHeader设置中添加Content-Length，请参考文档：https://cloud.tencent.com/document/product/436/13318 ）')));
                    return;
                  }
                  onProgress = util.throttleOnProgress.call(self2, FileSize, params.onProgress);
                  if (FileSize <= CopySliceSize) {
                    if (!params.Headers["x-cos-metadata-directive"]) {
                      params.Headers["x-cos-metadata-directive"] = "Copy";
                    }
                    self2.putObjectCopy(params, function(err2, data2) {
                      if (err2) {
                        onProgress(null, true);
                        return callback(err2);
                      }
                      onProgress({
                        loaded: FileSize,
                        total: FileSize
                      }, true);
                      callback(err2, data2);
                    });
                  } else {
                    var resHeaders = data.headers;
                    SourceResHeaders = resHeaders;
                    SourceHeaders = {
                      "Cache-Control": resHeaders["cache-control"],
                      "Content-Disposition": resHeaders["content-disposition"],
                      "Content-Encoding": resHeaders["content-encoding"],
                      "Content-Type": resHeaders["content-type"],
                      Expires: resHeaders["expires"],
                      "x-cos-storage-class": resHeaders["x-cos-storage-class"]
                    };
                    util.each(resHeaders, function(v, k) {
                      var metaPrefix = "x-cos-meta-";
                      if (k.indexOf(metaPrefix) === 0 && k.length > metaPrefix.length) {
                        SourceHeaders[k] = v;
                      }
                    });
                    ep.emit("get_file_size_finish");
                  }
                });
              }
              function copySliceItem(params, callback) {
                var TaskId = params.TaskId;
                var Bucket = params.Bucket;
                var Region = params.Region;
                var Key = params.Key;
                var CopySource = params.CopySource;
                var UploadId = params.UploadId;
                var PartNumber = params.PartNumber * 1;
                var CopySourceRange = params.CopySourceRange;
                var ChunkRetryTimes = this.options.ChunkRetryTimes + 1;
                var self2 = this;
                Async.retry(ChunkRetryTimes, function(tryCallback) {
                  self2.uploadPartCopy({
                    TaskId,
                    Bucket,
                    Region,
                    Key,
                    CopySource,
                    UploadId,
                    PartNumber,
                    CopySourceRange
                  }, function(err, data) {
                    tryCallback(err || null, data);
                  });
                }, function(err, data) {
                  return callback(err, data);
                });
              }
              var API_MAP = {
                sliceUploadFile,
                abortUploadTask,
                uploadFile,
                uploadFiles,
                sliceCopyFile
              };
              module2.exports.init = function(COS, task) {
                task.transferToTaskMethod(API_MAP, "sliceUploadFile");
                util.each(API_MAP, function(fn, apiName) {
                  COS.prototype[apiName] = util.apiWrapper(apiName, fn);
                });
              };
            }
          ),
          /***/
          "./src/async.js": (
            /*!**********************!*\
              !*** ./src/async.js ***!
              \**********************/
            /*! no static exports found */
            /***/
            function(module2, exports2) {
              var eachLimit = function eachLimit2(arr, limit, iterator, callback) {
                callback = callback || function() {
                };
                if (!arr.length || limit <= 0) {
                  return callback();
                }
                var completed = 0;
                var started = 0;
                var running = 0;
                (function replenish() {
                  if (completed >= arr.length) {
                    return callback();
                  }
                  while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function(err) {
                      if (err) {
                        callback(err);
                        callback = function callback2() {
                        };
                      } else {
                        completed += 1;
                        running -= 1;
                        if (completed >= arr.length) {
                          callback();
                        } else {
                          replenish();
                        }
                      }
                    });
                  }
                })();
              };
              var retry = function retry2(times, iterator, callback) {
                var next = function next2(index) {
                  iterator(function(err, data) {
                    if (err && index < times) {
                      next2(index + 1);
                    } else {
                      callback(err, data);
                    }
                  });
                };
                if (times < 1) {
                  callback();
                } else {
                  next(1);
                }
              };
              var async = {
                eachLimit,
                retry
              };
              module2.exports = async;
            }
          ),
          /***/
          "./src/base.js": (
            /*!*********************!*\
              !*** ./src/base.js ***!
              \*********************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var _typeof2 = __webpack_require__2(
                /*! @babel/runtime/helpers/typeof */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              );
              var REQUEST = __webpack_require__2(
                /*! ../lib/request */
                "./lib/request.js"
              );
              var util = __webpack_require__2(
                /*! ./util */
                "./src/util.js"
              );
              function getService(params, callback) {
                if (typeof params === "function") {
                  callback = params;
                  params = {};
                }
                var protocol = this.options.Protocol || (util.isBrowser && (typeof location === "undefined" ? "undefined" : _typeof2(location)) === "object" && location.protocol === "http:" ? "http:" : "https:");
                var domain = this.options.ServiceDomain;
                var appId = params.AppId || this.options.appId;
                var region = params.Region;
                if (domain) {
                  domain = domain.replace(/\{\{AppId\}\}/gi, appId || "").replace(/\{\{Region\}\}/gi, region || "").replace(/\{\{.*?\}\}/gi, "");
                  if (!/^[a-zA-Z]+:\/\//.test(domain)) {
                    domain = protocol + "//" + domain;
                  }
                  if (domain.slice(-1) === "/") {
                    domain = domain.slice(0, -1);
                  }
                } else if (region) {
                  domain = protocol + "//cos." + region + ".myqcloud.com";
                } else {
                  domain = protocol + "//service.cos.myqcloud.com";
                }
                var SignHost = "";
                var standardHost = region ? "cos." + region + ".myqcloud.com" : "service.cos.myqcloud.com";
                var urlHost = domain.replace(/^https?:\/\/([^/]+)(\/.*)?$/, "$1");
                if (standardHost === urlHost)
                  SignHost = standardHost;
                submitRequest.call(this, {
                  Action: "name/cos:GetService",
                  url: domain,
                  method: "GET",
                  headers: params.Headers,
                  SignHost
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var buckets = data && data.ListAllMyBucketsResult && data.ListAllMyBucketsResult.Buckets && data.ListAllMyBucketsResult.Buckets.Bucket || [];
                  buckets = util.isArray(buckets) ? buckets : [buckets];
                  var owner = data && data.ListAllMyBucketsResult && data.ListAllMyBucketsResult.Owner || {};
                  callback(null, {
                    Buckets: buckets,
                    Owner: owner,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putBucket(params, callback) {
                var self2 = this;
                var xml = "";
                if (params["BucketAZConfig"]) {
                  var CreateBucketConfiguration = {
                    BucketAZConfig: params.BucketAZConfig
                  };
                  xml = util.json2xml({
                    CreateBucketConfiguration
                  });
                }
                submitRequest.call(this, {
                  Action: "name/cos:PutBucket",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  body: xml
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var url = getUrl({
                    protocol: self2.options.Protocol,
                    domain: self2.options.Domain,
                    bucket: params.Bucket,
                    region: params.Region,
                    isLocation: true
                  });
                  callback(null, {
                    Location: url,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function headBucket(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:HeadBucket",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  method: "HEAD"
                }, callback);
              }
              function getBucket(params, callback) {
                var reqParams = {};
                reqParams["prefix"] = params["Prefix"] || "";
                reqParams["delimiter"] = params["Delimiter"];
                reqParams["marker"] = params["Marker"];
                reqParams["max-keys"] = params["MaxKeys"];
                reqParams["encoding-type"] = params["EncodingType"];
                submitRequest.call(this, {
                  Action: "name/cos:GetBucket",
                  ResourceKey: reqParams["prefix"],
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  qs: reqParams
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var ListBucketResult = data.ListBucketResult || {};
                  var Contents = ListBucketResult.Contents || [];
                  var CommonPrefixes = ListBucketResult.CommonPrefixes || [];
                  Contents = util.isArray(Contents) ? Contents : [Contents];
                  CommonPrefixes = util.isArray(CommonPrefixes) ? CommonPrefixes : [CommonPrefixes];
                  var result = util.clone(ListBucketResult);
                  util.extend(result, {
                    Contents,
                    CommonPrefixes,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                  callback(null, result);
                });
              }
              function deleteBucket(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteBucket",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  method: "DELETE"
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putBucketAcl(params, callback) {
                var headers = params.Headers;
                var xml = "";
                if (params["AccessControlPolicy"]) {
                  var AccessControlPolicy = util.clone(params["AccessControlPolicy"] || {});
                  var Grants = AccessControlPolicy.Grants || AccessControlPolicy.Grant;
                  Grants = util.isArray(Grants) ? Grants : [Grants];
                  delete AccessControlPolicy.Grant;
                  delete AccessControlPolicy.Grants;
                  AccessControlPolicy.AccessControlList = {
                    Grant: Grants
                  };
                  xml = util.json2xml({
                    AccessControlPolicy
                  });
                  headers["Content-Type"] = "application/xml";
                  headers["Content-MD5"] = util.b64(util.md5(xml));
                }
                util.each(headers, function(val, key) {
                  if (key.indexOf("x-cos-grant-") === 0) {
                    headers[key] = uniqGrant(headers[key]);
                  }
                });
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketACL",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers,
                  action: "acl",
                  body: xml
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketAcl(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketACL",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "acl"
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var AccessControlPolicy = data.AccessControlPolicy || {};
                  var Owner = AccessControlPolicy.Owner || {};
                  var Grant = AccessControlPolicy.AccessControlList.Grant || [];
                  Grant = util.isArray(Grant) ? Grant : [Grant];
                  var result = decodeAcl(AccessControlPolicy);
                  if (data.headers && data.headers["x-cos-acl"]) {
                    result.ACL = data.headers["x-cos-acl"];
                  }
                  result = util.extend(result, {
                    Owner,
                    Grants: Grant,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                  callback(null, result);
                });
              }
              function putBucketCors(params, callback) {
                var CORSConfiguration = params["CORSConfiguration"] || {};
                var CORSRules = CORSConfiguration["CORSRules"] || params["CORSRules"] || [];
                CORSRules = util.clone(util.isArray(CORSRules) ? CORSRules : [CORSRules]);
                util.each(CORSRules, function(rule) {
                  util.each(["AllowedOrigin", "AllowedHeader", "AllowedMethod", "ExposeHeader"], function(key) {
                    var sKey = key + "s";
                    var val = rule[sKey] || rule[key] || [];
                    delete rule[sKey];
                    rule[key] = util.isArray(val) ? val : [val];
                  });
                });
                var Conf = {
                  CORSRule: CORSRules
                };
                if (params.ResponseVary)
                  Conf.ResponseVary = params.ResponseVary;
                var xml = util.json2xml({
                  CORSConfiguration: Conf
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketCORS",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "cors",
                  headers
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketCors(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketCORS",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "cors"
                }, function(err, data) {
                  if (err) {
                    if (err.statusCode === 404 && err.error && err.error.Code === "NoSuchCORSConfiguration") {
                      var result = {
                        CORSRules: [],
                        statusCode: err.statusCode
                      };
                      err.headers && (result.headers = err.headers);
                      callback(null, result);
                    } else {
                      callback(err);
                    }
                    return;
                  }
                  var CORSConfiguration = data.CORSConfiguration || {};
                  var CORSRules = CORSConfiguration.CORSRules || CORSConfiguration.CORSRule || [];
                  CORSRules = util.clone(util.isArray(CORSRules) ? CORSRules : [CORSRules]);
                  var ResponseVary = CORSConfiguration.ResponseVary;
                  util.each(CORSRules, function(rule) {
                    util.each(["AllowedOrigin", "AllowedHeader", "AllowedMethod", "ExposeHeader"], function(key) {
                      var sKey = key + "s";
                      var val = rule[sKey] || rule[key] || [];
                      delete rule[key];
                      rule[sKey] = util.isArray(val) ? val : [val];
                    });
                  });
                  callback(null, {
                    CORSRules,
                    ResponseVary,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function deleteBucketCors(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteBucketCORS",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "cors"
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode || err.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketLocation(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketLocation",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "location"
                }, callback);
              }
              function putBucketPolicy(params, callback) {
                var Policy = params["Policy"];
                try {
                  if (typeof Policy === "string")
                    Policy = JSON.parse(Policy);
                } catch (e) {
                }
                if (!Policy || typeof Policy === "string")
                  return callback(util.error(new Error("Policy format error")));
                var PolicyStr = JSON.stringify(Policy);
                if (!Policy.version)
                  Policy.version = "2.0";
                var headers = params.Headers;
                headers["Content-Type"] = "application/json";
                headers["Content-MD5"] = util.b64(util.md5(PolicyStr));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketPolicy",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  action: "policy",
                  body: PolicyStr,
                  headers
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketPolicy(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketPolicy",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "policy",
                  rawBody: true
                }, function(err, data) {
                  if (err) {
                    if (err.statusCode && err.statusCode === 403) {
                      return callback(util.error(err, {
                        ErrorStatus: "Access Denied"
                      }));
                    }
                    if (err.statusCode && err.statusCode === 405) {
                      return callback(util.error(err, {
                        ErrorStatus: "Method Not Allowed"
                      }));
                    }
                    if (err.statusCode && err.statusCode === 404) {
                      return callback(util.error(err, {
                        ErrorStatus: "Policy Not Found"
                      }));
                    }
                    return callback(err);
                  }
                  var Policy = {};
                  try {
                    Policy = JSON.parse(data.body);
                  } catch (e) {
                  }
                  callback(null, {
                    Policy,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function deleteBucketPolicy(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteBucketPolicy",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "policy"
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode || err.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putBucketTagging(params, callback) {
                var Tagging = params["Tagging"] || {};
                var Tags = Tagging.TagSet || Tagging.Tags || params["Tags"] || [];
                Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
                var xml = util.json2xml({
                  Tagging: {
                    TagSet: {
                      Tag: Tags
                    }
                  }
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketTagging",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "tagging",
                  headers
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketTagging(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketTagging",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "tagging"
                }, function(err, data) {
                  if (err) {
                    if (err.statusCode === 404 && err.error && (err.error === "Not Found" || err.error.Code === "NoSuchTagSet")) {
                      var result = {
                        Tags: [],
                        statusCode: err.statusCode
                      };
                      err.headers && (result.headers = err.headers);
                      callback(null, result);
                    } else {
                      callback(err);
                    }
                    return;
                  }
                  var Tags = [];
                  try {
                    Tags = data.Tagging.TagSet.Tag || [];
                  } catch (e) {
                  }
                  Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
                  callback(null, {
                    Tags,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function deleteBucketTagging(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteBucketTagging",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "tagging"
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putBucketLifecycle(params, callback) {
                var LifecycleConfiguration = params["LifecycleConfiguration"] || {};
                var Rules = LifecycleConfiguration.Rules || params.Rules || [];
                Rules = util.clone(Rules);
                var xml = util.json2xml({
                  LifecycleConfiguration: {
                    Rule: Rules
                  }
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketLifecycle",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "lifecycle",
                  headers
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketLifecycle(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketLifecycle",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "lifecycle"
                }, function(err, data) {
                  if (err) {
                    if (err.statusCode === 404 && err.error && err.error.Code === "NoSuchLifecycleConfiguration") {
                      var result = {
                        Rules: [],
                        statusCode: err.statusCode
                      };
                      err.headers && (result.headers = err.headers);
                      callback(null, result);
                    } else {
                      callback(err);
                    }
                    return;
                  }
                  var Rules = [];
                  try {
                    Rules = data.LifecycleConfiguration.Rule || [];
                  } catch (e) {
                  }
                  Rules = util.clone(util.isArray(Rules) ? Rules : [Rules]);
                  callback(null, {
                    Rules,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function deleteBucketLifecycle(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteBucketLifecycle",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "lifecycle"
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putBucketVersioning(params, callback) {
                if (!params["VersioningConfiguration"]) {
                  callback(util.error(new Error("missing param VersioningConfiguration")));
                  return;
                }
                var VersioningConfiguration = params["VersioningConfiguration"] || {};
                var xml = util.json2xml({
                  VersioningConfiguration
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketVersioning",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "versioning",
                  headers
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketVersioning(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketVersioning",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "versioning"
                }, function(err, data) {
                  if (!err) {
                    !data.VersioningConfiguration && (data.VersioningConfiguration = {});
                  }
                  callback(err, data);
                });
              }
              function putBucketReplication(params, callback) {
                var ReplicationConfiguration = util.clone(params.ReplicationConfiguration);
                var xml = util.json2xml({
                  ReplicationConfiguration
                });
                xml = xml.replace(/<(\/?)Rules>/gi, "<$1Rule>");
                xml = xml.replace(/<(\/?)Tags>/gi, "<$1Tag>");
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketReplication",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "replication",
                  headers
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketReplication(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketReplication",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "replication"
                }, function(err, data) {
                  if (err) {
                    if (err.statusCode === 404 && err.error && (err.error === "Not Found" || err.error.Code === "ReplicationConfigurationnotFoundError")) {
                      var result = {
                        ReplicationConfiguration: {
                          Rules: []
                        },
                        statusCode: err.statusCode
                      };
                      err.headers && (result.headers = err.headers);
                      callback(null, result);
                    } else {
                      callback(err);
                    }
                    return;
                  }
                  !data.ReplicationConfiguration && (data.ReplicationConfiguration = {});
                  if (data.ReplicationConfiguration.Rule) {
                    data.ReplicationConfiguration.Rules = util.makeArray(data.ReplicationConfiguration.Rule);
                    delete data.ReplicationConfiguration.Rule;
                  }
                  callback(err, data);
                });
              }
              function deleteBucketReplication(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteBucketReplication",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "replication"
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putBucketWebsite(params, callback) {
                if (!params["WebsiteConfiguration"]) {
                  callback(util.error(new Error("missing param WebsiteConfiguration")));
                  return;
                }
                var WebsiteConfiguration = util.clone(params["WebsiteConfiguration"] || {});
                var RoutingRules = WebsiteConfiguration["RoutingRules"] || WebsiteConfiguration["RoutingRule"] || [];
                RoutingRules = util.isArray(RoutingRules) ? RoutingRules : [RoutingRules];
                delete WebsiteConfiguration.RoutingRule;
                delete WebsiteConfiguration.RoutingRules;
                if (RoutingRules.length)
                  WebsiteConfiguration.RoutingRules = {
                    RoutingRule: RoutingRules
                  };
                var xml = util.json2xml({
                  WebsiteConfiguration
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketWebsite",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "website",
                  headers
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketWebsite(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketWebsite",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  headers: params.Headers,
                  action: "website"
                }, function(err, data) {
                  if (err) {
                    if (err.statusCode === 404 && err.error.Code === "NoSuchWebsiteConfiguration") {
                      var result = {
                        WebsiteConfiguration: {},
                        statusCode: err.statusCode
                      };
                      err.headers && (result.headers = err.headers);
                      callback(null, result);
                    } else {
                      callback(err);
                    }
                    return;
                  }
                  var WebsiteConfiguration = data.WebsiteConfiguration || {};
                  if (WebsiteConfiguration["RoutingRules"]) {
                    var RoutingRules = util.clone(WebsiteConfiguration["RoutingRules"].RoutingRule || []);
                    RoutingRules = util.makeArray(RoutingRules);
                    WebsiteConfiguration.RoutingRules = RoutingRules;
                  }
                  callback(null, {
                    WebsiteConfiguration,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function deleteBucketWebsite(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteBucketWebsite",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "website"
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putBucketReferer(params, callback) {
                if (!params["RefererConfiguration"]) {
                  callback(util.error(new Error("missing param RefererConfiguration")));
                  return;
                }
                var RefererConfiguration = util.clone(params["RefererConfiguration"] || {});
                var DomainList = RefererConfiguration["DomainList"] || {};
                var Domains = DomainList["Domains"] || DomainList["Domain"] || [];
                Domains = util.isArray(Domains) ? Domains : [Domains];
                if (Domains.length)
                  RefererConfiguration.DomainList = {
                    Domain: Domains
                  };
                var xml = util.json2xml({
                  RefererConfiguration
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketReferer",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "referer",
                  headers
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketReferer(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketReferer",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  headers: params.Headers,
                  action: "referer"
                }, function(err, data) {
                  if (err) {
                    if (err.statusCode === 404 && err.error.Code === "NoSuchRefererConfiguration") {
                      var result = {
                        WebsiteConfiguration: {},
                        statusCode: err.statusCode
                      };
                      err.headers && (result.headers = err.headers);
                      callback(null, result);
                    } else {
                      callback(err);
                    }
                    return;
                  }
                  var RefererConfiguration = data.RefererConfiguration || {};
                  if (RefererConfiguration["DomainList"]) {
                    var Domains = util.makeArray(RefererConfiguration["DomainList"].Domain || []);
                    RefererConfiguration.DomainList = {
                      Domains
                    };
                  }
                  callback(null, {
                    RefererConfiguration,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putBucketDomain(params, callback) {
                var DomainConfiguration = params["DomainConfiguration"] || {};
                var DomainRule = DomainConfiguration.DomainRule || params.DomainRule || [];
                DomainRule = util.clone(DomainRule);
                var xml = util.json2xml({
                  DomainConfiguration: {
                    DomainRule
                  }
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketDomain",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "domain",
                  headers
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketDomain(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketDomain",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "domain"
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var DomainRule = [];
                  try {
                    DomainRule = data.DomainConfiguration.DomainRule || [];
                  } catch (e) {
                  }
                  DomainRule = util.clone(util.isArray(DomainRule) ? DomainRule : [DomainRule]);
                  callback(null, {
                    DomainRule,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function deleteBucketDomain(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteBucketDomain",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "domain"
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putBucketOrigin(params, callback) {
                var OriginConfiguration = params["OriginConfiguration"] || {};
                var OriginRule = OriginConfiguration.OriginRule || params.OriginRule || [];
                OriginRule = util.clone(OriginRule);
                var xml = util.json2xml({
                  OriginConfiguration: {
                    OriginRule
                  }
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketOrigin",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "origin",
                  headers
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketOrigin(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketOrigin",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "origin"
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var OriginRule = [];
                  try {
                    OriginRule = data.OriginConfiguration.OriginRule || [];
                  } catch (e) {
                  }
                  OriginRule = util.clone(util.isArray(OriginRule) ? OriginRule : [OriginRule]);
                  callback(null, {
                    OriginRule,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function deleteBucketOrigin(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteBucketOrigin",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "origin"
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putBucketLogging(params, callback) {
                var xml = util.json2xml({
                  BucketLoggingStatus: params["BucketLoggingStatus"] || ""
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketLogging",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "logging",
                  headers
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketLogging(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketLogging",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "logging"
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  callback(null, {
                    BucketLoggingStatus: data.BucketLoggingStatus,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function submitBucketInventory(method2, params, callback) {
                var InventoryConfiguration = util.clone(params["InventoryConfiguration"]);
                if (InventoryConfiguration.OptionalFields) {
                  var Field = InventoryConfiguration.OptionalFields || [];
                  InventoryConfiguration.OptionalFields = {
                    Field
                  };
                }
                if (InventoryConfiguration.Destination && InventoryConfiguration.Destination.COSBucketDestination && InventoryConfiguration.Destination.COSBucketDestination.Encryption) {
                  var Encryption = InventoryConfiguration.Destination.COSBucketDestination.Encryption;
                  if (Object.keys(Encryption).indexOf("SSECOS") > -1) {
                    Encryption["SSE-COS"] = Encryption["SSECOS"];
                    delete Encryption["SSECOS"];
                  }
                }
                var xml = util.json2xml({
                  InventoryConfiguration
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                var action = method2 === "PUT" ? "name/cos:PutBucketInventory" : "name/cos:PostBucketInventory";
                submitRequest.call(this, {
                  Action: action,
                  method: method2,
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "inventory",
                  qs: {
                    id: params["Id"]
                  },
                  headers
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putBucketInventory(params, callback) {
                return submitBucketInventory.call(this, "PUT", params, callback);
              }
              function postBucketInventory(params, callback) {
                return submitBucketInventory.call(this, "POST", params, callback);
              }
              function getBucketInventory(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketInventory",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "inventory",
                  qs: {
                    id: params["Id"]
                  }
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var InventoryConfiguration = data["InventoryConfiguration"];
                  if (InventoryConfiguration && InventoryConfiguration.OptionalFields && InventoryConfiguration.OptionalFields.Field) {
                    var Field = InventoryConfiguration.OptionalFields.Field;
                    if (!util.isArray(Field)) {
                      Field = [Field];
                    }
                    InventoryConfiguration.OptionalFields = Field;
                  }
                  if (InventoryConfiguration.Destination && InventoryConfiguration.Destination.COSBucketDestination && InventoryConfiguration.Destination.COSBucketDestination.Encryption) {
                    var Encryption = InventoryConfiguration.Destination.COSBucketDestination.Encryption;
                    if (Object.keys(Encryption).indexOf("SSE-COS") > -1) {
                      Encryption["SSECOS"] = Encryption["SSE-COS"];
                      delete Encryption["SSE-COS"];
                    }
                  }
                  callback(null, {
                    InventoryConfiguration,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function listBucketInventory(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:ListBucketInventory",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "inventory",
                  qs: {
                    "continuation-token": params["ContinuationToken"]
                  }
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var ListInventoryConfigurationResult = data["ListInventoryConfigurationResult"];
                  var InventoryConfigurations = ListInventoryConfigurationResult.InventoryConfiguration || [];
                  InventoryConfigurations = util.isArray(InventoryConfigurations) ? InventoryConfigurations : [InventoryConfigurations];
                  delete ListInventoryConfigurationResult["InventoryConfiguration"];
                  util.each(InventoryConfigurations, function(InventoryConfiguration) {
                    if (InventoryConfiguration && InventoryConfiguration.OptionalFields && InventoryConfiguration.OptionalFields.Field) {
                      var Field = InventoryConfiguration.OptionalFields.Field;
                      if (!util.isArray(Field)) {
                        Field = [Field];
                      }
                      InventoryConfiguration.OptionalFields = Field;
                    }
                    if (InventoryConfiguration.Destination && InventoryConfiguration.Destination.COSBucketDestination && InventoryConfiguration.Destination.COSBucketDestination.Encryption) {
                      var Encryption = InventoryConfiguration.Destination.COSBucketDestination.Encryption;
                      if (Object.keys(Encryption).indexOf("SSE-COS") > -1) {
                        Encryption["SSECOS"] = Encryption["SSE-COS"];
                        delete Encryption["SSE-COS"];
                      }
                    }
                  });
                  ListInventoryConfigurationResult.InventoryConfigurations = InventoryConfigurations;
                  util.extend(ListInventoryConfigurationResult, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                  callback(null, ListInventoryConfigurationResult);
                });
              }
              function deleteBucketInventory(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteBucketInventory",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "inventory",
                  qs: {
                    id: params["Id"]
                  }
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putBucketAccelerate(params, callback) {
                if (!params["AccelerateConfiguration"]) {
                  callback(util.error(new Error("missing param AccelerateConfiguration")));
                  return;
                }
                var configuration = {
                  AccelerateConfiguration: params.AccelerateConfiguration || {}
                };
                var xml = util.json2xml(configuration);
                var headers = {};
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketAccelerate",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "accelerate",
                  headers
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketAccelerate(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketAccelerate",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  action: "accelerate"
                }, function(err, data) {
                  if (!err) {
                    !data.AccelerateConfiguration && (data.AccelerateConfiguration = {});
                  }
                  callback(err, data);
                });
              }
              function putBucketEncryption(params, callback) {
                var conf = params.ServerSideEncryptionConfiguration || {};
                var Rules = conf.Rule || conf.Rules || [];
                var xml = util.json2xml({
                  ServerSideEncryptionConfiguration: {
                    Rule: Rules
                  }
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutBucketEncryption",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "encryption",
                  headers
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getBucketEncryption(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketEncryption",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "encryption"
                }, function(err, data) {
                  if (err) {
                    if (err.statusCode === 404 && err.code === "NoSuchEncryptionConfiguration") {
                      var result = {
                        EncryptionConfiguration: {
                          Rules: []
                        },
                        statusCode: err.statusCode
                      };
                      err.headers && (result.headers = err.headers);
                      callback(null, result);
                    } else {
                      callback(err);
                    }
                    return;
                  }
                  var Rules = util.makeArray(data.EncryptionConfiguration && data.EncryptionConfiguration.Rule || []);
                  data.EncryptionConfiguration = {
                    Rules
                  };
                  callback(err, data);
                });
              }
              function deleteBucketEncryption(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteBucketReplication",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "encryption"
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function headObject(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:HeadObject",
                  method: "HEAD",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  VersionId: params.VersionId,
                  headers: params.Headers
                }, function(err, data) {
                  if (err) {
                    var statusCode = err.statusCode;
                    if (params.Headers["If-Modified-Since"] && statusCode && statusCode === 304) {
                      return callback(null, {
                        NotModified: true,
                        statusCode
                      });
                    }
                    return callback(err);
                  }
                  data.ETag = util.attr(data.headers, "etag", "");
                  callback(null, data);
                });
              }
              function listObjectVersions(params, callback) {
                var reqParams = {};
                reqParams["prefix"] = params["Prefix"] || "";
                reqParams["delimiter"] = params["Delimiter"];
                reqParams["key-marker"] = params["KeyMarker"];
                reqParams["version-id-marker"] = params["VersionIdMarker"];
                reqParams["max-keys"] = params["MaxKeys"];
                reqParams["encoding-type"] = params["EncodingType"];
                submitRequest.call(this, {
                  Action: "name/cos:GetBucketObjectVersions",
                  ResourceKey: reqParams["prefix"],
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  qs: reqParams,
                  action: "versions"
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var ListVersionsResult = data.ListVersionsResult || {};
                  var DeleteMarkers = ListVersionsResult.DeleteMarker || [];
                  DeleteMarkers = util.isArray(DeleteMarkers) ? DeleteMarkers : [DeleteMarkers];
                  var Versions = ListVersionsResult.Version || [];
                  Versions = util.isArray(Versions) ? Versions : [Versions];
                  var result = util.clone(ListVersionsResult);
                  delete result.DeleteMarker;
                  delete result.Version;
                  util.extend(result, {
                    DeleteMarkers,
                    Versions,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                  callback(null, result);
                });
              }
              function getObject(params, callback) {
                var reqParams = params.Query || {};
                var reqParamsStr = params.QueryString || "";
                var onProgress = util.throttleOnProgress.call(this, 0, params.onProgress);
                var tracker = params.tracker;
                tracker && tracker.setParams({
                  signStartTime: (/* @__PURE__ */ new Date()).getTime()
                });
                reqParams["response-content-type"] = params["ResponseContentType"];
                reqParams["response-content-language"] = params["ResponseContentLanguage"];
                reqParams["response-expires"] = params["ResponseExpires"];
                reqParams["response-cache-control"] = params["ResponseCacheControl"];
                reqParams["response-content-disposition"] = params["ResponseContentDisposition"];
                reqParams["response-content-encoding"] = params["ResponseContentEncoding"];
                submitRequest.call(this, {
                  Action: "name/cos:GetObject",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  VersionId: params.VersionId,
                  DataType: params.DataType,
                  headers: params.Headers,
                  qs: reqParams,
                  qsStr: reqParamsStr,
                  rawBody: true,
                  onDownloadProgress: onProgress,
                  tracker
                }, function(err, data) {
                  onProgress(null, true);
                  if (err) {
                    var statusCode = err.statusCode;
                    if (params.Headers["If-Modified-Since"] && statusCode && statusCode === 304) {
                      return callback(null, {
                        NotModified: true
                      });
                    }
                    return callback(err);
                  }
                  callback(null, {
                    Body: data.body,
                    ETag: util.attr(data.headers, "etag", ""),
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putObject(params, callback) {
                var self2 = this;
                var FileSize = params.ContentLength;
                var onProgress = util.throttleOnProgress.call(self2, FileSize, params.onProgress);
                var headers = params.Headers;
                if (!headers["Cache-Control"] && !headers["cache-control"])
                  headers["Cache-Control"] = "";
                if (!headers["Content-Type"] && !headers["content-type"])
                  headers["Content-Type"] = params.Body && params.Body.type || "";
                var needCalcMd5 = params.UploadAddMetaMd5 || self2.options.UploadAddMetaMd5 || self2.options.UploadCheckContentMd5;
                var tracker = params.tracker;
                needCalcMd5 && tracker && tracker.setParams({
                  md5StartTime: (/* @__PURE__ */ new Date()).getTime()
                });
                util.getBodyMd5(needCalcMd5, params.Body, function(md5) {
                  if (md5) {
                    tracker && tracker.setParams({
                      md5EndTime: (/* @__PURE__ */ new Date()).getTime()
                    });
                    if (self2.options.UploadCheckContentMd5)
                      headers["Content-MD5"] = util.b64(md5);
                    if (params.UploadAddMetaMd5 || self2.options.UploadAddMetaMd5)
                      headers["x-cos-meta-md5"] = md5;
                  }
                  if (params.ContentLength !== void 0)
                    headers["Content-Length"] = params.ContentLength;
                  onProgress(null, true);
                  submitRequest.call(self2, {
                    Action: "name/cos:PutObject",
                    TaskId: params.TaskId,
                    method: "PUT",
                    Bucket: params.Bucket,
                    Region: params.Region,
                    Key: params.Key,
                    headers: params.Headers,
                    qs: params.Query,
                    body: params.Body,
                    onProgress,
                    tracker
                  }, function(err, data) {
                    if (err) {
                      onProgress(null, true);
                      return callback(err);
                    }
                    onProgress({
                      loaded: FileSize,
                      total: FileSize
                    }, true);
                    var url = getUrl({
                      ForcePathStyle: self2.options.ForcePathStyle,
                      protocol: self2.options.Protocol,
                      domain: self2.options.Domain,
                      bucket: params.Bucket,
                      region: !self2.options.UseAccelerate ? params.Region : "accelerate",
                      object: params.Key
                    });
                    url = url.substr(url.indexOf("://") + 3);
                    data.Location = url;
                    data.ETag = util.attr(data.headers, "etag", "");
                    callback(null, data);
                  });
                }, params.onHashProgress);
              }
              function deleteObject(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteObject",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  headers: params.Headers,
                  VersionId: params.VersionId,
                  action: params.Recursive ? "recursive" : ""
                }, function(err, data) {
                  if (err) {
                    var statusCode = err.statusCode;
                    if (statusCode && statusCode === 404) {
                      return callback(null, {
                        BucketNotFound: true,
                        statusCode
                      });
                    } else {
                      return callback(err);
                    }
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getObjectAcl(params, callback) {
                var reqParams = {};
                if (params.VersionId) {
                  reqParams.versionId = params.VersionId;
                }
                submitRequest.call(this, {
                  Action: "name/cos:GetObjectACL",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  headers: params.Headers,
                  qs: reqParams,
                  action: "acl"
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var AccessControlPolicy = data.AccessControlPolicy || {};
                  var Owner = AccessControlPolicy.Owner || {};
                  var Grant = AccessControlPolicy.AccessControlList && AccessControlPolicy.AccessControlList.Grant || [];
                  Grant = util.isArray(Grant) ? Grant : [Grant];
                  var result = decodeAcl(AccessControlPolicy);
                  delete result.GrantWrite;
                  if (data.headers && data.headers["x-cos-acl"]) {
                    result.ACL = data.headers["x-cos-acl"];
                  }
                  result = util.extend(result, {
                    Owner,
                    Grants: Grant,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                  callback(null, result);
                });
              }
              function putObjectAcl(params, callback) {
                var headers = params.Headers;
                var xml = "";
                if (params["AccessControlPolicy"]) {
                  var AccessControlPolicy = util.clone(params["AccessControlPolicy"] || {});
                  var Grants = AccessControlPolicy.Grants || AccessControlPolicy.Grant;
                  Grants = util.isArray(Grants) ? Grants : [Grants];
                  delete AccessControlPolicy.Grant;
                  delete AccessControlPolicy.Grants;
                  AccessControlPolicy.AccessControlList = {
                    Grant: Grants
                  };
                  xml = util.json2xml({
                    AccessControlPolicy
                  });
                  headers["Content-Type"] = "application/xml";
                  headers["Content-MD5"] = util.b64(util.md5(xml));
                }
                util.each(headers, function(val, key) {
                  if (key.indexOf("x-cos-grant-") === 0) {
                    headers[key] = uniqGrant(headers[key]);
                  }
                });
                submitRequest.call(this, {
                  Action: "name/cos:PutObjectACL",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  action: "acl",
                  headers,
                  body: xml
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function optionsObject(params, callback) {
                var headers = params.Headers;
                headers["Origin"] = params["Origin"];
                headers["Access-Control-Request-Method"] = params["AccessControlRequestMethod"];
                headers["Access-Control-Request-Headers"] = params["AccessControlRequestHeaders"];
                submitRequest.call(this, {
                  Action: "name/cos:OptionsObject",
                  method: "OPTIONS",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  headers
                }, function(err, data) {
                  if (err) {
                    if (err.statusCode && err.statusCode === 403) {
                      return callback(null, {
                        OptionsForbidden: true,
                        statusCode: err.statusCode
                      });
                    }
                    return callback(err);
                  }
                  var headers2 = data.headers || {};
                  callback(null, {
                    AccessControlAllowOrigin: headers2["access-control-allow-origin"],
                    AccessControlAllowMethods: headers2["access-control-allow-methods"],
                    AccessControlAllowHeaders: headers2["access-control-allow-headers"],
                    AccessControlExposeHeaders: headers2["access-control-expose-headers"],
                    AccessControlMaxAge: headers2["access-control-max-age"],
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function putObjectCopy(params, callback) {
                var self2 = this;
                var headers = params.Headers;
                if (!headers["Cache-Control"] && !headers["cache-control"])
                  headers["Cache-Control"] = "";
                var CopySource = params.CopySource || "";
                var m = util.getSourceParams.call(this, CopySource);
                if (!m) {
                  callback(util.error(new Error("CopySource format error")));
                  return;
                }
                var SourceBucket = m.Bucket;
                var SourceRegion = m.Region;
                var SourceKey = decodeURIComponent(m.Key);
                submitRequest.call(this, {
                  Scope: [{
                    action: "name/cos:GetObject",
                    bucket: SourceBucket,
                    region: SourceRegion,
                    prefix: SourceKey
                  }, {
                    action: "name/cos:PutObject",
                    bucket: params.Bucket,
                    region: params.Region,
                    prefix: params.Key
                  }],
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  VersionId: params.VersionId,
                  headers: params.Headers
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var result = util.clone(data.CopyObjectResult || {});
                  var url = getUrl({
                    ForcePathStyle: self2.options.ForcePathStyle,
                    protocol: self2.options.Protocol,
                    domain: self2.options.Domain,
                    bucket: params.Bucket,
                    region: params.Region,
                    object: params.Key,
                    isLocation: true
                  });
                  util.extend(result, {
                    Location: url,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                  callback(null, result);
                });
              }
              function uploadPartCopy(params, callback) {
                var CopySource = params.CopySource || "";
                var m = util.getSourceParams.call(this, CopySource);
                if (!m) {
                  callback(util.error(new Error("CopySource format error")));
                  return;
                }
                var SourceBucket = m.Bucket;
                var SourceRegion = m.Region;
                var SourceKey = decodeURIComponent(m.Key);
                submitRequest.call(this, {
                  Scope: [{
                    action: "name/cos:GetObject",
                    bucket: SourceBucket,
                    region: SourceRegion,
                    prefix: SourceKey
                  }, {
                    action: "name/cos:PutObject",
                    bucket: params.Bucket,
                    region: params.Region,
                    prefix: params.Key
                  }],
                  method: "PUT",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  VersionId: params.VersionId,
                  qs: {
                    partNumber: params["PartNumber"],
                    uploadId: params["UploadId"]
                  },
                  headers: params.Headers
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var result = util.clone(data.CopyPartResult || {});
                  util.extend(result, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                  callback(null, result);
                });
              }
              function deleteMultipleObject(params, callback) {
                var Objects = params.Objects || [];
                var Quiet = params.Quiet;
                Objects = util.isArray(Objects) ? Objects : [Objects];
                var xml = util.json2xml({
                  Delete: {
                    Object: Objects,
                    Quiet: Quiet || false
                  }
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                var Scope = util.map(Objects, function(v) {
                  return {
                    action: "name/cos:DeleteObject",
                    bucket: params.Bucket,
                    region: params.Region,
                    prefix: v.Key
                  };
                });
                submitRequest.call(this, {
                  Scope,
                  method: "POST",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  body: xml,
                  action: "delete",
                  headers
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  var DeleteResult = data.DeleteResult || {};
                  var Deleted = DeleteResult.Deleted || [];
                  var Errors = DeleteResult.Error || [];
                  Deleted = util.isArray(Deleted) ? Deleted : [Deleted];
                  Errors = util.isArray(Errors) ? Errors : [Errors];
                  var result = util.clone(DeleteResult);
                  util.extend(result, {
                    Error: Errors,
                    Deleted,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                  callback(null, result);
                });
              }
              function restoreObject(params, callback) {
                var headers = params.Headers;
                if (!params["RestoreRequest"]) {
                  callback(util.error(new Error("missing param RestoreRequest")));
                  return;
                }
                var RestoreRequest = params.RestoreRequest || {};
                var xml = util.json2xml({
                  RestoreRequest
                });
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:RestoreObject",
                  method: "POST",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  VersionId: params.VersionId,
                  body: xml,
                  action: "restore",
                  headers
                }, callback);
              }
              function putObjectTagging(params, callback) {
                var Tagging = params["Tagging"] || {};
                var Tags = Tagging.TagSet || Tagging.Tags || params["Tags"] || [];
                Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
                var xml = util.json2xml({
                  Tagging: {
                    TagSet: {
                      Tag: Tags
                    }
                  }
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:PutObjectTagging",
                  method: "PUT",
                  Bucket: params.Bucket,
                  Key: params.Key,
                  Region: params.Region,
                  body: xml,
                  action: "tagging",
                  headers,
                  VersionId: params.VersionId
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function getObjectTagging(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:GetObjectTagging",
                  method: "GET",
                  Key: params.Key,
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  action: "tagging",
                  VersionId: params.VersionId
                }, function(err, data) {
                  if (err) {
                    if (err.statusCode === 404 && err.error && (err.error === "Not Found" || err.error.Code === "NoSuchTagSet")) {
                      var result = {
                        Tags: [],
                        statusCode: err.statusCode
                      };
                      err.headers && (result.headers = err.headers);
                      callback(null, result);
                    } else {
                      callback(err);
                    }
                    return;
                  }
                  var Tags = [];
                  try {
                    Tags = data.Tagging.TagSet.Tag || [];
                  } catch (e) {
                  }
                  Tags = util.clone(util.isArray(Tags) ? Tags : [Tags]);
                  callback(null, {
                    Tags,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function deleteObjectTagging(params, callback) {
                submitRequest.call(this, {
                  Action: "name/cos:DeleteObjectTagging",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  headers: params.Headers,
                  action: "tagging",
                  VersionId: params.VersionId
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function selectObjectContent(params, callback) {
                var SelectType = params["SelectType"];
                if (!SelectType)
                  return callback(util.error(new Error("missing param SelectType")));
                var SelectRequest = params["SelectRequest"] || {};
                var xml = util.json2xml({
                  SelectRequest
                });
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:GetObject",
                  method: "POST",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  headers: params.Headers,
                  action: "select",
                  qs: {
                    "select-type": params["SelectType"]
                  },
                  VersionId: params.VersionId,
                  body: xml,
                  DataType: "arraybuffer",
                  rawBody: true
                }, function(err, data) {
                  if (err && err.statusCode === 204) {
                    return callback(null, {
                      statusCode: err.statusCode
                    });
                  } else if (err) {
                    return callback(err);
                  }
                  var result = util.parseSelectPayload(data.body);
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers,
                    Body: result.body,
                    Payload: result.payload
                  });
                });
              }
              function multipartInit(params, callback) {
                var self2 = this;
                var headers = params.Headers;
                var tracker = params.tracker;
                if (!headers["Cache-Control"] && !headers["cache-control"])
                  headers["Cache-Control"] = "";
                if (!headers["Content-Type"] && !headers["content-type"])
                  headers["Content-Type"] = params.Body && params.Body.type || "";
                var needCalcMd5 = params.Body && (params.UploadAddMetaMd5 || self2.options.UploadAddMetaMd5);
                needCalcMd5 && tracker && tracker.setParams({
                  md5StartTime: (/* @__PURE__ */ new Date()).getTime()
                });
                util.getBodyMd5(needCalcMd5, params.Body, function(md5) {
                  if (md5)
                    params.Headers["x-cos-meta-md5"] = md5;
                  needCalcMd5 && tracker && tracker.setParams({
                    md5EndTime: (/* @__PURE__ */ new Date()).getTime()
                  });
                  submitRequest.call(self2, {
                    Action: "name/cos:InitiateMultipartUpload",
                    method: "POST",
                    Bucket: params.Bucket,
                    Region: params.Region,
                    Key: params.Key,
                    action: "uploads",
                    headers: params.Headers,
                    qs: params.Query,
                    tracker
                  }, function(err, data) {
                    if (err) {
                      tracker && tracker.parent && tracker.parent.setParams({
                        errorNode: "multipartInit"
                      });
                      return callback(err);
                    }
                    data = util.clone(data || {});
                    if (data && data.InitiateMultipartUploadResult) {
                      return callback(null, util.extend(data.InitiateMultipartUploadResult, {
                        statusCode: data.statusCode,
                        headers: data.headers
                      }));
                    }
                    callback(null, data);
                  });
                }, params.onHashProgress);
              }
              function multipartUpload(params, callback) {
                var self2 = this;
                util.getFileSize("multipartUpload", params, function() {
                  var tracker = params.tracker;
                  var needCalcMd5 = self2.options.UploadCheckContentMd5;
                  needCalcMd5 && tracker && tracker.setParams({
                    md5StartTime: (/* @__PURE__ */ new Date()).getTime()
                  });
                  util.getBodyMd5(needCalcMd5, params.Body, function(md5) {
                    if (md5)
                      params.Headers["Content-MD5"] = util.b64(md5);
                    needCalcMd5 && tracker && tracker.setParams({
                      md5EndTime: (/* @__PURE__ */ new Date()).getTime()
                    });
                    tracker && tracker.setParams({
                      partNumber: params.PartNumber
                    });
                    submitRequest.call(self2, {
                      Action: "name/cos:UploadPart",
                      TaskId: params.TaskId,
                      method: "PUT",
                      Bucket: params.Bucket,
                      Region: params.Region,
                      Key: params.Key,
                      qs: {
                        partNumber: params["PartNumber"],
                        uploadId: params["UploadId"]
                      },
                      headers: params.Headers,
                      onProgress: params.onProgress,
                      body: params.Body || null,
                      tracker
                    }, function(err, data) {
                      if (err) {
                        tracker && tracker.parent && tracker.parent.setParams({
                          errorNode: "multipartUpload"
                        });
                        return callback(err);
                      }
                      callback(null, {
                        ETag: util.attr(data.headers, "etag", ""),
                        statusCode: data.statusCode,
                        headers: data.headers
                      });
                    });
                  });
                });
              }
              function multipartComplete(params, callback) {
                var self2 = this;
                var UploadId = params.UploadId;
                var Parts = params["Parts"];
                var tracker = params.tracker;
                for (var i = 0, len = Parts.length; i < len; i++) {
                  if (Parts[i]["ETag"] && Parts[i]["ETag"].indexOf('"') === 0) {
                    continue;
                  }
                  Parts[i]["ETag"] = '"' + Parts[i]["ETag"] + '"';
                }
                var xml = util.json2xml({
                  CompleteMultipartUpload: {
                    Part: Parts
                  }
                });
                xml = xml.replace(/\n\s*/g, "");
                var headers = params.Headers;
                headers["Content-Type"] = "application/xml";
                headers["Content-MD5"] = util.b64(util.md5(xml));
                submitRequest.call(this, {
                  Action: "name/cos:CompleteMultipartUpload",
                  method: "POST",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  qs: {
                    uploadId: UploadId
                  },
                  body: xml,
                  headers,
                  tracker
                }, function(err, data) {
                  if (err) {
                    tracker && tracker.parent && tracker.parent.setParams({
                      errorNode: "multipartComplete"
                    });
                    return callback(err);
                  }
                  var url = getUrl({
                    ForcePathStyle: self2.options.ForcePathStyle,
                    protocol: self2.options.Protocol,
                    domain: self2.options.Domain,
                    bucket: params.Bucket,
                    region: params.Region,
                    object: params.Key,
                    isLocation: true
                  });
                  var res = data.CompleteMultipartUploadResult || {};
                  if (res.ProcessResults) {
                    if (res && res.ProcessResults) {
                      res.UploadResult = {
                        OriginalInfo: {
                          Key: res.Key,
                          Location: url,
                          ETag: res.ETag,
                          ImageInfo: res.ImageInfo
                        },
                        ProcessResults: res.ProcessResults
                      };
                      delete res.ImageInfo;
                      delete res.ProcessResults;
                    }
                  }
                  var result = util.extend(res, {
                    Location: url,
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                  callback(null, result);
                });
              }
              function multipartList(params, callback) {
                var reqParams = {};
                reqParams["delimiter"] = params["Delimiter"];
                reqParams["encoding-type"] = params["EncodingType"];
                reqParams["prefix"] = params["Prefix"] || "";
                reqParams["max-uploads"] = params["MaxUploads"];
                reqParams["key-marker"] = params["KeyMarker"];
                reqParams["upload-id-marker"] = params["UploadIdMarker"];
                reqParams = util.clearKey(reqParams);
                var tracker = params.tracker;
                tracker && tracker.setParams({
                  signStartTime: (/* @__PURE__ */ new Date()).getTime()
                });
                submitRequest.call(this, {
                  Action: "name/cos:ListMultipartUploads",
                  ResourceKey: reqParams["prefix"],
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  headers: params.Headers,
                  qs: reqParams,
                  action: "uploads",
                  tracker
                }, function(err, data) {
                  if (err) {
                    tracker && tracker.parent && tracker.parent.setParams({
                      errorNode: "multipartList"
                    });
                    return callback(err);
                  }
                  if (data && data.ListMultipartUploadsResult) {
                    var Upload = data.ListMultipartUploadsResult.Upload || [];
                    Upload = util.isArray(Upload) ? Upload : [Upload];
                    data.ListMultipartUploadsResult.Upload = Upload;
                  }
                  var result = util.clone(data.ListMultipartUploadsResult || {});
                  util.extend(result, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                  callback(null, result);
                });
              }
              function multipartListPart(params, callback) {
                var reqParams = {};
                var tracker = params.tracker;
                reqParams["uploadId"] = params["UploadId"];
                reqParams["encoding-type"] = params["EncodingType"];
                reqParams["max-parts"] = params["MaxParts"];
                reqParams["part-number-marker"] = params["PartNumberMarker"];
                submitRequest.call(this, {
                  Action: "name/cos:ListParts",
                  method: "GET",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  headers: params.Headers,
                  qs: reqParams
                }, function(err, data) {
                  if (err) {
                    tracker && tracker.parent && tracker.parent.setParams({
                      errorNode: "multipartListPart"
                    });
                    return callback(err);
                  }
                  var ListPartsResult = data.ListPartsResult || {};
                  var Part = ListPartsResult.Part || [];
                  Part = util.isArray(Part) ? Part : [Part];
                  ListPartsResult.Part = Part;
                  var result = util.clone(ListPartsResult);
                  util.extend(result, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                  callback(null, result);
                });
              }
              function multipartAbort(params, callback) {
                var reqParams = {};
                reqParams["uploadId"] = params["UploadId"];
                submitRequest.call(this, {
                  Action: "name/cos:AbortMultipartUpload",
                  method: "DELETE",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  headers: params.Headers,
                  qs: reqParams
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  callback(null, {
                    statusCode: data.statusCode,
                    headers: data.headers
                  });
                });
              }
              function request(params, callback) {
                submitRequest.call(this, {
                  method: params.Method,
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Key: params.Key,
                  action: params.Action,
                  headers: params.Headers,
                  qs: params.Query,
                  body: params.Body,
                  Url: params.Url,
                  rawBody: params.RawBody,
                  DataType: params.DataType
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  if (data && data.body) {
                    data.Body = data.body;
                    delete data.body;
                  }
                  callback(err, data);
                });
              }
              function appendObject(params, callback) {
                var headers = params.Headers;
                if (!headers["Cache-Control"] && !headers["cache-control"])
                  headers["Cache-Control"] = "";
                if (!headers["Content-Type"] && !headers["content-type"])
                  headers["Content-Type"] = params.Body && params.Body.type || "";
                submitRequest.call(this, {
                  Action: "name/cos:AppendObject",
                  method: "POST",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  action: "append",
                  Key: params.Key,
                  body: params.Body,
                  qs: {
                    position: params.Position
                  },
                  headers: params.Headers
                }, function(err, data) {
                  if (err)
                    return callback(err);
                  callback(null, data);
                });
              }
              function getAuth(params) {
                var self2 = this;
                return util.getAuth({
                  SecretId: params.SecretId || this.options.SecretId || "",
                  SecretKey: params.SecretKey || this.options.SecretKey || "",
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Method: params.Method,
                  Key: params.Key,
                  Query: params.Query,
                  Headers: params.Headers,
                  Expires: params.Expires,
                  UseRawKey: self2.options.UseRawKey,
                  SystemClockOffset: self2.options.SystemClockOffset
                });
              }
              function getObjectUrl(params, callback) {
                var self2 = this;
                var useAccelerate = params.UseAccelerate === void 0 ? self2.options.UseAccelerate : params.UseAccelerate;
                var url = getUrl({
                  ForcePathStyle: self2.options.ForcePathStyle,
                  protocol: params.Protocol || self2.options.Protocol,
                  domain: params.Domain || self2.options.Domain,
                  bucket: params.Bucket,
                  region: useAccelerate ? "accelerate" : params.Region,
                  object: params.Key
                });
                var queryParamsStr = "";
                if (params.Query) {
                  queryParamsStr += util.obj2str(params.Query);
                }
                if (params.QueryString) {
                  queryParamsStr += (queryParamsStr ? "&" : "") + params.QueryString;
                }
                var syncUrl = url;
                if (params.Sign !== void 0 && !params.Sign) {
                  queryParamsStr && (syncUrl += "?" + queryParamsStr);
                  callback(null, {
                    Url: syncUrl
                  });
                  return syncUrl;
                }
                var SignHost = getSignHost.call(this, {
                  Bucket: params.Bucket,
                  Region: params.Region,
                  UseAccelerate: params.UseAccelerate,
                  Url: url
                });
                var AuthData = getAuthorizationAsync.call(this, {
                  Action: (params.Method || "").toUpperCase() === "PUT" ? "name/cos:PutObject" : "name/cos:GetObject",
                  Bucket: params.Bucket || "",
                  Region: params.Region || "",
                  Method: params.Method || "get",
                  Key: params.Key,
                  Expires: params.Expires,
                  Headers: params.Headers,
                  Query: params.Query,
                  SignHost,
                  ForceSignHost: params.ForceSignHost === false ? false : self2.options.ForceSignHost
                  // getObjectUrl支持传参ForceSignHost
                }, function(err, AuthData2) {
                  if (!callback)
                    return;
                  if (err) {
                    callback(err);
                    return;
                  }
                  var replaceUrlParamList = function replaceUrlParamList2(url2) {
                    var urlParams = url2.match(/q-url-param-list.*?(?=&)/g)[0];
                    var encodedParams = "q-url-param-list=" + encodeURIComponent(urlParams.replace(/q-url-param-list=/, "")).toLowerCase();
                    var reg = new RegExp(urlParams, "g");
                    var replacedUrl = url2.replace(reg, encodedParams);
                    return replacedUrl;
                  };
                  var signUrl = url;
                  signUrl += "?" + (AuthData2.Authorization.indexOf("q-signature") > -1 ? replaceUrlParamList(AuthData2.Authorization) : "sign=" + encodeURIComponent(AuthData2.Authorization));
                  AuthData2.SecurityToken && (signUrl += "&x-cos-security-token=" + AuthData2.SecurityToken);
                  AuthData2.ClientIP && (signUrl += "&clientIP=" + AuthData2.ClientIP);
                  AuthData2.ClientUA && (signUrl += "&clientUA=" + AuthData2.ClientUA);
                  AuthData2.Token && (signUrl += "&token=" + AuthData2.Token);
                  queryParamsStr && (signUrl += "&" + queryParamsStr);
                  setTimeout(function() {
                    callback(null, {
                      Url: signUrl
                    });
                  });
                });
                if (AuthData) {
                  syncUrl += "?" + AuthData.Authorization + (AuthData.SecurityToken ? "&x-cos-security-token=" + AuthData.SecurityToken : "");
                  queryParamsStr && (syncUrl += "&" + queryParamsStr);
                } else {
                  queryParamsStr && (syncUrl += "?" + queryParamsStr);
                }
                return syncUrl;
              }
              function decodeAcl(AccessControlPolicy) {
                var result = {
                  GrantFullControl: [],
                  GrantWrite: [],
                  GrantRead: [],
                  GrantReadAcp: [],
                  GrantWriteAcp: [],
                  ACL: ""
                };
                var GrantMap = {
                  FULL_CONTROL: "GrantFullControl",
                  WRITE: "GrantWrite",
                  READ: "GrantRead",
                  READ_ACP: "GrantReadAcp",
                  WRITE_ACP: "GrantWriteAcp"
                };
                var AccessControlList = AccessControlPolicy && AccessControlPolicy.AccessControlList || {};
                var Grant = AccessControlList.Grant;
                if (Grant) {
                  Grant = util.isArray(Grant) ? Grant : [Grant];
                }
                var PublicAcl = {
                  READ: 0,
                  WRITE: 0,
                  FULL_CONTROL: 0
                };
                Grant && Grant.length && util.each(Grant, function(item) {
                  if (item.Grantee.ID === "qcs::cam::anyone:anyone" || item.Grantee.URI === "http://cam.qcloud.com/groups/global/AllUsers") {
                    PublicAcl[item.Permission] = 1;
                  } else if (item.Grantee.ID !== AccessControlPolicy.Owner.ID) {
                    result[GrantMap[item.Permission]].push('id="' + item.Grantee.ID + '"');
                  }
                });
                if (PublicAcl.FULL_CONTROL || PublicAcl.WRITE && PublicAcl.READ) {
                  result.ACL = "public-read-write";
                } else if (PublicAcl.READ) {
                  result.ACL = "public-read";
                } else {
                  result.ACL = "private";
                }
                util.each(GrantMap, function(item) {
                  result[item] = uniqGrant(result[item].join(","));
                });
                return result;
              }
              function uniqGrant(str) {
                var arr = str.split(",");
                var exist = {};
                var i, item;
                for (i = 0; i < arr.length; ) {
                  item = arr[i].trim();
                  if (exist[item]) {
                    arr.splice(i, 1);
                  } else {
                    exist[item] = true;
                    arr[i] = item;
                    i++;
                  }
                }
                return arr.join(",");
              }
              function getUrl(params) {
                var region = params.region || "";
                var longBucket = params.bucket || "";
                var shortBucket = longBucket.substr(0, longBucket.lastIndexOf("-"));
                var appId = longBucket.substr(longBucket.lastIndexOf("-") + 1);
                var domain = params.domain;
                var object = params.object;
                if (typeof domain === "function") {
                  domain = domain({
                    Bucket: longBucket,
                    Region: region
                  });
                }
                if (["http", "https"].includes(params.protocol)) {
                  params.protocol = params.protocol + ":";
                }
                var protocol = params.protocol || (util.isBrowser && (typeof location === "undefined" ? "undefined" : _typeof2(location)) === "object" && location.protocol === "http:" ? "http:" : "https:");
                if (!domain) {
                  if (["cn-south", "cn-south-2", "cn-north", "cn-east", "cn-southwest", "sg"].indexOf(region) > -1) {
                    domain = "{Region}.myqcloud.com";
                  } else {
                    domain = "cos.{Region}.myqcloud.com";
                  }
                  if (!params.ForcePathStyle) {
                    domain = "{Bucket}." + domain;
                  }
                }
                domain = domain.replace(/\{\{AppId\}\}/gi, appId).replace(/\{\{Bucket\}\}/gi, shortBucket).replace(/\{\{Region\}\}/gi, region).replace(/\{\{.*?\}\}/gi, "");
                domain = domain.replace(/\{AppId\}/gi, appId).replace(/\{BucketName\}/gi, shortBucket).replace(/\{Bucket\}/gi, longBucket).replace(/\{Region\}/gi, region).replace(/\{.*?\}/gi, "");
                if (!/^[a-zA-Z]+:\/\//.test(domain)) {
                  domain = protocol + "//" + domain;
                }
                if (domain.slice(-1) === "/") {
                  domain = domain.slice(0, -1);
                }
                var url = domain;
                if (params.ForcePathStyle) {
                  url += "/" + longBucket;
                }
                url += "/";
                if (object) {
                  url += util.camSafeUrlEncode(object).replace(/%2F/g, "/");
                }
                if (params.isLocation) {
                  url = url.replace(/^https?:\/\//, "");
                }
                return url;
              }
              var getSignHost = function getSignHost2(opt) {
                if (!opt.Bucket || !opt.Region)
                  return "";
                var useAccelerate = opt.UseAccelerate === void 0 ? this.options.UseAccelerate : opt.UseAccelerate;
                var url = opt.Url || getUrl({
                  ForcePathStyle: this.options.ForcePathStyle,
                  protocol: this.options.Protocol,
                  domain: this.options.Domain,
                  bucket: opt.Bucket,
                  region: useAccelerate ? "accelerate" : opt.Region
                });
                var urlHost = url.replace(/^https?:\/\/([^/]+)(\/.*)?$/, "$1");
                var standardHostReg = new RegExp("^([a-z\\d-]+-\\d+\\.)?(cos|cosv6|ci|pic)\\.([a-z\\d-]+)\\.myqcloud\\.com$");
                if (standardHostReg.test(urlHost))
                  return urlHost;
                return "";
              };
              function getAuthorizationAsync(params, callback) {
                var headers = util.clone(params.Headers);
                var headerHost = "";
                util.each(headers, function(v, k) {
                  (v === "" || ["content-type", "cache-control", "expires"].indexOf(k.toLowerCase()) > -1) && delete headers[k];
                  if (k.toLowerCase() === "host")
                    headerHost = v;
                });
                var forceSignHost = params.ForceSignHost === false ? false : true;
                if (!headerHost && params.SignHost && forceSignHost)
                  headers.Host = params.SignHost;
                var cbDone = false;
                var cb = function cb2(err, AuthData) {
                  if (cbDone)
                    return;
                  cbDone = true;
                  if (AuthData && AuthData.XCosSecurityToken && !AuthData.SecurityToken) {
                    AuthData = util.clone(AuthData);
                    AuthData.SecurityToken = AuthData.XCosSecurityToken;
                    delete AuthData.XCosSecurityToken;
                  }
                  callback && callback(err, AuthData);
                };
                var self2 = this;
                var Bucket = params.Bucket || "";
                var Region = params.Region || "";
                var KeyName = params.Key || "";
                if (self2.options.ForcePathStyle && Bucket) {
                  KeyName = Bucket + "/" + KeyName;
                }
                var Pathname = "/" + KeyName;
                var StsData = {};
                var Scope = params.Scope;
                if (!Scope) {
                  var Action = params.Action || "";
                  var ResourceKey = params.ResourceKey || params.Key || "";
                  Scope = params.Scope || [{
                    action: Action,
                    bucket: Bucket,
                    region: Region,
                    prefix: ResourceKey
                  }];
                }
                var ScopeKey = util.md5(JSON.stringify(Scope));
                self2._StsCache = self2._StsCache || [];
                (function() {
                  var i, AuthData;
                  for (i = self2._StsCache.length - 1; i >= 0; i--) {
                    AuthData = self2._StsCache[i];
                    var compareTime = Math.round(util.getSkewTime(self2.options.SystemClockOffset) / 1e3) + 30;
                    if (AuthData.StartTime && compareTime < AuthData.StartTime || compareTime >= AuthData.ExpiredTime) {
                      self2._StsCache.splice(i, 1);
                      continue;
                    }
                    if (!AuthData.ScopeLimit || AuthData.ScopeLimit && AuthData.ScopeKey === ScopeKey) {
                      StsData = AuthData;
                      break;
                    }
                  }
                })();
                var calcAuthByTmpKey = function calcAuthByTmpKey2() {
                  var KeyTime = "";
                  if (StsData.StartTime && params.Expires)
                    KeyTime = StsData.StartTime + ";" + (StsData.StartTime + params.Expires * 1);
                  else if (StsData.StartTime && StsData.ExpiredTime)
                    KeyTime = StsData.StartTime + ";" + StsData.ExpiredTime;
                  var Authorization = util.getAuth({
                    SecretId: StsData.TmpSecretId,
                    SecretKey: StsData.TmpSecretKey,
                    Method: params.Method,
                    Pathname,
                    Query: params.Query,
                    Headers: headers,
                    Expires: params.Expires,
                    UseRawKey: self2.options.UseRawKey,
                    SystemClockOffset: self2.options.SystemClockOffset,
                    KeyTime,
                    ForceSignHost: forceSignHost
                  });
                  var AuthData = {
                    Authorization,
                    SecurityToken: StsData.SecurityToken || StsData.XCosSecurityToken || "",
                    Token: StsData.Token || "",
                    ClientIP: StsData.ClientIP || "",
                    ClientUA: StsData.ClientUA || ""
                  };
                  cb(null, AuthData);
                };
                var checkAuthError = function checkAuthError2(AuthData) {
                  if (AuthData.Authorization) {
                    var formatAllow = false;
                    var auth = AuthData.Authorization;
                    if (auth) {
                      if (auth.indexOf(" ") > -1) {
                        formatAllow = false;
                      } else if (auth.indexOf("q-sign-algorithm=") > -1 && auth.indexOf("q-ak=") > -1 && auth.indexOf("q-sign-time=") > -1 && auth.indexOf("q-key-time=") > -1 && auth.indexOf("q-url-param-list=") > -1) {
                        formatAllow = true;
                      } else {
                        try {
                          auth = atob(auth);
                          if (auth.indexOf("a=") > -1 && auth.indexOf("k=") > -1 && auth.indexOf("t=") > -1 && auth.indexOf("r=") > -1 && auth.indexOf("b=") > -1) {
                            formatAllow = true;
                          }
                        } catch (e) {
                        }
                      }
                    }
                    if (!formatAllow)
                      return util.error(new Error("getAuthorization callback params format error"));
                  } else {
                    if (!AuthData.TmpSecretId)
                      return util.error(new Error('getAuthorization callback params missing "TmpSecretId"'));
                    if (!AuthData.TmpSecretKey)
                      return util.error(new Error('getAuthorization callback params missing "TmpSecretKey"'));
                    if (!AuthData.SecurityToken && !AuthData.XCosSecurityToken)
                      return util.error(new Error('getAuthorization callback params missing "SecurityToken"'));
                    if (!AuthData.ExpiredTime)
                      return util.error(new Error('getAuthorization callback params missing "ExpiredTime"'));
                    if (AuthData.ExpiredTime && AuthData.ExpiredTime.toString().length !== 10)
                      return util.error(new Error('getAuthorization callback params "ExpiredTime" should be 10 digits'));
                    if (AuthData.StartTime && AuthData.StartTime.toString().length !== 10)
                      return util.error(new Error('getAuthorization callback params "StartTime" should be 10 StartTime'));
                  }
                  return false;
                };
                if (StsData.ExpiredTime && StsData.ExpiredTime - util.getSkewTime(self2.options.SystemClockOffset) / 1e3 > 60) {
                  calcAuthByTmpKey();
                } else if (self2.options.getAuthorization) {
                  self2.options.getAuthorization.call(self2, {
                    Bucket,
                    Region,
                    Method: params.Method,
                    Key: KeyName,
                    Pathname,
                    Query: params.Query,
                    Headers: headers,
                    Scope,
                    SystemClockOffset: self2.options.SystemClockOffset,
                    ForceSignHost: forceSignHost
                  }, function(AuthData) {
                    if (typeof AuthData === "string")
                      AuthData = {
                        Authorization: AuthData
                      };
                    var AuthError = checkAuthError(AuthData);
                    if (AuthError)
                      return cb(AuthError);
                    if (AuthData.Authorization) {
                      cb(null, AuthData);
                    } else {
                      StsData = AuthData || {};
                      StsData.Scope = Scope;
                      StsData.ScopeKey = ScopeKey;
                      self2._StsCache.push(StsData);
                      calcAuthByTmpKey();
                    }
                  });
                } else if (self2.options.getSTS) {
                  self2.options.getSTS.call(self2, {
                    Bucket,
                    Region
                  }, function(data) {
                    StsData = data || {};
                    StsData.Scope = Scope;
                    StsData.ScopeKey = ScopeKey;
                    if (!StsData.TmpSecretId)
                      StsData.TmpSecretId = StsData.SecretId;
                    if (!StsData.TmpSecretKey)
                      StsData.TmpSecretKey = StsData.SecretKey;
                    var AuthError = checkAuthError(StsData);
                    if (AuthError)
                      return cb(AuthError);
                    self2._StsCache.push(StsData);
                    calcAuthByTmpKey();
                  });
                } else {
                  return function() {
                    var Authorization = util.getAuth({
                      SecretId: params.SecretId || self2.options.SecretId,
                      SecretKey: params.SecretKey || self2.options.SecretKey,
                      Method: params.Method,
                      Pathname,
                      Query: params.Query,
                      Headers: headers,
                      Expires: params.Expires,
                      UseRawKey: self2.options.UseRawKey,
                      SystemClockOffset: self2.options.SystemClockOffset,
                      ForceSignHost: forceSignHost
                    });
                    var AuthData = {
                      Authorization,
                      SecurityToken: self2.options.SecurityToken || self2.options.XCosSecurityToken
                    };
                    cb(null, AuthData);
                    return AuthData;
                  }();
                }
                return "";
              }
              function allowRetry(err) {
                var allowRetry2 = false;
                var isTimeError = false;
                var serverDate = err.headers && (err.headers.date || err.headers.Date) || err.error && err.error.ServerTime;
                try {
                  var errorCode = err.error.Code;
                  var errorMessage = err.error.Message;
                  if (errorCode === "RequestTimeTooSkewed" || errorCode === "AccessDenied" && errorMessage === "Request has expired") {
                    isTimeError = true;
                  }
                } catch (e) {
                }
                if (err) {
                  if (isTimeError && serverDate) {
                    var serverTime = Date.parse(serverDate);
                    if (this.options.CorrectClockSkew && Math.abs(util.getSkewTime(this.options.SystemClockOffset) - serverTime) >= 3e4) {
                      console.error("error: Local time is too skewed.");
                      this.options.SystemClockOffset = serverTime - Date.now();
                      allowRetry2 = true;
                    }
                  } else if (Math.floor(err.statusCode / 100) === 5) {
                    allowRetry2 = true;
                  }
                }
                return allowRetry2;
              }
              function submitRequest(params, callback) {
                var self2 = this;
                !params.headers && (params.headers = {});
                !params.qs && (params.qs = {});
                params.VersionId && (params.qs.versionId = params.VersionId);
                params.qs = util.clearKey(params.qs);
                params.headers && (params.headers = util.clearKey(params.headers));
                params.qs && (params.qs = util.clearKey(params.qs));
                var Query = util.clone(params.qs);
                params.action && (Query[params.action] = "");
                var paramsUrl = params.url || params.Url;
                var SignHost = params.SignHost || getSignHost.call(this, {
                  Bucket: params.Bucket,
                  Region: params.Region,
                  Url: paramsUrl
                });
                var tracker = params.tracker;
                var next = function next2(tryTimes) {
                  var oldClockOffset = self2.options.SystemClockOffset;
                  tracker && tracker.setParams({
                    signStartTime: (/* @__PURE__ */ new Date()).getTime(),
                    retryTimes: tryTimes - 1
                  });
                  getAuthorizationAsync.call(self2, {
                    Bucket: params.Bucket || "",
                    Region: params.Region || "",
                    Method: params.method,
                    Key: params.Key,
                    Query,
                    Headers: params.headers,
                    SignHost,
                    Action: params.Action,
                    ResourceKey: params.ResourceKey,
                    Scope: params.Scope,
                    ForceSignHost: self2.options.ForceSignHost
                  }, function(err, AuthData) {
                    if (err) {
                      callback(err);
                      return;
                    }
                    tracker && tracker.setParams({
                      signEndTime: (/* @__PURE__ */ new Date()).getTime(),
                      httpStartTime: (/* @__PURE__ */ new Date()).getTime()
                    });
                    params.AuthData = AuthData;
                    _submitRequest.call(self2, params, function(err2, data) {
                      tracker && tracker.setParams({
                        httpEndTime: (/* @__PURE__ */ new Date()).getTime()
                      });
                      if (err2 && tryTimes < 2 && (oldClockOffset !== self2.options.SystemClockOffset || allowRetry.call(self2, err2))) {
                        if (params.headers) {
                          delete params.headers.Authorization;
                          delete params.headers["token"];
                          delete params.headers["clientIP"];
                          delete params.headers["clientUA"];
                          params.headers["x-cos-security-token"] && delete params.headers["x-cos-security-token"];
                          params.headers["x-ci-security-token"] && delete params.headers["x-ci-security-token"];
                        }
                        next2(tryTimes + 1);
                      } else {
                        callback(err2, data);
                      }
                    });
                  });
                };
                next(1);
              }
              function _submitRequest(params, callback) {
                var self2 = this;
                var TaskId = params.TaskId;
                if (TaskId && !self2._isRunningTask(TaskId))
                  return;
                var bucket = params.Bucket;
                var region = params.Region;
                var object = params.Key;
                var method2 = params.method || "GET";
                var url = params.Url || params.url;
                var body = params.body;
                var rawBody = params.rawBody;
                if (self2.options.UseAccelerate) {
                  region = "accelerate";
                }
                url = url || getUrl({
                  ForcePathStyle: self2.options.ForcePathStyle,
                  protocol: self2.options.Protocol,
                  domain: self2.options.Domain,
                  bucket,
                  region,
                  object
                });
                if (params.action) {
                  url = url + "?" + (util.isIOS_QQ ? "".concat(params.action, "=") : params.action);
                }
                if (params.qsStr) {
                  if (url.indexOf("?") > -1) {
                    url = url + "&" + params.qsStr;
                  } else {
                    url = url + "?" + params.qsStr;
                  }
                }
                var opt = {
                  method: method2,
                  url,
                  headers: params.headers,
                  qs: params.qs,
                  body
                };
                var token = "x-cos-security-token";
                if (util.isCIHost(url)) {
                  token = "x-ci-security-token";
                }
                opt.headers.Authorization = params.AuthData.Authorization;
                params.AuthData.Token && (opt.headers["token"] = params.AuthData.Token);
                params.AuthData.ClientIP && (opt.headers["clientIP"] = params.AuthData.ClientIP);
                params.AuthData.ClientUA && (opt.headers["clientUA"] = params.AuthData.ClientUA);
                params.AuthData.SecurityToken && (opt.headers[token] = params.AuthData.SecurityToken);
                opt.headers && (opt.headers = util.clearKey(opt.headers));
                opt = util.clearKey(opt);
                if (params.onProgress && typeof params.onProgress === "function") {
                  var contentLength = body && (body.size || body.length) || 0;
                  opt.onProgress = function(e) {
                    if (TaskId && !self2._isRunningTask(TaskId))
                      return;
                    var loaded = e ? e.loaded : 0;
                    params.onProgress({
                      loaded,
                      total: contentLength
                    });
                  };
                }
                if (params.onDownloadProgress) {
                  opt.onDownloadProgress = params.onDownloadProgress;
                }
                if (params.DataType) {
                  opt.dataType = params.DataType;
                }
                if (this.options.Timeout) {
                  opt.timeout = this.options.Timeout;
                }
                self2.options.ForcePathStyle && (opt.pathStyle = self2.options.ForcePathStyle);
                self2.emit("before-send", opt);
                var useAccelerate = opt.url.includes("accelerate.");
                var queryString = opt.qs ? Object.keys(opt.qs).map(function(key) {
                  return "".concat(key, "=").concat(opt.qs[key]);
                }).join("&") : "";
                var fullUrl = queryString ? opt.url + "?" + queryString : opt.url;
                params.tracker && params.tracker.setParams({
                  reqUrl: fullUrl,
                  accelerate: useAccelerate ? "Y" : "N"
                });
                params.tracker && params.tracker.parent && params.tracker.parent.setParams({
                  reqUrl: fullUrl,
                  accelerate: useAccelerate ? "Y" : "N"
                });
                var sender = (self2.options.Request || REQUEST)(opt, function(r) {
                  if (r && r.error === "abort")
                    return;
                  var receive = {
                    options: opt,
                    error: r && r.error,
                    statusCode: r && r.statusCode || 0,
                    statusMessage: r && r.statusMessage || "",
                    headers: r && r.headers || {},
                    body: r && r.body
                  };
                  self2.emit("after-receive", receive);
                  var err = receive.error;
                  var body2 = receive.body;
                  var response = {
                    statusCode: receive.statusCode,
                    statusMessage: receive.statusMessage,
                    headers: receive.headers
                  };
                  var hasReturned;
                  var cb = function cb2(err2, data) {
                    TaskId && self2.off("inner-kill-task", killTask);
                    if (hasReturned)
                      return;
                    hasReturned = true;
                    var attrs = {};
                    response && response.statusCode && (attrs.statusCode = response.statusCode);
                    response && response.headers && (attrs.headers = response.headers);
                    if (err2) {
                      err2 = util.extend(err2 || {}, attrs);
                      callback(err2, null);
                    } else {
                      data = util.extend(data || {}, attrs);
                      callback(null, data);
                    }
                    sender = null;
                  };
                  if (err)
                    return cb(util.error(err));
                  var statusCode = response.statusCode;
                  var statusSuccess = Math.floor(statusCode / 100) === 2;
                  if (rawBody && statusSuccess)
                    return cb(null, {
                      body: body2
                    });
                  var json;
                  try {
                    json = body2 && body2.indexOf("<") > -1 && body2.indexOf(">") > -1 && util.xml2json(body2) || {};
                  } catch (e) {
                    json = {};
                  }
                  var xmlError = json && json.Error;
                  if (statusSuccess) {
                    cb(null, json);
                  } else if (xmlError) {
                    cb(util.error(new Error(xmlError.Message), {
                      code: xmlError.Code,
                      error: xmlError
                    }));
                  } else if (statusCode) {
                    cb(util.error(new Error(response.statusMessage), {
                      code: "" + statusCode
                    }));
                  } else if (statusCode) {
                    cb(util.error(new Error("statusCode error")));
                  }
                });
                var killTask = function killTask2(data) {
                  if (data.TaskId === TaskId) {
                    sender && sender.abort && sender.abort();
                    self2.off("inner-kill-task", killTask2);
                  }
                };
                TaskId && self2.on("inner-kill-task", killTask);
              }
              var API_MAP = {
                // Bucket 相关方法
                getService,
                // Bucket
                putBucket,
                headBucket,
                // Bucket
                getBucket,
                deleteBucket,
                putBucketAcl,
                // BucketACL
                getBucketAcl,
                putBucketCors,
                // BucketCors
                getBucketCors,
                deleteBucketCors,
                getBucketLocation,
                // BucketLocation
                getBucketPolicy,
                // BucketPolicy
                putBucketPolicy,
                deleteBucketPolicy,
                putBucketTagging,
                // BucketTagging
                getBucketTagging,
                deleteBucketTagging,
                putBucketLifecycle,
                // BucketLifecycle
                getBucketLifecycle,
                deleteBucketLifecycle,
                putBucketVersioning,
                // BucketVersioning
                getBucketVersioning,
                putBucketReplication,
                // BucketReplication
                getBucketReplication,
                deleteBucketReplication,
                putBucketWebsite,
                // BucketWebsite
                getBucketWebsite,
                deleteBucketWebsite,
                putBucketReferer,
                // BucketReferer
                getBucketReferer,
                putBucketDomain,
                // BucketDomain
                getBucketDomain,
                deleteBucketDomain,
                putBucketOrigin,
                // BucketOrigin
                getBucketOrigin,
                deleteBucketOrigin,
                putBucketLogging,
                // BucketLogging
                getBucketLogging,
                putBucketInventory,
                // BucketInventory
                postBucketInventory,
                getBucketInventory,
                listBucketInventory,
                deleteBucketInventory,
                putBucketAccelerate,
                getBucketAccelerate,
                putBucketEncryption,
                getBucketEncryption,
                deleteBucketEncryption,
                // Object 相关方法
                getObject,
                headObject,
                listObjectVersions,
                putObject,
                deleteObject,
                getObjectAcl,
                putObjectAcl,
                optionsObject,
                putObjectCopy,
                deleteMultipleObject,
                restoreObject,
                putObjectTagging,
                getObjectTagging,
                deleteObjectTagging,
                selectObjectContent,
                appendObject,
                // 分块上传相关方法
                uploadPartCopy,
                multipartInit,
                multipartUpload,
                multipartComplete,
                multipartList,
                multipartListPart,
                multipartAbort,
                // 工具方法
                request,
                getObjectUrl,
                getAuth
              };
              function warnOldApi(apiName, fn, proto) {
                util.each(["Cors", "Acl"], function(suffix) {
                  if (apiName.slice(-suffix.length) === suffix) {
                    var oldName = apiName.slice(0, -suffix.length) + suffix.toUpperCase();
                    var apiFn = util.apiWrapper(apiName, fn);
                    var warned = false;
                    proto[oldName] = function() {
                      !warned && console.warn("warning: cos." + oldName + " has been deprecated. Please Use cos." + apiName + " instead.");
                      warned = true;
                      apiFn.apply(this, arguments);
                    };
                  }
                });
              }
              module2.exports.init = function(COS, task) {
                task.transferToTaskMethod(API_MAP, "putObject");
                util.each(API_MAP, function(fn, apiName) {
                  COS.prototype[apiName] = util.apiWrapper(apiName, fn);
                  warnOldApi(apiName, fn, COS.prototype);
                });
              };
            }
          ),
          /***/
          "./src/cos.js": (
            /*!********************!*\
              !*** ./src/cos.js ***!
              \********************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              "use strict";
              var util = __webpack_require__2(
                /*! ./util */
                "./src/util.js"
              );
              var event = __webpack_require__2(
                /*! ./event */
                "./src/event.js"
              );
              var task = __webpack_require__2(
                /*! ./task */
                "./src/task.js"
              );
              var base = __webpack_require__2(
                /*! ./base */
                "./src/base.js"
              );
              var advance = __webpack_require__2(
                /*! ./advance */
                "./src/advance.js"
              );
              var pkg = __webpack_require__2(
                /*! ../package.json */
                "./package.json"
              );
              var defaultOptions = {
                AppId: "",
                // AppId 已废弃，请拼接到 Bucket 后传入，例如：test-1250000000
                SecretId: "",
                SecretKey: "",
                SecurityToken: "",
                // 使用临时密钥需要注意自行刷新 Token
                ChunkRetryTimes: 2,
                FileParallelLimit: 3,
                ChunkParallelLimit: 3,
                ChunkSize: 1024 * 1024,
                SliceSize: 1024 * 1024,
                CopyChunkParallelLimit: 20,
                CopyChunkSize: 1024 * 1024 * 10,
                CopySliceSize: 1024 * 1024 * 10,
                MaxPartNumber: 1e4,
                ProgressInterval: 1e3,
                Domain: "",
                ServiceDomain: "",
                Protocol: "",
                CompatibilityMode: false,
                ForcePathStyle: false,
                UseRawKey: false,
                Timeout: 0,
                // 单位毫秒，0 代表不设置超时时间
                CorrectClockSkew: true,
                SystemClockOffset: 0,
                // 单位毫秒，ms
                UploadCheckContentMd5: false,
                UploadQueueSize: 1e4,
                UploadAddMetaMd5: false,
                UploadIdCacheLimit: 50,
                UseAccelerate: false,
                ForceSignHost: true,
                // 默认将host加入签名计算，关闭后可能导致越权风险，建议保持为true
                EnableTracker: false,
                // 默认关闭上报
                DeepTracker: false,
                // 上报时是否对每个分块上传做单独上报
                TrackerDelay: 5e3,
                // 周期性上报，单位毫秒。0代表实时上报
                CustomId: ""
                // 自定义上报id
              };
              var COS = function COS2(options) {
                this.options = util.extend(util.clone(defaultOptions), options || {});
                this.options.FileParallelLimit = Math.max(1, this.options.FileParallelLimit);
                this.options.ChunkParallelLimit = Math.max(1, this.options.ChunkParallelLimit);
                this.options.ChunkRetryTimes = Math.max(0, this.options.ChunkRetryTimes);
                this.options.ChunkSize = Math.max(1024 * 1024, this.options.ChunkSize);
                this.options.CopyChunkParallelLimit = Math.max(1, this.options.CopyChunkParallelLimit);
                this.options.CopyChunkSize = Math.max(1024 * 1024, this.options.CopyChunkSize);
                this.options.CopySliceSize = Math.max(0, this.options.CopySliceSize);
                this.options.MaxPartNumber = Math.max(1024, Math.min(1e4, this.options.MaxPartNumber));
                this.options.Timeout = Math.max(0, this.options.Timeout);
                if (this.options.AppId) {
                  console.warn('warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g: "test-1250000000").');
                }
                if (this.options.SecretId && this.options.SecretId.indexOf(" ") > -1) {
                  console.error("error: SecretId格式错误，请检查");
                  console.error("error: SecretId format is incorrect. Please check");
                }
                if (this.options.SecretKey && this.options.SecretKey.indexOf(" ") > -1) {
                  console.error("error: SecretKey格式错误，请检查");
                  console.error("error: SecretKey format is incorrect. Please check");
                }
                if (util.isNode()) {
                  console.warn("warning: cos-js-sdk-v5 不支持 nodejs 环境使用，请改用 cos-nodejs-sdk-v5，参考文档： https://cloud.tencent.com/document/product/436/8629");
                  console.warn("warning: cos-js-sdk-v5 does not support nodejs environment. Please use cos-nodejs-sdk-v5 instead. See: https://cloud.tencent.com/document/product/436/8629");
                }
                event.init(this);
                task.init(this);
              };
              base.init(COS, task);
              advance.init(COS, task);
              COS.util = {
                md5: util.md5,
                xml2json: util.xml2json,
                json2xml: util.json2xml,
                encodeBase64: util.encodeBase64
              };
              COS.getAuthorization = util.getAuth;
              COS.version = pkg.version;
              module2.exports = COS;
            }
          ),
          /***/
          "./src/event.js": (
            /*!**********************!*\
              !*** ./src/event.js ***!
              \**********************/
            /*! no static exports found */
            /***/
            function(module2, exports2) {
              var initEvent = function initEvent2(cos) {
                var listeners = {};
                var getList = function getList2(action) {
                  !listeners[action] && (listeners[action] = []);
                  return listeners[action];
                };
                cos.on = function(action, callback) {
                  if (action === "task-list-update") {
                    console.warn('warning: Event "' + action + '" has been deprecated. Please use "list-update" instead.');
                  }
                  getList(action).push(callback);
                };
                cos.off = function(action, callback) {
                  var list = getList(action);
                  for (var i = list.length - 1; i >= 0; i--) {
                    callback === list[i] && list.splice(i, 1);
                  }
                };
                cos.emit = function(action, data) {
                  var list = getList(action).map(function(cb) {
                    return cb;
                  });
                  for (var i = 0; i < list.length; i++) {
                    list[i](data);
                  }
                };
              };
              var EventProxy = function EventProxy2() {
                initEvent(this);
              };
              module2.exports.init = initEvent;
              module2.exports.EventProxy = EventProxy;
            }
          ),
          /***/
          "./src/session.js": (
            /*!************************!*\
              !*** ./src/session.js ***!
              \************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var util = __webpack_require__2(
                /*! ./util */
                "./src/util.js"
              );
              var cacheKey = "cos_sdk_upload_cache";
              var expires = 30 * 24 * 3600;
              var cache;
              var timer;
              var getCache = function getCache2() {
                try {
                  var val = JSON.parse(localStorage.getItem(cacheKey));
                } catch (e) {
                }
                if (!val)
                  val = [];
                cache = val;
              };
              var setCache = function setCache2() {
                try {
                  if (cache.length)
                    localStorage.setItem(cacheKey, JSON.stringify(cache));
                  else
                    localStorage.removeItem(cacheKey);
                } catch (e) {
                }
              };
              var init = function init2() {
                if (cache)
                  return;
                getCache.call(this);
                var changed = false;
                var now = Math.round(Date.now() / 1e3);
                for (var i = cache.length - 1; i >= 0; i--) {
                  var mtime = cache[i][2];
                  if (!mtime || mtime + expires < now) {
                    cache.splice(i, 1);
                    changed = true;
                  }
                }
                changed && setCache();
              };
              var save = function save2() {
                if (timer)
                  return;
                timer = setTimeout(function() {
                  setCache();
                  timer = null;
                }, 400);
              };
              var mod = {
                using: {},
                // 标记 UploadId 正在使用
                setUsing: function setUsing(uuid) {
                  mod.using[uuid] = true;
                },
                // 标记 UploadId 已经没在使用
                removeUsing: function removeUsing(uuid) {
                  delete mod.using[uuid];
                },
                // 用上传参数生成哈希值
                getFileId: function getFileId(file, ChunkSize, Bucket, Key) {
                  if (file.name && file.size && file.lastModifiedDate && ChunkSize) {
                    return util.md5([file.name, file.size, file.lastModifiedDate, ChunkSize, Bucket, Key].join("::"));
                  } else {
                    return null;
                  }
                },
                // 用上传参数生成哈希值
                getCopyFileId: function getCopyFileId(copySource, sourceHeaders, ChunkSize, Bucket, Key) {
                  var size = sourceHeaders["content-length"];
                  var etag = sourceHeaders.etag || "";
                  var lastModified = sourceHeaders["last-modified"];
                  if (copySource && ChunkSize) {
                    return util.md5([copySource, size, etag, lastModified, ChunkSize, Bucket, Key].join("::"));
                  } else {
                    return null;
                  }
                },
                // 获取文件对应的 UploadId 列表
                getUploadIdList: function getUploadIdList(uuid) {
                  if (!uuid)
                    return null;
                  init.call(this);
                  var list = [];
                  for (var i = 0; i < cache.length; i++) {
                    if (cache[i][0] === uuid)
                      list.push(cache[i][1]);
                  }
                  return list.length ? list : null;
                },
                // 缓存 UploadId
                saveUploadId: function saveUploadId(uuid, UploadId, limit) {
                  init.call(this);
                  if (!uuid)
                    return;
                  for (var i = cache.length - 1; i >= 0; i--) {
                    var item = cache[i];
                    if (item[0] === uuid && item[1] === UploadId) {
                      cache.splice(i, 1);
                    }
                  }
                  cache.unshift([uuid, UploadId, Math.round(Date.now() / 1e3)]);
                  if (cache.length > limit)
                    cache.splice(limit);
                  save();
                },
                // UploadId 已用完，移除掉
                removeUploadId: function removeUploadId(UploadId) {
                  init.call(this);
                  delete mod.using[UploadId];
                  for (var i = cache.length - 1; i >= 0; i--) {
                    if (cache[i][1] === UploadId)
                      cache.splice(i, 1);
                  }
                  save();
                }
              };
              module2.exports = mod;
            }
          ),
          /***/
          "./src/task.js": (
            /*!*********************!*\
              !*** ./src/task.js ***!
              \*********************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var session = __webpack_require__2(
                /*! ./session */
                "./src/session.js"
              );
              var util = __webpack_require__2(
                /*! ./util */
                "./src/util.js"
              );
              var originApiMap = {};
              var transferToTaskMethod = function transferToTaskMethod2(apiMap, apiName) {
                originApiMap[apiName] = apiMap[apiName];
                apiMap[apiName] = function(params, callback) {
                  if (params.SkipTask) {
                    originApiMap[apiName].call(this, params, callback);
                  } else {
                    this._addTask(apiName, params, callback);
                  }
                };
              };
              var initTask = function initTask2(cos) {
                var queue = [];
                var tasks = {};
                var uploadingFileCount = 0;
                var nextUploadIndex = 0;
                var formatTask = function formatTask2(task) {
                  var t = {
                    id: task.id,
                    Bucket: task.Bucket,
                    Region: task.Region,
                    Key: task.Key,
                    FilePath: task.FilePath,
                    state: task.state,
                    loaded: task.loaded,
                    size: task.size,
                    speed: task.speed,
                    percent: task.percent,
                    hashPercent: task.hashPercent,
                    error: task.error
                  };
                  if (task.FilePath)
                    t.FilePath = task.FilePath;
                  if (task._custom)
                    t._custom = task._custom;
                  return t;
                };
                var emitListUpdate = function() {
                  var timer;
                  var emit = function emit2() {
                    timer = 0;
                    cos.emit("task-list-update", {
                      list: util.map(queue, formatTask)
                    });
                    cos.emit("list-update", {
                      list: util.map(queue, formatTask)
                    });
                  };
                  return function() {
                    if (!timer)
                      timer = setTimeout(emit);
                  };
                }();
                var clearQueue = function clearQueue2() {
                  if (queue.length <= cos.options.UploadQueueSize)
                    return;
                  for (var i = 0; i < nextUploadIndex && // 小于当前操作的 index 才清理
                  i < queue.length && // 大于队列才清理
                  queue.length > cos.options.UploadQueueSize; ) {
                    var isActive = queue[i].state === "waiting" || queue[i].state === "checking" || queue[i].state === "uploading";
                    if (!queue[i] || !isActive) {
                      tasks[queue[i].id] && delete tasks[queue[i].id];
                      queue.splice(i, 1);
                      nextUploadIndex--;
                    } else {
                      i++;
                    }
                  }
                  emitListUpdate();
                };
                var startNextTask = function startNextTask2() {
                  if (uploadingFileCount >= cos.options.FileParallelLimit)
                    return;
                  while (queue[nextUploadIndex] && queue[nextUploadIndex].state !== "waiting")
                    nextUploadIndex++;
                  if (nextUploadIndex >= queue.length)
                    return;
                  var task = queue[nextUploadIndex];
                  nextUploadIndex++;
                  uploadingFileCount++;
                  task.state = "checking";
                  task.params.onTaskStart && task.params.onTaskStart(formatTask(task));
                  !task.params.UploadData && (task.params.UploadData = {});
                  var apiParams = util.formatParams(task.api, task.params);
                  originApiMap[task.api].call(cos, apiParams, function(err, data) {
                    if (!cos._isRunningTask(task.id))
                      return;
                    if (task.state === "checking" || task.state === "uploading") {
                      task.state = err ? "error" : "success";
                      err && (task.error = err);
                      uploadingFileCount--;
                      emitListUpdate();
                      startNextTask2();
                      task.callback && task.callback(err, data);
                      if (task.state === "success") {
                        if (task.params) {
                          delete task.params.UploadData;
                          delete task.params.Body;
                          delete task.params;
                        }
                        delete task.callback;
                      }
                    }
                    clearQueue();
                  });
                  emitListUpdate();
                  setTimeout(startNextTask2);
                };
                var killTask = function killTask2(id, switchToState) {
                  var task = tasks[id];
                  if (!task)
                    return;
                  var waiting = task && task.state === "waiting";
                  var running = task && (task.state === "checking" || task.state === "uploading");
                  if (switchToState === "canceled" && task.state !== "canceled" || switchToState === "paused" && waiting || switchToState === "paused" && running) {
                    if (switchToState === "paused" && task.params.Body && typeof task.params.Body.pipe === "function") {
                      console.error("stream not support pause");
                      return;
                    }
                    task.state = switchToState;
                    cos.emit("inner-kill-task", {
                      TaskId: id,
                      toState: switchToState
                    });
                    try {
                      var UploadId = task && task.params && task.params.UploadData.UploadId;
                    } catch (e) {
                    }
                    if (switchToState === "canceled" && UploadId)
                      session.removeUsing(UploadId);
                    emitListUpdate();
                    if (running) {
                      uploadingFileCount--;
                      startNextTask();
                    }
                    if (switchToState === "canceled") {
                      if (task.params) {
                        delete task.params.UploadData;
                        delete task.params.Body;
                        delete task.params;
                      }
                      delete task.callback;
                    }
                  }
                  clearQueue();
                };
                cos._addTasks = function(taskList) {
                  util.each(taskList, function(task) {
                    cos._addTask(task.api, task.params, task.callback, true);
                  });
                  emitListUpdate();
                };
                var isTaskReadyWarning = true;
                cos._addTask = function(api, params, callback, ignoreAddEvent) {
                  params = util.formatParams(api, params);
                  var id = util.uuid();
                  params.TaskId = id;
                  params.onTaskReady && params.onTaskReady(id);
                  if (params.TaskReady) {
                    params.TaskReady(id);
                    isTaskReadyWarning && console.warn('warning: Param "TaskReady" has been deprecated. Please use "onTaskReady" instead.');
                    isTaskReadyWarning = false;
                  }
                  var task = {
                    // env
                    params,
                    callback,
                    api,
                    index: queue.length,
                    // task
                    id,
                    Bucket: params.Bucket,
                    Region: params.Region,
                    Key: params.Key,
                    FilePath: params.FilePath || "",
                    state: "waiting",
                    loaded: 0,
                    size: 0,
                    speed: 0,
                    percent: 0,
                    hashPercent: 0,
                    error: null,
                    _custom: params._custom
                  };
                  var onHashProgress = params.onHashProgress;
                  params.onHashProgress = function(info) {
                    if (!cos._isRunningTask(task.id))
                      return;
                    task.hashPercent = info.percent;
                    onHashProgress && onHashProgress(info);
                    emitListUpdate();
                  };
                  var onProgress = params.onProgress;
                  params.onProgress = function(info) {
                    if (!cos._isRunningTask(task.id))
                      return;
                    task.state === "checking" && (task.state = "uploading");
                    task.loaded = info.loaded;
                    task.speed = info.speed;
                    task.percent = info.percent;
                    onProgress && onProgress(info);
                    emitListUpdate();
                  };
                  util.getFileSize(api, params, function(err, size) {
                    if (err)
                      return callback(util.error(err));
                    tasks[id] = task;
                    queue.push(task);
                    task.size = size;
                    !ignoreAddEvent && emitListUpdate();
                    startNextTask();
                    clearQueue();
                  });
                  return id;
                };
                cos._isRunningTask = function(id) {
                  var task = tasks[id];
                  return !!(task && (task.state === "checking" || task.state === "uploading"));
                };
                cos.getTaskList = function() {
                  return util.map(queue, formatTask);
                };
                cos.cancelTask = function(id) {
                  killTask(id, "canceled");
                };
                cos.pauseTask = function(id) {
                  killTask(id, "paused");
                };
                cos.restartTask = function(id) {
                  var task = tasks[id];
                  if (task && (task.state === "paused" || task.state === "error")) {
                    task.state = "waiting";
                    emitListUpdate();
                    nextUploadIndex = Math.min(nextUploadIndex, task.index);
                    startNextTask();
                  }
                };
                cos.isUploadRunning = function() {
                  return uploadingFileCount || nextUploadIndex < queue.length;
                };
              };
              module2.exports.transferToTaskMethod = transferToTaskMethod;
              module2.exports.init = initTask;
            }
          ),
          /***/
          "./src/tracker.js": (
            /*!************************!*\
              !*** ./src/tracker.js ***!
              \************************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              var _classCallCheck = __webpack_require__2(
                /*! @babel/runtime/helpers/classCallCheck */
                "./node_modules/@babel/runtime/helpers/classCallCheck.js"
              );
              var _createClass = __webpack_require__2(
                /*! @babel/runtime/helpers/createClass */
                "./node_modules/@babel/runtime/helpers/createClass.js"
              );
              var _typeof2 = __webpack_require__2(
                /*! @babel/runtime/helpers/typeof */
                "./node_modules/@babel/runtime/helpers/typeof.js"
              );
              var pkg = __webpack_require__2(
                /*! ../package.json */
                "./package.json"
              );
              var beacon = null;
              var getBeacon = function getBeacon2(delay) {
                if (!beacon) {
                  var BeaconAction = __webpack_require__2(
                    /*! ../lib/beacon.min */
                    "./lib/beacon.min.js"
                  );
                  beacon = new BeaconAction({
                    appkey: "0AND0VEVB24UBGDU",
                    versionCode: pkg.version,
                    channelID: "js_sdk",
                    //渠道,选填
                    openid: "openid",
                    // 用户id, 选填
                    unionid: "unid",
                    //用户unionid , 类似idfv,选填
                    strictMode: false,
                    //严苛模式开关, 打开严苛模式会主动抛出异常, 上线请务必关闭!!!
                    delay,
                    // 普通事件延迟上报时间(单位毫秒), 默认1000(1秒),选填
                    sessionDuration: 60 * 1e3
                    // session变更的时间间隔, 一个用户持续30分钟(默认值)没有任何上报则算另一次 session,每变更一次session上报一次启动事件(rqd_applaunched),使用毫秒(ms),最小值30秒,选填
                  });
                }
                return beacon;
              };
              var utils = {
                // 生成uid 每个链路对应唯一一条uid
                getUid: function getUid() {
                  var S4 = function S42() {
                    return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
                  };
                  return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
                },
                // 获取网络类型
                getNetType: function getNetType() {
                  if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) === "object") {
                    var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                    return (connection === null || connection === void 0 ? void 0 : connection.type) || (connection === null || connection === void 0 ? void 0 : connection.effectiveType) || "unknown";
                  }
                  return "unknown";
                },
                // 获取pc端操作系统类型
                getOsType: function getOsType() {
                  if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) !== "object") {
                    return "unknown os";
                  }
                  var agent = navigator.userAgent.toLowerCase();
                  var isMac = /macintosh|mac os x/i.test(navigator.userAgent);
                  if (agent.indexOf("win32") >= 0 || agent.indexOf("wow32") >= 0) {
                    return "win32";
                  }
                  if (agent.indexOf("win64") >= 0 || agent.indexOf("wow64") >= 0) {
                    return "win64";
                  }
                  if (isMac) {
                    return "mac";
                  }
                  return "unknown os";
                },
                isMobile: function isMobile2() {
                  var exp = /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i;
                  if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) === "object" && navigator.userAgent.match(exp)) {
                    return true;
                  }
                  return false;
                },
                isAndroid: function isAndroid2() {
                  var exp = /(Android|Adr|Linux)/i;
                  if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) === "object" && navigator.userAgent.match(exp)) {
                    return true;
                  }
                  return false;
                },
                isIOS: function isIOS2() {
                  var exp = /(iPhone|iPod|iPad|iOS)/i;
                  if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) === "object" && navigator.userAgent.match(exp)) {
                    return true;
                  }
                  return false;
                },
                isOtherMobile: function isOtherMobile() {
                  return isMobile && !isAndroid && !isIOS;
                },
                // 获取浏览器类型
                getDeviceName: function getDeviceName() {
                  if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) !== "object") {
                    return "unknown device";
                  }
                  var explorer = navigator.userAgent.toLowerCase();
                  if (explorer.includes("app/tencent_wemeet")) {
                    return "tencent_wemeet";
                  }
                  if (explorer.indexOf("maxthon") >= 0) {
                    var match = explorer.match(/maxthon\/([\d.]+)/);
                    var ver = match && match[1] || "";
                    return "傲游浏览器 ".concat(ver).trim();
                  }
                  if (explorer.indexOf("qqbrowser") >= 0) {
                    var _match = explorer.match(/qqbrowser\/([\d.]+)/);
                    var _ver = _match && _match[1] || "";
                    return "QQ浏览器 ".concat(_ver).trim();
                  }
                  if (explorer.indexOf("se 2.x") >= 0) {
                    return "搜狗浏览器";
                  }
                  if (explorer.indexOf("wxwork") >= 0) {
                    return "微信内置浏览器";
                  }
                  if (explorer.indexOf("msie") >= 0) {
                    var _match2 = explorer.match(/msie ([\d.]+)/);
                    var _ver2 = _match2 && _match2[1] || "";
                    return "IE ".concat(_ver2).trim();
                  }
                  if (explorer.indexOf("firefox") >= 0) {
                    var _match3 = explorer.match(/firefox\/([\d.]+)/);
                    var _ver3 = _match3 && _match3[1] || "";
                    return "Firefox ".concat(_ver3).trim();
                  }
                  if (explorer.indexOf("chrome") >= 0) {
                    var _match4 = explorer.match(/chrome\/([\d.]+)/);
                    var _ver4 = _match4 && _match4[1] || "";
                    return "Chrome ".concat(_ver4).trim();
                  }
                  if (explorer.indexOf("opera") >= 0) {
                    var _match5 = explorer.match(/opera.([\d.]+)/);
                    var _ver5 = _match5 && _match5[1] || "";
                    return "Opera ".concat(_ver5).trim();
                  }
                  if (explorer.indexOf("safari") >= 0) {
                    var _match6 = explorer.match(/version\/([\d.]+)/);
                    var _ver6 = _match6 && _match6[1] || "";
                    return "Safari ".concat(_ver6).trim();
                  }
                  if (explorer.indexOf("edge") >= 0) {
                    var _match7 = explorer.match(/edge\/([\d.]+)/);
                    var _ver7 = _match7 && _match7[1] || "";
                    return "edge ".concat(_ver7).trim();
                  }
                  return explorer.substr(0, 200);
                }
              };
              var constant = {
                isMobile: utils.isMobile(),
                isBrowser: !utils.isMobile(),
                mobileOsType: utils.isAndroid() ? "android" : utils.isIOS ? "ios" : "other_mobile",
                pcOsType: utils.getOsType()
              };
              var deviceInfo = {
                // ↓上报项
                deviceType: constant.isMobile ? "mobile" : constant.isBrowser ? "browser" : "unknown",
                devicePlatform: constant.isMobile ? constant.mobileOsType : constant.pcOsType,
                deviceName: utils.getDeviceName()
                //浏览器名称
              };
              var sliceUploadMethods = ["multipartInit", "multipartUpload", "multipartComplete", "multipartList", "multipartListPart", "multipartAbort"];
              var uploadApi = ["putObject", "postObject", "appendObject", "sliceUploadFile", "uploadFile", "uploadFiles"].concat(sliceUploadMethods);
              var downloadApi = ["getObject"];
              function getEventCode(apiName) {
                if (uploadApi.includes(apiName)) {
                  return "cos_upload";
                }
                if (downloadApi.includes(apiName)) {
                  return "cos_download";
                }
                return "base_service";
              }
              function camel2underline(key) {
                return key.replace(/([A-Z])/g, "_$1").toLowerCase();
              }
              function formatParams(params) {
                var formattedParams = {};
                var allReporterKeys = ["tracePlatform", "cossdkVersion", "region", "networkType", "host", "accelerate", "requestPath", "size", "httpMd5", "httpSign", "httpFull", "name", "result", "tookTime", "errorNode", "errorCode", "errorMessage", "errorRequestId", "errorStatusCode", "errorServiceName", "errorType", "traceId", "bucket", "appid", "partNumber", "retryTimes", "reqUrl", "customId", "fullError", "deviceType", "devicePlatform", "deviceName"];
                var successKeys = ["tracePlatform", "cossdkVersion", "region", "bucket", "appid", "networkType", "host", "accelerate", "requestPath", "partNumber", "size", "name", "result", "tookTime", "errorRequestId", "retryTimes", "reqUrl", "customId", "deviceType", "devicePlatform", "deviceName"];
                var reporterKeys = params.result === "Success" ? successKeys : allReporterKeys;
                for (var key in params) {
                  if (!reporterKeys.includes(key))
                    continue;
                  var formattedKey = camel2underline(key);
                  formattedParams[formattedKey] = params[key];
                }
                return formattedParams;
              }
              var Tracker = function() {
                "use strict";
                function Tracker2(opt) {
                  _classCallCheck(this, Tracker2);
                  var parent = opt.parent, traceId = opt.traceId, bucket = opt.bucket, region = opt.region, apiName = opt.apiName, fileKey = opt.fileKey, fileSize = opt.fileSize, accelerate = opt.accelerate, customId = opt.customId, delay = opt.delay, deepTracker = opt.deepTracker;
                  var appid = bucket && bucket.substr(bucket.lastIndexOf("-") + 1) || "";
                  this.parent = parent;
                  this.deepTracker = deepTracker;
                  this.delay = delay;
                  this.params = {
                    // 通用字段
                    cossdkVersion: pkg.version,
                    region,
                    networkType: "",
                    host: "",
                    accelerate: accelerate ? "Y" : "N",
                    requestPath: fileKey || "",
                    size: fileSize || -1,
                    httpMd5: 0,
                    // MD5耗时
                    httpSign: 0,
                    // 计算签名耗时
                    httpFull: 0,
                    // http请求耗时
                    name: apiName || "",
                    result: "",
                    // sdk api调用结果Success、Fail
                    tookTime: 0,
                    // 总耗时
                    errorNode: "",
                    errorCode: "",
                    errorMessage: "",
                    errorRequestId: "",
                    errorStatusCode: 0,
                    errorServiceName: "",
                    // js补充字段
                    tracePlatform: "cos-js-sdk-v5",
                    // 上报平台=js
                    traceId: traceId || utils.getUid(),
                    // 每条上报唯一标识
                    bucket,
                    appid,
                    partNumber: 0,
                    // 分块上传编号
                    retryTimes: 0,
                    // sdk内部发起的请求重试
                    reqUrl: "",
                    // 请求url
                    customId: customId || "",
                    // 业务id
                    deviceType: deviceInfo.deviceType,
                    // 设备类型 移动端浏览器、web浏览器
                    devicePlatform: deviceInfo.devicePlatform,
                    deviceName: deviceInfo.deviceName,
                    md5StartTime: 0,
                    // md5计算开始时间
                    md5EndTime: 0,
                    // md5计算结束时间
                    signStartTime: 0,
                    // 计算签名开始时间
                    signEndTime: 0,
                    // 计算签名结束时间
                    httpStartTime: 0,
                    // 发起网络请求开始时间
                    httpEndTime: 0,
                    // 网路请求结束时间
                    startTime: (/* @__PURE__ */ new Date()).getTime(),
                    // sdk api调用起始时间，不是纯网络耗时
                    endTime: 0
                    //  sdk api调用结束时间，不是纯网络耗时
                  };
                  this.beacon = getBeacon(delay);
                }
                _createClass(Tracker2, [{
                  key: "formatResult",
                  value: function formatResult(err, data) {
                    var _err$error, _err$error2, _err$error3, _err$error4, _err$error5, _err$error6;
                    var now = (/* @__PURE__ */ new Date()).getTime();
                    var tookTime = now - this.params.startTime;
                    var networkType = utils.getNetType();
                    var errorCode = err ? (err === null || err === void 0 ? void 0 : err.code) || (err === null || err === void 0 ? void 0 : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.code) || (err === null || err === void 0 ? void 0 : (_err$error2 = err.error) === null || _err$error2 === void 0 ? void 0 : _err$error2.Code) : "";
                    var errorMessage = err ? (err === null || err === void 0 ? void 0 : err.message) || (err === null || err === void 0 ? void 0 : (_err$error3 = err.error) === null || _err$error3 === void 0 ? void 0 : _err$error3.message) || (err === null || err === void 0 ? void 0 : (_err$error4 = err.error) === null || _err$error4 === void 0 ? void 0 : _err$error4.Message) : "";
                    var errorServiceName = err ? (err === null || err === void 0 ? void 0 : err.resource) || (err === null || err === void 0 ? void 0 : (_err$error5 = err.error) === null || _err$error5 === void 0 ? void 0 : _err$error5.resource) || (err === null || err === void 0 ? void 0 : (_err$error6 = err.error) === null || _err$error6 === void 0 ? void 0 : _err$error6.Resource) : "";
                    var errorStatusCode = err ? err === null || err === void 0 ? void 0 : err.statusCode : data.statusCode;
                    var requestId = err ? (err === null || err === void 0 ? void 0 : err.headers) && (err === null || err === void 0 ? void 0 : err.headers["x-cos-request-id"]) : (data === null || data === void 0 ? void 0 : data.headers) && (data === null || data === void 0 ? void 0 : data.headers["x-cos-request-id"]);
                    var errorType = err ? requestId ? "Server" : "Client" : "";
                    Object.assign(this.params, {
                      tookTime,
                      networkType,
                      httpMd5: this.params.md5EndTime - this.params.md5StartTime,
                      httpSign: this.params.signEndTime - this.params.signStartTime,
                      httpFull: this.params.httpEndTime - this.params.httpStartTime,
                      result: err ? "Fail" : "Success",
                      errorType,
                      errorCode,
                      errorStatusCode,
                      errorMessage,
                      errorServiceName,
                      errorRequestId: requestId
                    });
                    if (err && (!errorCode || !errorMessage)) {
                      this.params.fullError = err ? JSON.stringify(err) : "";
                    }
                    if (this.params.name === "getObject") {
                      this.params.size = data ? data.headers && data.headers["content-length"] : -1;
                    }
                    if (this.params.reqUrl) {
                      try {
                        var execRes = /^http(s)?:\/\/(.*?)\//.exec(this.params.reqUrl);
                        this.params.host = execRes[2];
                      } catch (e) {
                        this.params.host = this.params.reqUrl;
                      }
                    }
                    this.sendEvents();
                  }
                  // 设置当前链路的参数
                }, {
                  key: "setParams",
                  value: function setParams(params) {
                    Object.assign(this.params, params);
                  }
                  // 使用灯塔延时上报
                }, {
                  key: "sendEvents",
                  value: function sendEvents() {
                    if (sliceUploadMethods.includes(this.params.name) && !this.deepTracker) {
                      return;
                    }
                    var eventCode = getEventCode(this.params.name);
                    var formattedParams = formatParams(this.params);
                    if (!this.beacon) {
                      this.beacon = getBeacon(this.delay || 5e3);
                    }
                    if (this.delay === 0) {
                      this.beacon && this.beacon.onDirectUserAction(eventCode, formattedParams);
                    } else {
                      this.beacon && this.beacon.onUserAction(eventCode, formattedParams);
                    }
                  }
                  // 生成子实例，与父所属一个链路，可用于分块上传内部流程上报单个分块操作
                }, {
                  key: "generateSubTracker",
                  value: function generateSubTracker(subParams) {
                    Object.assign(subParams, {
                      parent: this,
                      deepTracker: this.deepTracker,
                      traceId: this.params.traceId,
                      bucket: this.params.bucket,
                      region: this.params.region,
                      fileKey: this.params.requestPath,
                      customId: this.params.customId,
                      delay: this.delay
                    });
                    return new Tracker2(subParams);
                  }
                }]);
                return Tracker2;
              }();
              module2.exports = Tracker;
            }
          ),
          /***/
          "./src/util.js": (
            /*!*********************!*\
              !*** ./src/util.js ***!
              \*********************/
            /*! no static exports found */
            /***/
            function(module2, exports2, __webpack_require__2) {
              "use strict";
              (function(process2) {
                var _typeof2 = __webpack_require__2(
                  /*! @babel/runtime/helpers/typeof */
                  "./node_modules/@babel/runtime/helpers/typeof.js"
                );
                var md5 = __webpack_require__2(
                  /*! ../lib/md5 */
                  "./lib/md5.js"
                );
                var CryptoJS = __webpack_require__2(
                  /*! ../lib/crypto */
                  "./lib/crypto.js"
                );
                var xml2json = __webpack_require__2(
                  /*! ../lib/xml2json */
                  "./lib/xml2json.js"
                );
                var json2xml = __webpack_require__2(
                  /*! ../lib/json2xml */
                  "./lib/json2xml.js"
                );
                var base64 = __webpack_require__2(
                  /*! ../lib/base64 */
                  "./lib/base64.js"
                );
                var Tracker = __webpack_require__2(
                  /*! ./tracker */
                  "./src/tracker.js"
                );
                function camSafeUrlEncode(str) {
                  return encodeURIComponent(str).replace(/!/g, "%21").replace(/'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
                }
                function getObjectKeys(obj, forKey) {
                  var list = [];
                  for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                      list.push(forKey ? camSafeUrlEncode(key).toLowerCase() : key);
                    }
                  }
                  return list.sort(function(a, b) {
                    a = a.toLowerCase();
                    b = b.toLowerCase();
                    return a === b ? 0 : a > b ? 1 : -1;
                  });
                }
                var obj2str = function obj2str2(obj, lowerCaseKey) {
                  var i, key, val;
                  var list = [];
                  var keyList = getObjectKeys(obj);
                  for (i = 0; i < keyList.length; i++) {
                    key = keyList[i];
                    val = obj[key] === void 0 || obj[key] === null ? "" : "" + obj[key];
                    key = lowerCaseKey ? camSafeUrlEncode(key).toLowerCase() : camSafeUrlEncode(key);
                    val = camSafeUrlEncode(val) || "";
                    list.push(key + "=" + val);
                  }
                  return list.join("&");
                };
                var signHeaders = ["cache-control", "content-disposition", "content-encoding", "content-length", "content-md5", "expect", "expires", "host", "if-match", "if-modified-since", "if-none-match", "if-unmodified-since", "origin", "range", "transfer-encoding"];
                var getSignHeaderObj = function getSignHeaderObj2(headers) {
                  var signHeaderObj = {};
                  for (var i in headers) {
                    var key = i.toLowerCase();
                    if (key.indexOf("x-cos-") > -1 || signHeaders.indexOf(key) > -1) {
                      signHeaderObj[i] = headers[i];
                    }
                  }
                  return signHeaderObj;
                };
                var getAuth = function getAuth2(opt) {
                  opt = opt || {};
                  var SecretId = opt.SecretId;
                  var SecretKey = opt.SecretKey;
                  var KeyTime = opt.KeyTime;
                  var method2 = (opt.method || opt.Method || "get").toLowerCase();
                  var queryParams = clone(opt.Query || opt.params || {});
                  var headers = getSignHeaderObj(clone(opt.Headers || opt.headers || {}));
                  var Key = opt.Key || "";
                  var pathname;
                  if (opt.UseRawKey) {
                    pathname = opt.Pathname || opt.pathname || "/" + Key;
                  } else {
                    pathname = opt.Pathname || opt.pathname || Key;
                    pathname.indexOf("/") !== 0 && (pathname = "/" + pathname);
                  }
                  var forceSignHost = opt.ForceSignHost === false ? false : true;
                  if (!headers.Host && !headers.host && opt.Bucket && opt.Region && forceSignHost)
                    headers.Host = opt.Bucket + ".cos." + opt.Region + ".myqcloud.com";
                  if (!SecretId)
                    throw new Error("missing param SecretId");
                  if (!SecretKey)
                    throw new Error("missing param SecretKey");
                  var now = Math.round(getSkewTime(opt.SystemClockOffset) / 1e3) - 1;
                  var exp = now;
                  var Expires = opt.Expires || opt.expires;
                  if (Expires === void 0) {
                    exp += 900;
                  } else {
                    exp += Expires * 1 || 0;
                  }
                  var qSignAlgorithm = "sha1";
                  var qAk = SecretId;
                  var qSignTime = KeyTime || now + ";" + exp;
                  var qKeyTime = KeyTime || now + ";" + exp;
                  var qHeaderList = getObjectKeys(headers, true).join(";").toLowerCase();
                  var qUrlParamList = getObjectKeys(queryParams, true).join(";").toLowerCase();
                  var signKey = CryptoJS.HmacSHA1(qKeyTime, SecretKey).toString();
                  var formatString = [method2, pathname, util.obj2str(queryParams, true), util.obj2str(headers, true), ""].join("\n");
                  var stringToSign = ["sha1", qSignTime, CryptoJS.SHA1(formatString).toString(), ""].join("\n");
                  var qSignature = CryptoJS.HmacSHA1(stringToSign, signKey).toString();
                  var authorization = ["q-sign-algorithm=" + qSignAlgorithm, "q-ak=" + qAk, "q-sign-time=" + qSignTime, "q-key-time=" + qKeyTime, "q-header-list=" + qHeaderList, "q-url-param-list=" + qUrlParamList, "q-signature=" + qSignature].join("&");
                  return authorization;
                };
                var readIntBE = function readIntBE2(chunk, size, offset) {
                  var bytes = size / 8;
                  var buf = chunk.slice(offset, offset + bytes);
                  new Uint8Array(buf).reverse();
                  return new {
                    8: Uint8Array,
                    16: Uint16Array,
                    32: Uint32Array
                  }[size](buf)[0];
                };
                var buf2str = function buf2str2(chunk, start, end, isUtf8) {
                  var buf = chunk.slice(start, end);
                  var str = "";
                  new Uint8Array(buf).forEach(function(charCode) {
                    str += String.fromCharCode(charCode);
                  });
                  if (isUtf8)
                    str = decodeURIComponent(escape(str));
                  return str;
                };
                var parseSelectPayload = function parseSelectPayload2(chunk) {
                  var header = {};
                  var body = buf2str(chunk);
                  var result = {
                    records: []
                  };
                  while (chunk.byteLength) {
                    var totalLength = readIntBE(chunk, 32, 0);
                    var headerLength = readIntBE(chunk, 32, 4);
                    var payloadRestLength = totalLength - headerLength - 16;
                    var offset = 0;
                    var content;
                    chunk = chunk.slice(12);
                    while (offset < headerLength) {
                      var headerNameLength = readIntBE(chunk, 8, offset);
                      var headerName = buf2str(chunk, offset + 1, offset + 1 + headerNameLength);
                      var headerValueLength = readIntBE(chunk, 16, offset + headerNameLength + 2);
                      var headerValue = buf2str(chunk, offset + headerNameLength + 4, offset + headerNameLength + 4 + headerValueLength);
                      header[headerName] = headerValue;
                      offset += headerNameLength + 4 + headerValueLength;
                    }
                    if (header[":event-type"] === "Records") {
                      content = buf2str(chunk, offset, offset + payloadRestLength, true);
                      result.records.push(content);
                    } else if (header[":event-type"] === "Stats") {
                      content = buf2str(chunk, offset, offset + payloadRestLength, true);
                      result.stats = util.xml2json(content).Stats;
                    } else if (header[":event-type"] === "error") {
                      var errCode = header[":error-code"];
                      var errMessage = header[":error-message"];
                      var err = new Error(errMessage);
                      err.message = errMessage;
                      err.name = err.code = errCode;
                      result.error = err;
                    } else if (["Progress", "Continuation", "End"].includes(header[":event-type"])) {
                    }
                    chunk = chunk.slice(offset + payloadRestLength + 4);
                  }
                  return {
                    payload: result.records.join(""),
                    body
                  };
                };
                var getSourceParams = function getSourceParams2(source) {
                  var parser = this.options.CopySourceParser;
                  if (parser)
                    return parser(source);
                  var m = source.match(/^([^.]+-\d+)\.cos(v6|-cdc|-cdz|-internal)?\.([^.]+)\.((myqcloud\.com)|(tencentcos\.cn))\/(.+)$/);
                  if (!m)
                    return null;
                  return {
                    Bucket: m[1],
                    Region: m[3],
                    Key: m[7]
                  };
                };
                var noop = function noop2() {
                };
                var clearKey = function clearKey2(obj) {
                  var retObj = {};
                  for (var key in obj) {
                    if (obj.hasOwnProperty(key) && obj[key] !== void 0 && obj[key] !== null) {
                      retObj[key] = obj[key];
                    }
                  }
                  return retObj;
                };
                var readAsBinaryString = function readAsBinaryString2(blob, callback) {
                  var readFun;
                  var fr = new FileReader();
                  if (FileReader.prototype.readAsBinaryString) {
                    readFun = FileReader.prototype.readAsBinaryString;
                    fr.onload = function() {
                      callback(this.result);
                    };
                  } else if (FileReader.prototype.readAsArrayBuffer) {
                    readFun = function readFun2(fileData) {
                      var binary = "";
                      var pt = this;
                      var reader = new FileReader();
                      reader.onload = function(e) {
                        var bytes = new Uint8Array(reader.result);
                        var length = bytes.byteLength;
                        for (var i = 0; i < length; i++) {
                          binary += String.fromCharCode(bytes[i]);
                        }
                        callback(binary);
                      };
                      reader.readAsArrayBuffer(fileData);
                    };
                  } else {
                    console.error("FileReader not support readAsBinaryString");
                  }
                  readFun.call(fr, blob);
                };
                var fileSliceNeedCopy = function() {
                  var compareVersion = function compareVersion2(a, b) {
                    a = a.split(".");
                    b = b.split(".");
                    for (var i = 0; i < b.length; i++) {
                      if (a[i] !== b[i]) {
                        return parseInt(a[i]) > parseInt(b[i]) ? 1 : -1;
                      }
                    }
                    return 0;
                  };
                  var check = function check2(ua) {
                    if (!ua)
                      return false;
                    var ChromeVersion = (ua.match(/Chrome\/([.\d]+)/) || [])[1];
                    var QBCoreVersion = (ua.match(/QBCore\/([.\d]+)/) || [])[1];
                    var QQBrowserVersion = (ua.match(/QQBrowser\/([.\d]+)/) || [])[1];
                    var need = ChromeVersion && compareVersion(ChromeVersion, "53.0.2785.116") < 0 && QBCoreVersion && compareVersion(QBCoreVersion, "3.53.991.400") < 0 && QQBrowserVersion && compareVersion(QQBrowserVersion, "9.0.2524.400") <= 0 || false;
                    return need;
                  };
                  return check(typeof navigator !== "undefined" && navigator.userAgent);
                }();
                var fileSlice = function fileSlice2(file, start, end, isUseToUpload, callback) {
                  var blob;
                  if (file.slice) {
                    blob = file.slice(start, end);
                  } else if (file.mozSlice) {
                    blob = file.mozSlice(start, end);
                  } else if (file.webkitSlice) {
                    blob = file.webkitSlice(start, end);
                  }
                  if (isUseToUpload && fileSliceNeedCopy) {
                    var reader = new FileReader();
                    reader.onload = function(e) {
                      blob = null;
                      callback(new Blob([reader.result]));
                    };
                    reader.readAsArrayBuffer(blob);
                  } else {
                    callback(blob);
                  }
                };
                var getBodyMd5 = function getBodyMd52(UploadCheckContentMd5, Body, callback, onProgress) {
                  callback = callback || noop;
                  if (UploadCheckContentMd5) {
                    if (typeof Body === "string") {
                      callback(util.md5(Body, true));
                    } else if (Blob && Body instanceof Blob) {
                      util.getFileMd5(Body, function(err, md52) {
                        callback(md52);
                      }, onProgress);
                    } else {
                      callback();
                    }
                  } else {
                    callback();
                  }
                };
                var md5ChunkSize = 1024 * 1024;
                var getFileMd5 = function getFileMd52(blob, callback, onProgress) {
                  var size = blob.size;
                  var loaded = 0;
                  var md5ctx = md5.getCtx();
                  var next = function next2(start) {
                    if (start >= size) {
                      var hash = md5ctx.digest("hex");
                      callback(null, hash);
                      return;
                    }
                    var end = Math.min(size, start + md5ChunkSize);
                    util.fileSlice(blob, start, end, false, function(chunk) {
                      readAsBinaryString(chunk, function(content) {
                        chunk = null;
                        md5ctx = md5ctx.update(content, true);
                        loaded += content.length;
                        content = null;
                        if (onProgress)
                          onProgress({
                            loaded,
                            total: size,
                            percent: Math.round(loaded / size * 1e4) / 1e4
                          });
                        next2(start + md5ChunkSize);
                      });
                    });
                  };
                  next(0);
                };
                function clone(obj) {
                  return map(obj, function(v) {
                    return _typeof2(v) === "object" && v !== null ? clone(v) : v;
                  });
                }
                function attr(obj, name, defaultValue) {
                  return obj && name in obj ? obj[name] : defaultValue;
                }
                function extend(target, source) {
                  each(source, function(val, key) {
                    target[key] = source[key];
                  });
                  return target;
                }
                function isArray(arr) {
                  return arr instanceof Array;
                }
                function isInArray(arr, item) {
                  var flag = false;
                  for (var i = 0; i < arr.length; i++) {
                    if (item === arr[i]) {
                      flag = true;
                      break;
                    }
                  }
                  return flag;
                }
                function makeArray(arr) {
                  return isArray(arr) ? arr : [arr];
                }
                function each(obj, fn) {
                  for (var i in obj) {
                    if (obj.hasOwnProperty(i)) {
                      fn(obj[i], i);
                    }
                  }
                }
                function map(obj, fn) {
                  var o = isArray(obj) ? [] : {};
                  for (var i in obj) {
                    if (obj.hasOwnProperty(i)) {
                      o[i] = fn(obj[i], i);
                    }
                  }
                  return o;
                }
                function filter(obj, fn) {
                  var iaArr = isArray(obj);
                  var o = iaArr ? [] : {};
                  for (var i in obj) {
                    if (obj.hasOwnProperty(i)) {
                      if (fn(obj[i], i)) {
                        if (iaArr) {
                          o.push(obj[i]);
                        } else {
                          o[i] = obj[i];
                        }
                      }
                    }
                  }
                  return o;
                }
                var b64 = function b642(str) {
                  var i, len, char, res = "";
                  for (i = 0, len = str.length / 2; i < len; i++) {
                    char = parseInt(str[i * 2] + str[i * 2 + 1], 16);
                    res += String.fromCharCode(char);
                  }
                  return btoa(res);
                };
                var uuid = function uuid2() {
                  var S4 = function S42() {
                    return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
                  };
                  return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
                };
                var hasMissingParams = function hasMissingParams2(apiName, params) {
                  var Bucket = params.Bucket;
                  var Region = params.Region;
                  var Key = params.Key;
                  var Domain = this.options.Domain;
                  var checkBucket = !Domain || typeof Domain === "string" && Domain.indexOf("{Bucket}") > -1;
                  var checkRegion = !Domain || typeof Domain === "string" && Domain.indexOf("{Region}") > -1;
                  if (apiName.indexOf("Bucket") > -1 || apiName === "deleteMultipleObject" || apiName === "multipartList" || apiName === "listObjectVersions") {
                    if (checkBucket && !Bucket)
                      return "Bucket";
                    if (checkRegion && !Region)
                      return "Region";
                  } else if (apiName.indexOf("Object") > -1 || apiName.indexOf("multipart") > -1 || apiName === "sliceUploadFile" || apiName === "abortUploadTask") {
                    if (checkBucket && !Bucket)
                      return "Bucket";
                    if (checkRegion && !Region)
                      return "Region";
                    if (!Key)
                      return "Key";
                  }
                  return false;
                };
                var formatParams = function formatParams2(apiName, params) {
                  params = extend({}, params);
                  if (apiName !== "getAuth" && apiName !== "getV4Auth" && apiName !== "getObjectUrl") {
                    var Headers = params.Headers || {};
                    if (params && _typeof2(params) === "object") {
                      (function() {
                        for (var key in params) {
                          if (params.hasOwnProperty(key) && key.indexOf("x-cos-") > -1) {
                            Headers[key] = params[key];
                          }
                        }
                      })();
                      var headerMap = {
                        // params headers
                        "x-cos-mfa": "MFA",
                        "Content-MD5": "ContentMD5",
                        "Content-Length": "ContentLength",
                        "Content-Type": "ContentType",
                        Expect: "Expect",
                        Expires: "Expires",
                        "Cache-Control": "CacheControl",
                        "Content-Disposition": "ContentDisposition",
                        "Content-Encoding": "ContentEncoding",
                        Range: "Range",
                        "If-Modified-Since": "IfModifiedSince",
                        "If-Unmodified-Since": "IfUnmodifiedSince",
                        "If-Match": "IfMatch",
                        "If-None-Match": "IfNoneMatch",
                        "x-cos-copy-source": "CopySource",
                        "x-cos-copy-source-Range": "CopySourceRange",
                        "x-cos-metadata-directive": "MetadataDirective",
                        "x-cos-copy-source-If-Modified-Since": "CopySourceIfModifiedSince",
                        "x-cos-copy-source-If-Unmodified-Since": "CopySourceIfUnmodifiedSince",
                        "x-cos-copy-source-If-Match": "CopySourceIfMatch",
                        "x-cos-copy-source-If-None-Match": "CopySourceIfNoneMatch",
                        "x-cos-acl": "ACL",
                        "x-cos-grant-read": "GrantRead",
                        "x-cos-grant-write": "GrantWrite",
                        "x-cos-grant-full-control": "GrantFullControl",
                        "x-cos-grant-read-acp": "GrantReadAcp",
                        "x-cos-grant-write-acp": "GrantWriteAcp",
                        "x-cos-storage-class": "StorageClass",
                        "x-cos-traffic-limit": "TrafficLimit",
                        "x-cos-mime-limit": "MimeLimit",
                        // SSE-C
                        "x-cos-server-side-encryption-customer-algorithm": "SSECustomerAlgorithm",
                        "x-cos-server-side-encryption-customer-key": "SSECustomerKey",
                        "x-cos-server-side-encryption-customer-key-MD5": "SSECustomerKeyMD5",
                        // SSE-COS、SSE-KMS
                        "x-cos-server-side-encryption": "ServerSideEncryption",
                        "x-cos-server-side-encryption-cos-kms-key-id": "SSEKMSKeyId",
                        "x-cos-server-side-encryption-context": "SSEContext",
                        // 上传时图片处理
                        "Pic-Operations": "PicOperations"
                      };
                      util.each(headerMap, function(paramKey, headerKey) {
                        if (params[paramKey] !== void 0) {
                          Headers[headerKey] = params[paramKey];
                        }
                      });
                      params.Headers = clearKey(Headers);
                    }
                  }
                  return params;
                };
                var apiWrapper = function apiWrapper2(apiName, apiFn) {
                  return function(params, callback) {
                    var self2 = this;
                    if (typeof params === "function") {
                      callback = params;
                      params = {};
                    }
                    params = formatParams(apiName, params);
                    var tracker;
                    if (self2.options.EnableTracker) {
                      if (params.calledBySdk === "sliceUploadFile") {
                        tracker = params.tracker && params.tracker.generateSubTracker({
                          apiName
                        });
                      } else if (["uploadFile", "uploadFiles"].includes(apiName)) {
                        tracker = null;
                      } else {
                        var fileSize = -1;
                        if (params.Body) {
                          fileSize = typeof params.Body === "string" ? params.Body.length : params.Body.size || params.Body.byteLength || -1;
                        }
                        tracker = new Tracker({
                          bucket: params.Bucket,
                          region: params.Region,
                          apiName,
                          fileKey: params.Key,
                          fileSize,
                          deepTracker: self2.options.DeepTracker,
                          customId: self2.options.CustomId,
                          delay: self2.options.TrackerDelay
                        });
                      }
                    }
                    params.tracker = tracker;
                    var formatResult = function formatResult2(result) {
                      if (result && result.headers) {
                        result.headers["x-cos-request-id"] && (result.RequestId = result.headers["x-cos-request-id"]);
                        result.headers["x-ci-request-id"] && (result.RequestId = result.headers["x-ci-request-id"]);
                        result.headers["x-cos-version-id"] && (result.VersionId = result.headers["x-cos-version-id"]);
                        result.headers["x-cos-delete-marker"] && (result.DeleteMarker = result.headers["x-cos-delete-marker"]);
                      }
                      return result;
                    };
                    var _callback = function _callback2(err, data) {
                      tracker && tracker.formatResult(err, data);
                      callback && callback(formatResult(err), formatResult(data));
                    };
                    var checkParams = function checkParams2() {
                      if (apiName !== "getService" && apiName !== "abortUploadTask") {
                        var missingResult = hasMissingParams.call(self2, apiName, params);
                        if (missingResult) {
                          return "missing param " + missingResult;
                        }
                        if (params.Region) {
                          if (self2.options.CompatibilityMode) {
                            if (!/^([a-z\d-.]+)$/.test(params.Region)) {
                              return "Region format error.";
                            }
                          } else {
                            if (params.Region.indexOf("cos.") > -1) {
                              return 'param Region should not be start with "cos."';
                            } else if (!/^([a-z\d-]+)$/.test(params.Region)) {
                              return "Region format error.";
                            }
                          }
                          if (!self2.options.CompatibilityMode && params.Region.indexOf("-") === -1 && params.Region !== "yfb" && params.Region !== "default" && params.Region !== "accelerate") {
                            console.warn("warning: param Region format error, find help here: https://cloud.tencent.com/document/product/436/6224");
                          }
                        }
                        if (params.Bucket) {
                          if (!/^([a-z\d-]+)-(\d+)$/.test(params.Bucket)) {
                            if (params.AppId) {
                              params.Bucket = params.Bucket + "-" + params.AppId;
                            } else if (self2.options.AppId) {
                              params.Bucket = params.Bucket + "-" + self2.options.AppId;
                            } else {
                              return 'Bucket should format as "test-1250000000".';
                            }
                          }
                          if (params.AppId) {
                            console.warn('warning: AppId has been deprecated, Please put it at the end of parameter Bucket(E.g Bucket:"test-1250000000" ).');
                            delete params.AppId;
                          }
                        }
                        if (!self2.options.UseRawKey && params.Key && params.Key.substr(0, 1) === "/") {
                          params.Key = params.Key.substr(1);
                        }
                      }
                    };
                    var errMsg = checkParams();
                    var isSync = ["getAuth", "getObjectUrl"].includes(apiName);
                    if (typeof Promise === "function" && !isSync && !callback) {
                      return new Promise(function(resolve, reject) {
                        callback = function callback2(err, data) {
                          err ? reject(err) : resolve(data);
                        };
                        if (errMsg)
                          return _callback(util.error(new Error(errMsg)));
                        apiFn.call(self2, params, _callback);
                      });
                    } else {
                      if (errMsg)
                        return _callback(util.error(new Error(errMsg)));
                      var res = apiFn.call(self2, params, _callback);
                      if (isSync)
                        return res;
                    }
                  };
                };
                var throttleOnProgress = function throttleOnProgress2(total, onProgress) {
                  var self2 = this;
                  var size0 = 0;
                  var size1 = 0;
                  var time0 = Date.now();
                  var time1;
                  var timer;
                  function update() {
                    timer = 0;
                    if (onProgress && typeof onProgress === "function") {
                      time1 = Date.now();
                      var speed = Math.max(0, Math.round((size1 - size0) / ((time1 - time0) / 1e3) * 100) / 100) || 0;
                      var percent;
                      if (size1 === 0 && total === 0) {
                        percent = 1;
                      } else {
                        percent = Math.floor(size1 / total * 100) / 100 || 0;
                      }
                      time0 = time1;
                      size0 = size1;
                      try {
                        onProgress({
                          loaded: size1,
                          total,
                          speed,
                          percent
                        });
                      } catch (e) {
                      }
                    }
                  }
                  return function(info, immediately) {
                    if (info) {
                      size1 = info.loaded;
                      total = info.total;
                    }
                    if (immediately) {
                      clearTimeout(timer);
                      update();
                    } else {
                      if (timer)
                        return;
                      timer = setTimeout(update, self2.options.ProgressInterval);
                    }
                  };
                };
                var getFileSize = function getFileSize2(api, params, callback) {
                  var size;
                  if (typeof params.Body === "string") {
                    params.Body = new Blob([params.Body], {
                      type: "text/plain"
                    });
                  } else if (params.Body instanceof ArrayBuffer) {
                    params.Body = new Blob([params.Body]);
                  }
                  if (params.Body && (params.Body instanceof Blob || params.Body.toString() === "[object File]" || params.Body.toString() === "[object Blob]")) {
                    size = params.Body.size;
                  } else {
                    callback(util.error(new Error("params body format error, Only allow File|Blob|String.")));
                    return;
                  }
                  params.ContentLength = size;
                  callback(null, size);
                };
                var getSkewTime = function getSkewTime2(offset) {
                  return Date.now() + (offset || 0);
                };
                var error = function error2(err, opt) {
                  var sourceErr = err;
                  err.message = err.message || null;
                  if (typeof opt === "string") {
                    err.error = opt;
                    err.message = opt;
                  } else if (_typeof2(opt) === "object" && opt !== null) {
                    extend(err, opt);
                    if (opt.code || opt.name)
                      err.code = opt.code || opt.name;
                    if (opt.message)
                      err.message = opt.message;
                    if (opt.stack)
                      err.stack = opt.stack;
                  }
                  if (typeof Object.defineProperty === "function") {
                    Object.defineProperty(err, "name", {
                      writable: true,
                      enumerable: false
                    });
                    Object.defineProperty(err, "message", {
                      enumerable: true
                    });
                  }
                  err.name = opt && opt.name || err.name || err.code || "Error";
                  if (!err.code)
                    err.code = err.name;
                  if (!err.error)
                    err.error = clone(sourceErr);
                  return err;
                };
                var isWebWorker = function isWebWorker2() {
                  return (typeof globalThis === "undefined" ? "undefined" : _typeof2(globalThis)) === "object" && (globalThis.constructor.name === "DedicatedWorkerGlobalScope" || globalThis.FileReaderSync);
                };
                var isNode = function isNode2() {
                  return (typeof window === "undefined" ? "undefined" : _typeof2(window)) !== "object" && (typeof process2 === "undefined" ? "undefined" : _typeof2(process2)) === "object" && true && !isWebWorker();
                };
                var isCIHost = function isCIHost2(url) {
                  return /^https?:\/\/([^/]+\.)?ci\.[^/]+/.test(url);
                };
                var isIOS2 = function() {
                  if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) !== "object") {
                    return false;
                  }
                  var u = navigator.userAgent;
                  var isIOS3 = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
                  return isIOS3;
                }();
                var isQQ = function() {
                  if ((typeof navigator === "undefined" ? "undefined" : _typeof2(navigator)) !== "object") {
                    return false;
                  }
                  return /\sQQ/i.test(navigator.userAgent);
                }();
                var encodeBase64 = function encodeBase642(str, safe) {
                  var base64Str = base64.encode(str);
                  if (safe) {
                    base64Str = base64Str.replaceAll("+", "-").replaceAll("/", "_").replaceAll("=", "");
                  }
                  return base64Str;
                };
                var util = {
                  noop,
                  formatParams,
                  apiWrapper,
                  xml2json,
                  json2xml,
                  md5,
                  clearKey,
                  fileSlice,
                  getBodyMd5,
                  getFileMd5,
                  b64,
                  extend,
                  isArray,
                  isInArray,
                  makeArray,
                  each,
                  map,
                  filter,
                  clone,
                  attr,
                  uuid,
                  camSafeUrlEncode,
                  throttleOnProgress,
                  getFileSize,
                  getSkewTime,
                  error,
                  obj2str,
                  getAuth,
                  parseSelectPayload,
                  getSourceParams,
                  isBrowser: true,
                  isNode,
                  isCIHost,
                  isIOS_QQ: isIOS2 && isQQ,
                  encodeBase64
                };
                module2.exports = util;
              }).call(this, __webpack_require__2(
                /*! ./../node_modules/process/browser.js */
                "./node_modules/process/browser.js"
              ));
            }
          )
          /******/
        })
      );
    });
  }
});
export default require_cos_js_sdk_v5();
//# sourceMappingURL=cos-js-sdk-v5.js.map
