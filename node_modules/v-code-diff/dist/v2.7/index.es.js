(function(){"use strict";try{if(typeof document!="undefined"){var o=document.createElement("style");o.appendChild(document.createTextNode(".code-diff-view{--color-canvas-default-transparent: rgba(255,255,255,0);--color-page-header-bg: #f6f8fa;--color-marketing-icon-primary: #218bff;--color-marketing-icon-secondary: #54aeff;--color-diff-blob-addition-num-text: #24292f;--color-diff-blob-addition-fg: #24292f;--color-diff-blob-addition-num-bg: #ccffd8;--color-diff-blob-addition-line-bg: #e6ffec;--color-diff-blob-addition-word-bg: #abf2bc;--color-diff-blob-deletion-num-text: #24292f;--color-diff-blob-deletion-fg: #24292f;--color-diff-blob-deletion-num-bg: #ffd7d5;--color-diff-blob-deletion-line-bg: #ffebe9;--color-diff-blob-deletion-word-bg: rgba(255,129,130,.4);--color-diff-blob-hunk-num-bg: rgba(84,174,255,.4);--color-diff-blob-expander-icon: #57606a;--color-diff-blob-selected-line-highlight-mix-blend-mode: multiply;--color-diffstat-deletion-border: rgba(27,31,36,.15);--color-diffstat-addition-border: rgba(27,31,36,.15);--color-diffstat-addition-bg: #2da44e;--color-search-keyword-hl: #fff8c5;--color-prettylights-syntax-comment: #6e7781;--color-prettylights-syntax-constant: #0550ae;--color-prettylights-syntax-entity: #8250df;--color-prettylights-syntax-storage-modifier-import: #24292f;--color-prettylights-syntax-entity-tag: #116329;--color-prettylights-syntax-keyword: #cf222e;--color-prettylights-syntax-string: #0a3069;--color-prettylights-syntax-variable: #953800;--color-prettylights-syntax-brackethighlighter-unmatched: #82071e;--color-prettylights-syntax-invalid-illegal-text: #f6f8fa;--color-prettylights-syntax-invalid-illegal-bg: #82071e;--color-prettylights-syntax-carriage-return-text: #f6f8fa;--color-prettylights-syntax-carriage-return-bg: #cf222e;--color-prettylights-syntax-string-regexp: #116329;--color-prettylights-syntax-markup-list: #3b2300;--color-prettylights-syntax-markup-heading: #0550ae;--color-prettylights-syntax-markup-italic: #24292f;--color-prettylights-syntax-markup-bold: #24292f;--color-prettylights-syntax-markup-deleted-text: #82071e;--color-prettylights-syntax-markup-deleted-bg: #ffebe9;--color-prettylights-syntax-markup-inserted-text: #116329;--color-prettylights-syntax-markup-inserted-bg: #dafbe1;--color-prettylights-syntax-markup-changed-text: #953800;--color-prettylights-syntax-markup-changed-bg: #ffd8b5;--color-prettylights-syntax-markup-ignored-text: #eaeef2;--color-prettylights-syntax-markup-ignored-bg: #0550ae;--color-prettylights-syntax-meta-diff-range: #8250df;--color-prettylights-syntax-brackethighlighter-angle: #57606a;--color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;--color-prettylights-syntax-constant-other-reference-link: #0a3069;--color-codemirror-text: #24292f;--color-codemirror-bg: #ffffff;--color-codemirror-gutters-bg: #ffffff;--color-codemirror-guttermarker-text: #ffffff;--color-codemirror-guttermarker-subtle-text: #6e7781;--color-codemirror-linenumber-text: #57606a;--color-codemirror-cursor: #24292f;--color-codemirror-selection-bg: rgba(84,174,255,.4);--color-codemirror-activeline-bg: rgba(234,238,242,.5);--color-codemirror-matchingbracket-text: #24292f;--color-codemirror-lines-bg: #ffffff;--color-codemirror-syntax-comment: #24292f;--color-codemirror-syntax-constant: #0550ae;--color-codemirror-syntax-entity: #8250df;--color-codemirror-syntax-keyword: #cf222e;--color-codemirror-syntax-storage: #cf222e;--color-codemirror-syntax-string: #0a3069;--color-codemirror-syntax-support: #0550ae;--color-codemirror-syntax-variable: #953800;--color-checks-bg: #24292f;--color-checks-run-border-width: 0px;--color-checks-container-border-width: 0px;--color-checks-text-primary: #f6f8fa;--color-checks-text-secondary: #8c959f;--color-checks-text-link: #54aeff;--color-checks-btn-icon: #afb8c1;--color-checks-btn-hover-icon: #f6f8fa;--color-checks-btn-hover-bg: rgba(255,255,255,.125);--color-checks-input-text: #eaeef2;--color-checks-input-placeholder-text: #8c959f;--color-checks-input-focus-text: #8c959f;--color-checks-input-bg: #32383f;--color-checks-input-shadow: none;--color-checks-donut-error: #fa4549;--color-checks-donut-pending: #bf8700;--color-checks-donut-success: #2da44e;--color-checks-donut-neutral: #afb8c1;--color-checks-dropdown-text: #afb8c1;--color-checks-dropdown-bg: #32383f;--color-checks-dropdown-border: #424a53;--color-checks-dropdown-shadow: rgba(27,31,36,.3);--color-checks-dropdown-hover-text: #f6f8fa;--color-checks-dropdown-hover-bg: #424a53;--color-checks-dropdown-btn-hover-text: #f6f8fa;--color-checks-dropdown-btn-hover-bg: #32383f;--color-checks-scrollbar-thumb-bg: #57606a;--color-checks-header-label-text: #d0d7de;--color-checks-header-label-open-text: #f6f8fa;--color-checks-header-border: #32383f;--color-checks-header-icon: #8c959f;--color-checks-line-text: #d0d7de;--color-checks-line-num-text: rgba(140,149,159,.75);--color-checks-line-timestamp-text: #8c959f;--color-checks-line-hover-bg: #32383f;--color-checks-line-selected-bg: rgba(33,139,255,.15);--color-checks-line-selected-num-text: #54aeff;--color-checks-line-dt-fm-text: #24292f;--color-checks-line-dt-fm-bg: #9a6700;--color-checks-gate-bg: rgba(125,78,0,.15);--color-checks-gate-text: #d0d7de;--color-checks-gate-waiting-text: #d4a72c;--color-checks-step-header-open-bg: #32383f;--color-checks-step-error-text: #ff8182;--color-checks-step-warning-text: #d4a72c;--color-checks-logline-text: #8c959f;--color-checks-logline-num-text: rgba(140,149,159,.75);--color-checks-logline-debug-text: #c297ff;--color-checks-logline-error-text: #d0d7de;--color-checks-logline-error-num-text: #ff8182;--color-checks-logline-error-bg: rgba(164,14,38,.15);--color-checks-logline-warning-text: #d0d7de;--color-checks-logline-warning-num-text: #d4a72c;--color-checks-logline-warning-bg: rgba(125,78,0,.15);--color-checks-logline-command-text: #54aeff;--color-checks-logline-section-text: #4ac26b;--color-checks-ansi-black: #24292f;--color-checks-ansi-black-bright: #32383f;--color-checks-ansi-white: #d0d7de;--color-checks-ansi-white-bright: #d0d7de;--color-checks-ansi-gray: #8c959f;--color-checks-ansi-red: #ff8182;--color-checks-ansi-red-bright: #ffaba8;--color-checks-ansi-green: #4ac26b;--color-checks-ansi-green-bright: #6fdd8b;--color-checks-ansi-yellow: #d4a72c;--color-checks-ansi-yellow-bright: #eac54f;--color-checks-ansi-blue: #54aeff;--color-checks-ansi-blue-bright: #80ccff;--color-checks-ansi-magenta: #c297ff;--color-checks-ansi-magenta-bright: #d8b9ff;--color-checks-ansi-cyan: #76e3ea;--color-checks-ansi-cyan-bright: #b3f0ff;--color-project-header-bg: #24292f;--color-project-sidebar-bg: #ffffff;--color-project-gradient-in: #ffffff;--color-project-gradient-out: rgba(255,255,255,0);--color-mktg-btn-bg: #1b1f23;--color-mktg-btn-shadow-outline: rgb(0 0 0 / 15%) 0 0 0 1px inset;--color-mktg-btn-shadow-focus: rgb(0 0 0 / 15%) 0 0 0 4px;--color-mktg-btn-shadow-hover: 0 3px 2px rgba(0, 0, 0, .07), 0 7px 5px rgba(0, 0, 0, .04), 0 12px 10px rgba(0, 0, 0, .03), 0 22px 18px rgba(0, 0, 0, .03), 0 42px 33px rgba(0, 0, 0, .02), 0 100px 80px rgba(0, 0, 0, .02);--color-mktg-btn-shadow-hover-muted: rgb(0 0 0 / 70%) 0 0 0 2px inset;--color-avatar-bg: #ffffff;--color-avatar-border: rgba(27,31,36,.15);--color-avatar-stack-fade: #afb8c1;--color-avatar-stack-fade-more: #d0d7de;--color-avatar-child-shadow: -2px -2px 0 rgba(255,255,255,.8);--color-topic-tag-border: rgba(0,0,0,0);--color-counter-border: rgba(0,0,0,0);--color-select-menu-backdrop-border: rgba(0,0,0,0);--color-select-menu-tap-highlight: rgba(175,184,193,.5);--color-select-menu-tap-focus-bg: #b6e3ff;--color-overlay-shadow: 0 1px 3px rgba(27,31,36,.12), 0 8px 24px rgba(66,74,83,.12);--color-header-text: rgba(255,255,255,.7);--color-header-bg: #24292f;--color-header-divider: #57606a;--color-header-logo: #ffffff;--color-header-search-bg: #24292f;--color-header-search-border: #57606a;--color-sidenav-selected-bg: #ffffff;--color-menu-bg-active: rgba(0,0,0,0);--color-input-disabled-bg: rgba(175,184,193,.2);--color-timeline-badge-bg: #eaeef2;--color-ansi-black: #24292f;--color-ansi-black-bright: #57606a;--color-ansi-white: #6e7781;--color-ansi-white-bright: #8c959f;--color-ansi-gray: #6e7781;--color-ansi-red: #cf222e;--color-ansi-red-bright: #a40e26;--color-ansi-green: #116329;--color-ansi-green-bright: #1a7f37;--color-ansi-yellow: #4d2d00;--color-ansi-yellow-bright: #633c01;--color-ansi-blue: #0969da;--color-ansi-blue-bright: #218bff;--color-ansi-magenta: #8250df;--color-ansi-magenta-bright: #a475f9;--color-ansi-cyan: #1b7c83;--color-ansi-cyan-bright: #3192aa;--color-btn-text: #24292f;--color-btn-bg: #f6f8fa;--color-btn-border: rgba(27,31,36,.15);--color-btn-shadow: 0 1px 0 rgba(27,31,36,.04);--color-btn-inset-shadow: inset 0 1px 0 rgba(255,255,255,.25);--color-btn-hover-bg: #f3f4f6;--color-btn-hover-border: rgba(27,31,36,.15);--color-btn-active-bg: hsla(220,14%,93%,1);--color-btn-active-border: rgba(27,31,36,.15);--color-btn-selected-bg: hsla(220,14%,94%,1);--color-btn-focus-bg: #f6f8fa;--color-btn-focus-border: rgba(27,31,36,.15);--color-btn-focus-shadow: 0 0 0 3px rgba(9,105,218,.3);--color-btn-shadow-active: inset 0 .15em .3em rgba(27,31,36,.15);--color-btn-shadow-input-focus: 0 0 0 .2em rgba(9,105,218,.3);--color-btn-counter-bg: rgba(27,31,36,.08);--color-btn-primary-text: #ffffff;--color-btn-primary-bg: #2da44e;--color-btn-primary-border: rgba(27,31,36,.15);--color-btn-primary-shadow: 0 1px 0 rgba(27,31,36,.1);--color-btn-primary-inset-shadow: inset 0 1px 0 rgba(255,255,255,.03);--color-btn-primary-hover-bg: #2c974b;--color-btn-primary-hover-border: rgba(27,31,36,.15);--color-btn-primary-selected-bg: hsla(137,55%,36%,1);--color-btn-primary-selected-shadow: inset 0 1px 0 rgba(0,45,17,.2);--color-btn-primary-disabled-text: rgba(255,255,255,.8);--color-btn-primary-disabled-bg: #94d3a2;--color-btn-primary-disabled-border: rgba(27,31,36,.15);--color-btn-primary-focus-bg: #2da44e;--color-btn-primary-focus-border: rgba(27,31,36,.15);--color-btn-primary-focus-shadow: 0 0 0 3px rgba(45,164,78,.4);--color-btn-primary-icon: rgba(255,255,255,.8);--color-btn-primary-counter-bg: rgba(255,255,255,.2);--color-btn-outline-text: #0969da;--color-btn-outline-hover-text: #ffffff;--color-btn-outline-hover-bg: #0969da;--color-btn-outline-hover-border: rgba(27,31,36,.15);--color-btn-outline-hover-shadow: 0 1px 0 rgba(27,31,36,.1);--color-btn-outline-hover-inset-shadow: inset 0 1px 0 rgba(255,255,255,.03);--color-btn-outline-hover-counter-bg: rgba(255,255,255,.2);--color-btn-outline-selected-text: #ffffff;--color-btn-outline-selected-bg: hsla(212,92%,42%,1);--color-btn-outline-selected-border: rgba(27,31,36,.15);--color-btn-outline-selected-shadow: inset 0 1px 0 rgba(0,33,85,.2);--color-btn-outline-disabled-text: rgba(9,105,218,.5);--color-btn-outline-disabled-bg: #f6f8fa;--color-btn-outline-disabled-counter-bg: rgba(9,105,218,.05);--color-btn-outline-focus-border: rgba(27,31,36,.15);--color-btn-outline-focus-shadow: 0 0 0 3px rgba(5,80,174,.4);--color-btn-outline-counter-bg: rgba(9,105,218,.1);--color-btn-danger-text: #cf222e;--color-btn-danger-hover-text: #ffffff;--color-btn-danger-hover-bg: #a40e26;--color-btn-danger-hover-border: rgba(27,31,36,.15);--color-btn-danger-hover-shadow: 0 1px 0 rgba(27,31,36,.1);--color-btn-danger-hover-inset-shadow: inset 0 1px 0 rgba(255,255,255,.03);--color-btn-danger-hover-counter-bg: rgba(255,255,255,.2);--color-btn-danger-selected-text: #ffffff;--color-btn-danger-selected-bg: hsla(356,72%,44%,1);--color-btn-danger-selected-border: rgba(27,31,36,.15);--color-btn-danger-selected-shadow: inset 0 1px 0 rgba(76,0,20,.2);--color-btn-danger-disabled-text: rgba(207,34,46,.5);--color-btn-danger-disabled-bg: #f6f8fa;--color-btn-danger-disabled-counter-bg: rgba(207,34,46,.05);--color-btn-danger-focus-border: rgba(27,31,36,.15);--color-btn-danger-focus-shadow: 0 0 0 3px rgba(164,14,38,.4);--color-btn-danger-counter-bg: rgba(207,34,46,.1);--color-btn-danger-icon: #cf222e;--color-btn-danger-hover-icon: #ffffff;--color-underlinenav-icon: #6e7781;--color-underlinenav-border-hover: rgba(175,184,193,.2);--color-action-list-item-inline-divider: rgba(208,215,222,.48);--color-action-list-item-default-hover-bg: rgba(208,215,222,.32);--color-action-list-item-default-hover-border: rgba(0,0,0,0);--color-action-list-item-default-active-bg: rgba(208,215,222,.48);--color-action-list-item-default-active-border: rgba(0,0,0,0);--color-action-list-item-default-selected-bg: rgba(208,215,222,.24);--color-action-list-item-danger-hover-bg: rgba(255,235,233,.64);--color-action-list-item-danger-active-bg: #ffebe9;--color-action-list-item-danger-hover-text: #cf222e;--color-switch-track-bg: #eaeef2;--color-switch-track-border: #afb8c1;--color-switch-track-checked-bg: #ddf4ff;--color-switch-track-checked-hover-bg: #b6e3ff;--color-switch-track-checked-active-bg: #80ccff;--color-switch-track-checked-border: #54aeff;--color-switch-knob-checked-bg: #0969da;--color-switch-knob-checked-disabled-bg: #6e7781;--color-segmented-control-bg: #eaeef2;--color-segmented-control-button-hover-bg: rgba(175,184,193,.2);--color-segmented-control-button-active-bg: rgba(175,184,193,.4);--color-segmented-control-button-selected-border: #6e7781;--color-fg-default: #24292f;--color-fg-muted: #57606a;--color-fg-subtle: #6e7781;--color-fg-on-emphasis: #ffffff;--color-canvas-default: #ffffff;--color-canvas-overlay: #ffffff;--color-canvas-inset: #f6f8fa;--color-canvas-subtle: #f6f8fa;--color-border-default: #d0d7de;--color-border-muted: hsla(210,18%,87%,1);--color-border-subtle: rgba(27,31,36,.15);--color-shadow-small: 0 1px 0 rgba(27,31,36,.04);--color-shadow-medium: 0 3px 6px rgba(140,149,159,.15);--color-shadow-large: 0 8px 24px rgba(140,149,159,.2);--color-shadow-extra-large: 0 12px 28px rgba(140,149,159,.3);--color-neutral-emphasis-plus: #24292f;--color-neutral-emphasis: #6e7781;--color-neutral-muted: rgba(175,184,193,.2);--color-neutral-subtle: rgba(234,238,242,.5);--color-accent-fg: #0969da;--color-accent-emphasis: #0969da;--color-accent-muted: rgba(84,174,255,.4);--color-accent-subtle: #ddf4ff;--color-success-fg: #1a7f37;--color-success-emphasis: #2da44e;--color-success-muted: rgba(74,194,107,.4);--color-success-subtle: #dafbe1;--color-attention-fg: #9a6700;--color-attention-emphasis: #bf8700;--color-attention-muted: rgba(212,167,44,.4);--color-attention-subtle: #fff8c5;--color-severe-fg: #bc4c00;--color-severe-emphasis: #bc4c00;--color-severe-muted: rgba(251,143,68,.4);--color-severe-subtle: #fff1e5;--color-danger-fg: #cf222e;--color-danger-emphasis: #cf222e;--color-danger-muted: rgba(255,129,130,.4);--color-danger-subtle: #ffebe9;--color-open-fg: #1a7f37;--color-open-emphasis: #2da44e;--color-open-muted: rgba(74,194,107,.4);--color-open-subtle: #dafbe1;--color-closed-fg: #cf222e;--color-closed-emphasis: #cf222e;--color-closed-muted: rgba(255,129,130,.4);--color-closed-subtle: #ffebe9;--color-done-fg: #8250df;--color-done-emphasis: #8250df;--color-done-muted: rgba(194,151,255,.4);--color-done-subtle: #fbefff;--color-sponsors-fg: #bf3989;--color-sponsors-emphasis: #bf3989;--color-sponsors-muted: rgba(255,128,200,.4);--color-sponsors-subtle: #ffeff7;--color-primer-fg-disabled: #8c959f;--color-primer-canvas-backdrop: rgba(27,31,36,.5);--color-primer-canvas-sticky: rgba(255,255,255,.95);--color-primer-border-active: #fd8c73;--color-primer-border-contrast: rgba(27,31,36,.1);--color-primer-shadow-highlight: inset 0 1px 0 rgba(255,255,255,.25);--color-primer-shadow-inset: inset 0 1px 0 rgba(208,215,222,.2);--color-primer-shadow-focus: 0 0 0 3px rgba(9,105,218,.3);--color-scale-black: #1b1f24;--color-scale-white: #ffffff;--color-scale-gray-0: #f6f8fa;--color-scale-gray-1: #eaeef2;--color-scale-gray-2: #d0d7de;--color-scale-gray-3: #afb8c1;--color-scale-gray-4: #8c959f;--color-scale-gray-5: #6e7781;--color-scale-gray-6: #57606a;--color-scale-gray-7: #424a53;--color-scale-gray-8: #32383f;--color-scale-gray-9: #24292f;--color-scale-blue-0: #ddf4ff;--color-scale-blue-1: #b6e3ff;--color-scale-blue-2: #80ccff;--color-scale-blue-3: #54aeff;--color-scale-blue-4: #218bff;--color-scale-blue-5: #0969da;--color-scale-blue-6: #0550ae;--color-scale-blue-7: #033d8b;--color-scale-blue-8: #0a3069;--color-scale-blue-9: #002155;--color-scale-green-0: #dafbe1;--color-scale-green-1: #aceebb;--color-scale-green-2: #6fdd8b;--color-scale-green-3: #4ac26b;--color-scale-green-4: #2da44e;--color-scale-green-5: #1a7f37;--color-scale-green-6: #116329;--color-scale-green-7: #044f1e;--color-scale-green-8: #003d16;--color-scale-green-9: #002d11;--color-scale-yellow-0: #fff8c5;--color-scale-yellow-1: #fae17d;--color-scale-yellow-2: #eac54f;--color-scale-yellow-3: #d4a72c;--color-scale-yellow-4: #bf8700;--color-scale-yellow-5: #9a6700;--color-scale-yellow-6: #7d4e00;--color-scale-yellow-7: #633c01;--color-scale-yellow-8: #4d2d00;--color-scale-yellow-9: #3b2300;--color-scale-orange-0: #fff1e5;--color-scale-orange-1: #ffd8b5;--color-scale-orange-2: #ffb77c;--color-scale-orange-3: #fb8f44;--color-scale-orange-4: #e16f24;--color-scale-orange-5: #bc4c00;--color-scale-orange-6: #953800;--color-scale-orange-7: #762c00;--color-scale-orange-8: #5c2200;--color-scale-orange-9: #471700;--color-scale-red-0: #ffebe9;--color-scale-red-1: #ffcecb;--color-scale-red-2: #ffaba8;--color-scale-red-3: #ff8182;--color-scale-red-4: #fa4549;--color-scale-red-5: #cf222e;--color-scale-red-6: #a40e26;--color-scale-red-7: #82071e;--color-scale-red-8: #660018;--color-scale-red-9: #4c0014;--color-scale-purple-0: #fbefff;--color-scale-purple-1: #ecd8ff;--color-scale-purple-2: #d8b9ff;--color-scale-purple-3: #c297ff;--color-scale-purple-4: #a475f9;--color-scale-purple-5: #8250df;--color-scale-purple-6: #6639ba;--color-scale-purple-7: #512a97;--color-scale-purple-8: #3e1f79;--color-scale-purple-9: #2e1461;--color-scale-pink-0: #ffeff7;--color-scale-pink-1: #ffd3eb;--color-scale-pink-2: #ffadda;--color-scale-pink-3: #ff80c8;--color-scale-pink-4: #e85aad;--color-scale-pink-5: #bf3989;--color-scale-pink-6: #99286e;--color-scale-pink-7: #772057;--color-scale-pink-8: #611347;--color-scale-pink-9: #4d0336;--color-scale-coral-0: #fff0eb;--color-scale-coral-1: #ffd6cc;--color-scale-coral-2: #ffb4a1;--color-scale-coral-3: #fd8c73;--color-scale-coral-4: #ec6547;--color-scale-coral-5: #c4432b;--color-scale-coral-6: #9e2f1c;--color-scale-coral-7: #801f0f;--color-scale-coral-8: #691105;--color-scale-coral-9: #510901}.code-diff-view{position:relative;margin-top:16px;margin-bottom:16px;border:1px solid var(--color-border-default, #ddd);border-radius:6px;overflow-y:auto}.code-diff-view *{position:static;box-sizing:border-box}.code-diff-view .file-header{background-color:var(--color-canvas-subtle);border-bottom:1px solid var(--color-border-default);padding:8px 16px;font-size:12px;font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace}.code-diff-view .file-header .file-info{display:flex;justify-content:space-between;align-items:center;margin-left:8px;height:24px}.code-diff-view .file-header .file-info .filename{font-size:13px;color:var(--color-fg-default)}.code-diff-view .file-header .file-info .diff-stat .diff-stat-added{color:var(--color-diffstat-addition-bg)}.code-diff-view .file-header .file-info .diff-stat .diff-stat-deleted{color:var(--color-danger-emphasis)}.code-diff-view table{border-spacing:0}.code-diff-view .diff-table{width:100%}.code-diff-view .diff-table .blob-num{position:relative;width:1%;min-width:50px;padding-right:10px;padding-left:10px;font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px;line-height:20px;color:var(--color-fg-subtle);text-align:right;white-space:nowrap;vertical-align:top;cursor:pointer;-webkit-user-select:none;user-select:none}.code-diff-view .diff-table .blob-num-deletion{color:var(--color-diff-blob-deletion-num-text);background-color:var(--color-diff-blob-deletion-num-bg);border-color:var(--color-danger-emphasis)}.code-diff-view .diff-table .blob-num-addition{color:var(--color-diff-blob-addition-num-text);background-color:var(--color-diff-blob-addition-num-bg);border-color:var(--color-success-emphasis)}.code-diff-view .diff-table .blob-code{position:relative;padding-right:10px;padding-left:10px;line-height:20px;vertical-align:top}.code-diff-view .diff-table .blob-code .blob-code-inner{display:table-cell;overflow:visible;font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px;color:var(--color-fg-default);word-wrap:anywhere;white-space:pre-wrap}.code-diff-view .diff-table .blob-code-deletion{background-color:var(--color-diff-blob-deletion-line-bg);outline:1px dashed transparent}.code-diff-view .diff-table .blob-code-deletion .x{color:var(--color-diff-blob-deletion-fg);background-color:var(--color-diff-blob-deletion-word-bg)}.code-diff-view .diff-table .blob-code-addition{background-color:var(--color-diff-blob-addition-line-bg);outline:1px dotted transparent}.code-diff-view .diff-table .blob-code-addition .x{color:var(--color-diff-blob-addition-fg);background-color:var(--color-diff-blob-addition-word-bg)}.code-diff-view .diff-table .blob-code-context,.code-diff-view .diff-table .blob-code-addition,.code-diff-view .diff-table .blob-code-deletion{padding-left:22px!important}.code-diff-view .diff-table .blob-code-marker:before{position:absolute;top:1px;left:8px;padding-right:8px;content:attr(data-code-marker)}.code-diff-view .diff-table .blob-num-hunk{background-color:var(--color-diff-blob-hunk-num-bg)}.code-diff-view .diff-table .blob-code-hunk{background-color:var(--color-accent-subtle)}.code-diff-view .file-diff-split{table-layout:fixed}.code-diff-view .file-diff-split .blob-code+.blob-num{border-left:1px solid var(--color-border-muted)}.code-diff-view .empty-cell{cursor:default;background-color:var(--color-neutral-subtle);border-right-color:var(--color-border-muted)}pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}.hljs{background:#fff;color:#000}.hljs-comment,.hljs-quote,.hljs-variable{color:green}.hljs-built_in,.hljs-keyword,.hljs-name,.hljs-selector-tag,.hljs-tag{color:#00f}.hljs-addition,.hljs-attribute,.hljs-literal,.hljs-section,.hljs-string,.hljs-template-tag,.hljs-template-variable,.hljs-title,.hljs-type{color:#a31515}.hljs-deletion,.hljs-meta,.hljs-selector-attr,.hljs-selector-pseudo{color:#2b91af}.hljs-doctag{color:gray}.hljs-attr{color:red}.hljs-bullet,.hljs-link,.hljs-symbol{color:#00b0e8}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}")),document.head.appendChild(o)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
import Dn, { defineComponent as de, computed as me, ref as Sn, watch as Rn } from "vue";
Dn.util.warn;
function q() {
}
q.prototype = {
  diff: function(e, o) {
    var u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, g = u.callback;
    typeof u == "function" && (g = u, u = {}), this.options = u;
    var t = this;
    function r(p) {
      return g ? (setTimeout(function() {
        g(void 0, p);
      }, 0), !0) : p;
    }
    e = this.castInput(e), o = this.castInput(o), e = this.removeEmpty(this.tokenize(e)), o = this.removeEmpty(this.tokenize(o));
    var i = o.length, s = e.length, a = 1, l = i + s;
    u.maxEditLength && (l = Math.min(l, u.maxEditLength));
    var c = [{
      newPos: -1,
      components: []
    }], f = this.extractCommon(c[0], o, e, 0);
    if (c[0].newPos + 1 >= i && f + 1 >= s)
      return r([{
        value: this.join(o),
        count: o.length
      }]);
    function h() {
      for (var p = -1 * a; p <= a; p += 2) {
        var _ = void 0, v = c[p - 1], E = c[p + 1], w = (E ? E.newPos : 0) - p;
        v && (c[p - 1] = void 0);
        var m = v && v.newPos + 1 < i, T = E && 0 <= w && w < s;
        if (!m && !T) {
          c[p] = void 0;
          continue;
        }
        if (!m || T && v.newPos < E.newPos ? (_ = On(E), t.pushComponent(_.components, void 0, !0)) : (_ = v, _.newPos++, t.pushComponent(_.components, !0, void 0)), w = t.extractCommon(_, o, e, p), _.newPos + 1 >= i && w + 1 >= s)
          return r(Ln(t, _.components, o, e, t.useLongestToken));
        c[p] = _;
      }
      a++;
    }
    if (g)
      (function p() {
        setTimeout(function() {
          if (a > l)
            return g();
          h() || p();
        }, 0);
      })();
    else
      for (; a <= l; ) {
        var d = h();
        if (d)
          return d;
      }
  },
  pushComponent: function(e, o, u) {
    var g = e[e.length - 1];
    g && g.added === o && g.removed === u ? e[e.length - 1] = {
      count: g.count + 1,
      added: o,
      removed: u
    } : e.push({
      count: 1,
      added: o,
      removed: u
    });
  },
  extractCommon: function(e, o, u, g) {
    for (var t = o.length, r = u.length, i = e.newPos, s = i - g, a = 0; i + 1 < t && s + 1 < r && this.equals(o[i + 1], u[s + 1]); )
      i++, s++, a++;
    return a && e.components.push({
      count: a
    }), e.newPos = i, s;
  },
  equals: function(e, o) {
    return this.options.comparator ? this.options.comparator(e, o) : e === o || this.options.ignoreCase && e.toLowerCase() === o.toLowerCase();
  },
  removeEmpty: function(e) {
    for (var o = [], u = 0; u < e.length; u++)
      e[u] && o.push(e[u]);
    return o;
  },
  castInput: function(e) {
    return e;
  },
  tokenize: function(e) {
    return e.split("");
  },
  join: function(e) {
    return e.join("");
  }
};
function Ln(n, e, o, u, g) {
  for (var t = 0, r = e.length, i = 0, s = 0; t < r; t++) {
    var a = e[t];
    if (a.removed) {
      if (a.value = n.join(u.slice(s, s + a.count)), s += a.count, t && e[t - 1].added) {
        var c = e[t - 1];
        e[t - 1] = e[t], e[t] = c;
      }
    } else {
      if (!a.added && g) {
        var l = o.slice(i, i + a.count);
        l = l.map(function(h, d) {
          var p = u[s + d];
          return p.length > h.length ? p : h;
        }), a.value = n.join(l);
      } else
        a.value = n.join(o.slice(i, i + a.count));
      i += a.count, a.added || (s += a.count);
    }
  }
  var f = e[r - 1];
  return r > 1 && typeof f.value == "string" && (f.added || f.removed) && n.equals("", f.value) && (e[r - 2].value += f.value, e.pop()), e;
}
function On(n) {
  return {
    newPos: n.newPos,
    components: n.components.slice(0)
  };
}
var Cn = new q();
function In(n, e, o) {
  return Cn.diff(n, e, o);
}
function kn(n, e) {
  if (typeof n == "function")
    e.callback = n;
  else if (n)
    for (var o in n)
      n.hasOwnProperty(o) && (e[o] = n[o]);
  return e;
}
var We = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, Qe = /\S/, ke = new q();
ke.equals = function(n, e) {
  return this.options.ignoreCase && (n = n.toLowerCase(), e = e.toLowerCase()), n === e || this.options.ignoreWhitespace && !Qe.test(n) && !Qe.test(e);
};
ke.tokenize = function(n) {
  for (var e = n.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), o = 0; o < e.length - 1; o++)
    !e[o + 1] && e[o + 2] && We.test(e[o]) && We.test(e[o + 2]) && (e[o] += e[o + 2], e.splice(o + 1, 2), o--);
  return e;
};
function Bn(n, e, o) {
  return o = kn(o, {
    ignoreWhitespace: !0
  }), ke.diff(n, e, o);
}
var tn = new q();
tn.tokenize = function(n) {
  var e = [], o = n.split(/(\n|\r\n)/);
  o[o.length - 1] || o.pop();
  for (var u = 0; u < o.length; u++) {
    var g = o[u];
    u % 2 && !this.options.newlineIsToken ? e[e.length - 1] += g : (this.options.ignoreWhitespace && (g = g.trim()), e.push(g));
  }
  return e;
};
var $n = new q();
$n.tokenize = function(n) {
  return n.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var Un = new q();
Un.tokenize = function(n) {
  return n.split(/([{}:;,]|\s+)/);
};
function Me(n) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Me = function(e) {
    return typeof e;
  } : Me = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Me(n);
}
var Pn = Object.prototype.toString, ue = new q();
ue.useLongestToken = !0;
ue.tokenize = tn.tokenize;
ue.castInput = function(n) {
  var e = this.options, o = e.undefinedReplacement, u = e.stringifyReplacer, g = u === void 0 ? function(t, r) {
    return typeof r == "undefined" ? o : r;
  } : u;
  return typeof n == "string" ? n : JSON.stringify(Ce(n, null, null, g), g, "  ");
};
ue.equals = function(n, e) {
  return q.prototype.equals.call(ue, n.replace(/,([\r\n])/g, "$1"), e.replace(/,([\r\n])/g, "$1"));
};
function Ce(n, e, o, u, g) {
  e = e || [], o = o || [], u && (n = u(g, n));
  var t;
  for (t = 0; t < e.length; t += 1)
    if (e[t] === n)
      return o[t];
  var r;
  if (Pn.call(n) === "[object Array]") {
    for (e.push(n), r = new Array(n.length), o.push(r), t = 0; t < n.length; t += 1)
      r[t] = Ce(n[t], e, o, u, g);
    return e.pop(), o.pop(), r;
  }
  if (n && n.toJSON && (n = n.toJSON()), Me(n) === "object" && n !== null) {
    e.push(n), r = {}, o.push(r);
    var i = [], s;
    for (s in n)
      n.hasOwnProperty(s) && i.push(s);
    for (i.sort(), t = 0; t < i.length; t += 1)
      s = i[t], r[s] = Ce(n[s], e, o, u, s);
    e.pop(), o.pop();
  } else
    r = n;
  return r;
}
var Ie = new q();
Ie.tokenize = function(n) {
  return n.slice();
};
Ie.join = Ie.removeEmpty = function(n) {
  return n;
};
var ce = {}, xn = {
  get exports() {
    return ce;
  },
  set exports(n) {
    ce = n;
  }
};
(function(n) {
  var e = function() {
    this.Diff_Timeout = 1, this.Diff_EditCost = 4, this.Match_Threshold = 0.5, this.Match_Distance = 1e3, this.Patch_DeleteThreshold = 0.5, this.Patch_Margin = 4, this.Match_MaxBits = 32;
  }, o = -1, u = 1, g = 0;
  e.Diff = function(t, r) {
    return [t, r];
  }, e.prototype.diff_main = function(t, r, i, s) {
    typeof s == "undefined" && (this.Diff_Timeout <= 0 ? s = Number.MAX_VALUE : s = new Date().getTime() + this.Diff_Timeout * 1e3);
    var a = s;
    if (t == null || r == null)
      throw new Error("Null input. (diff_main)");
    if (t == r)
      return t ? [new e.Diff(g, t)] : [];
    typeof i == "undefined" && (i = !0);
    var l = i, c = this.diff_commonPrefix(t, r), f = t.substring(0, c);
    t = t.substring(c), r = r.substring(c), c = this.diff_commonSuffix(t, r);
    var h = t.substring(t.length - c);
    t = t.substring(0, t.length - c), r = r.substring(0, r.length - c);
    var d = this.diff_compute_(t, r, l, a);
    return f && d.unshift(new e.Diff(g, f)), h && d.push(new e.Diff(g, h)), this.diff_cleanupMerge(d), d;
  }, e.prototype.diff_compute_ = function(t, r, i, s) {
    var a;
    if (!t)
      return [new e.Diff(u, r)];
    if (!r)
      return [new e.Diff(o, t)];
    var l = t.length > r.length ? t : r, c = t.length > r.length ? r : t, f = l.indexOf(c);
    if (f != -1)
      return a = [
        new e.Diff(u, l.substring(0, f)),
        new e.Diff(g, c),
        new e.Diff(
          u,
          l.substring(f + c.length)
        )
      ], t.length > r.length && (a[0][0] = a[2][0] = o), a;
    if (c.length == 1)
      return [
        new e.Diff(o, t),
        new e.Diff(u, r)
      ];
    var h = this.diff_halfMatch_(t, r);
    if (h) {
      var d = h[0], p = h[1], _ = h[2], v = h[3], E = h[4], w = this.diff_main(d, _, i, s), m = this.diff_main(p, v, i, s);
      return w.concat(
        [new e.Diff(g, E)],
        m
      );
    }
    return i && t.length > 100 && r.length > 100 ? this.diff_lineMode_(t, r, s) : this.diff_bisect_(t, r, s);
  }, e.prototype.diff_lineMode_ = function(t, r, i) {
    var s = this.diff_linesToChars_(t, r);
    t = s.chars1, r = s.chars2;
    var a = s.lineArray, l = this.diff_main(t, r, !1, i);
    this.diff_charsToLines_(l, a), this.diff_cleanupSemantic(l), l.push(new e.Diff(g, ""));
    for (var c = 0, f = 0, h = 0, d = "", p = ""; c < l.length; ) {
      switch (l[c][0]) {
        case u:
          h++, p += l[c][1];
          break;
        case o:
          f++, d += l[c][1];
          break;
        case g:
          if (f >= 1 && h >= 1) {
            l.splice(
              c - f - h,
              f + h
            ), c = c - f - h;
            for (var _ = this.diff_main(d, p, !1, i), v = _.length - 1; v >= 0; v--)
              l.splice(c, 0, _[v]);
            c = c + _.length;
          }
          h = 0, f = 0, d = "", p = "";
          break;
      }
      c++;
    }
    return l.pop(), l;
  }, e.prototype.diff_bisect_ = function(t, r, i) {
    for (var s = t.length, a = r.length, l = Math.ceil((s + a) / 2), c = l, f = 2 * l, h = new Array(f), d = new Array(f), p = 0; p < f; p++)
      h[p] = -1, d[p] = -1;
    h[c + 1] = 0, d[c + 1] = 0;
    for (var _ = s - a, v = _ % 2 != 0, E = 0, w = 0, m = 0, T = 0, D = 0; D < l && !(new Date().getTime() > i); D++) {
      for (var M = -D + E; M <= D - w; M += 2) {
        var I = c + M, R;
        M == -D || M != D && h[I - 1] < h[I + 1] ? R = h[I + 1] : R = h[I - 1] + 1;
        for (var H = R - M; R < s && H < a && t.charAt(R) == r.charAt(H); )
          R++, H++;
        if (h[I] = R, R > s)
          w += 2;
        else if (H > a)
          E += 2;
        else if (v) {
          var U = c + _ - M;
          if (U >= 0 && U < f && d[U] != -1) {
            var $ = s - d[U];
            if (R >= $)
              return this.diff_bisectSplit_(t, r, R, H, i);
          }
        }
      }
      for (var F = -D + m; F <= D - T; F += 2) {
        var U = c + F, $;
        F == -D || F != D && d[U - 1] < d[U + 1] ? $ = d[U + 1] : $ = d[U - 1] + 1;
        for (var G = $ - F; $ < s && G < a && t.charAt(s - $ - 1) == r.charAt(a - G - 1); )
          $++, G++;
        if (d[U] = $, $ > s)
          T += 2;
        else if (G > a)
          m += 2;
        else if (!v) {
          var I = c + _ - F;
          if (I >= 0 && I < f && h[I] != -1) {
            var R = h[I], H = c + R - I;
            if ($ = s - $, R >= $)
              return this.diff_bisectSplit_(t, r, R, H, i);
          }
        }
      }
    }
    return [
      new e.Diff(o, t),
      new e.Diff(u, r)
    ];
  }, e.prototype.diff_bisectSplit_ = function(t, r, i, s, a) {
    var l = t.substring(0, i), c = r.substring(0, s), f = t.substring(i), h = r.substring(s), d = this.diff_main(l, c, !1, a), p = this.diff_main(f, h, !1, a);
    return d.concat(p);
  }, e.prototype.diff_linesToChars_ = function(t, r) {
    var i = [], s = {};
    i[0] = "";
    function a(h) {
      for (var d = "", p = 0, _ = -1, v = i.length; _ < h.length - 1; ) {
        _ = h.indexOf(`
`, p), _ == -1 && (_ = h.length - 1);
        var E = h.substring(p, _ + 1);
        (s.hasOwnProperty ? s.hasOwnProperty(E) : s[E] !== void 0) ? d += String.fromCharCode(s[E]) : (v == l && (E = h.substring(p), _ = h.length), d += String.fromCharCode(v), s[E] = v, i[v++] = E), p = _ + 1;
      }
      return d;
    }
    var l = 4e4, c = a(t);
    l = 65535;
    var f = a(r);
    return { chars1: c, chars2: f, lineArray: i };
  }, e.prototype.diff_charsToLines_ = function(t, r) {
    for (var i = 0; i < t.length; i++) {
      for (var s = t[i][1], a = [], l = 0; l < s.length; l++)
        a[l] = r[s.charCodeAt(l)];
      t[i][1] = a.join("");
    }
  }, e.prototype.diff_commonPrefix = function(t, r) {
    if (!t || !r || t.charAt(0) != r.charAt(0))
      return 0;
    for (var i = 0, s = Math.min(t.length, r.length), a = s, l = 0; i < a; )
      t.substring(l, a) == r.substring(l, a) ? (i = a, l = i) : s = a, a = Math.floor((s - i) / 2 + i);
    return a;
  }, e.prototype.diff_commonSuffix = function(t, r) {
    if (!t || !r || t.charAt(t.length - 1) != r.charAt(r.length - 1))
      return 0;
    for (var i = 0, s = Math.min(t.length, r.length), a = s, l = 0; i < a; )
      t.substring(t.length - a, t.length - l) == r.substring(r.length - a, r.length - l) ? (i = a, l = i) : s = a, a = Math.floor((s - i) / 2 + i);
    return a;
  }, e.prototype.diff_commonOverlap_ = function(t, r) {
    var i = t.length, s = r.length;
    if (i == 0 || s == 0)
      return 0;
    i > s ? t = t.substring(i - s) : i < s && (r = r.substring(0, i));
    var a = Math.min(i, s);
    if (t == r)
      return a;
    for (var l = 0, c = 1; ; ) {
      var f = t.substring(a - c), h = r.indexOf(f);
      if (h == -1)
        return l;
      c += h, (h == 0 || t.substring(a - c) == r.substring(0, c)) && (l = c, c++);
    }
  }, e.prototype.diff_halfMatch_ = function(t, r) {
    if (this.Diff_Timeout <= 0)
      return null;
    var i = t.length > r.length ? t : r, s = t.length > r.length ? r : t;
    if (i.length < 4 || s.length * 2 < i.length)
      return null;
    var a = this;
    function l(w, m, T) {
      for (var D = w.substring(T, T + Math.floor(w.length / 4)), M = -1, I = "", R, H, U, $; (M = m.indexOf(D, M + 1)) != -1; ) {
        var F = a.diff_commonPrefix(
          w.substring(T),
          m.substring(M)
        ), G = a.diff_commonSuffix(
          w.substring(0, T),
          m.substring(0, M)
        );
        I.length < G + F && (I = m.substring(M - G, M) + m.substring(M, M + F), R = w.substring(0, T - G), H = w.substring(T + F), U = m.substring(0, M - G), $ = m.substring(M + F));
      }
      return I.length * 2 >= w.length ? [
        R,
        H,
        U,
        $,
        I
      ] : null;
    }
    var c = l(
      i,
      s,
      Math.ceil(i.length / 4)
    ), f = l(
      i,
      s,
      Math.ceil(i.length / 2)
    ), h;
    if (!c && !f)
      return null;
    f ? c ? h = c[4].length > f[4].length ? c : f : h = f : h = c;
    var d, p, _, v;
    t.length > r.length ? (d = h[0], p = h[1], _ = h[2], v = h[3]) : (_ = h[0], v = h[1], d = h[2], p = h[3]);
    var E = h[4];
    return [d, p, _, v, E];
  }, e.prototype.diff_cleanupSemantic = function(t) {
    for (var r = !1, i = [], s = 0, a = null, l = 0, c = 0, f = 0, h = 0, d = 0; l < t.length; )
      t[l][0] == g ? (i[s++] = l, c = h, f = d, h = 0, d = 0, a = t[l][1]) : (t[l][0] == u ? h += t[l][1].length : d += t[l][1].length, a && a.length <= Math.max(c, f) && a.length <= Math.max(
        h,
        d
      ) && (t.splice(
        i[s - 1],
        0,
        new e.Diff(o, a)
      ), t[i[s - 1] + 1][0] = u, s--, s--, l = s > 0 ? i[s - 1] : -1, c = 0, f = 0, h = 0, d = 0, a = null, r = !0)), l++;
    for (r && this.diff_cleanupMerge(t), this.diff_cleanupSemanticLossless(t), l = 1; l < t.length; ) {
      if (t[l - 1][0] == o && t[l][0] == u) {
        var p = t[l - 1][1], _ = t[l][1], v = this.diff_commonOverlap_(p, _), E = this.diff_commonOverlap_(_, p);
        v >= E ? (v >= p.length / 2 || v >= _.length / 2) && (t.splice(l, 0, new e.Diff(
          g,
          _.substring(0, v)
        )), t[l - 1][1] = p.substring(0, p.length - v), t[l + 1][1] = _.substring(v), l++) : (E >= p.length / 2 || E >= _.length / 2) && (t.splice(l, 0, new e.Diff(
          g,
          p.substring(0, E)
        )), t[l - 1][0] = u, t[l - 1][1] = _.substring(0, _.length - E), t[l + 1][0] = o, t[l + 1][1] = p.substring(E), l++), l++;
      }
      l++;
    }
  }, e.prototype.diff_cleanupSemanticLossless = function(t) {
    function r(E, w) {
      if (!E || !w)
        return 6;
      var m = E.charAt(E.length - 1), T = w.charAt(0), D = m.match(e.nonAlphaNumericRegex_), M = T.match(e.nonAlphaNumericRegex_), I = D && m.match(e.whitespaceRegex_), R = M && T.match(e.whitespaceRegex_), H = I && m.match(e.linebreakRegex_), U = R && T.match(e.linebreakRegex_), $ = H && E.match(e.blanklineEndRegex_), F = U && w.match(e.blanklineStartRegex_);
      return $ || F ? 5 : H || U ? 4 : D && !I && R ? 3 : I || R ? 2 : D || M ? 1 : 0;
    }
    for (var i = 1; i < t.length - 1; ) {
      if (t[i - 1][0] == g && t[i + 1][0] == g) {
        var s = t[i - 1][1], a = t[i][1], l = t[i + 1][1], c = this.diff_commonSuffix(s, a);
        if (c) {
          var f = a.substring(a.length - c);
          s = s.substring(0, s.length - c), a = f + a.substring(0, a.length - c), l = f + l;
        }
        for (var h = s, d = a, p = l, _ = r(s, a) + r(a, l); a.charAt(0) === l.charAt(0); ) {
          s += a.charAt(0), a = a.substring(1) + l.charAt(0), l = l.substring(1);
          var v = r(s, a) + r(a, l);
          v >= _ && (_ = v, h = s, d = a, p = l);
        }
        t[i - 1][1] != h && (h ? t[i - 1][1] = h : (t.splice(i - 1, 1), i--), t[i][1] = d, p ? t[i + 1][1] = p : (t.splice(i + 1, 1), i--));
      }
      i++;
    }
  }, e.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/, e.whitespaceRegex_ = /\s/, e.linebreakRegex_ = /[\r\n]/, e.blanklineEndRegex_ = /\n\r?\n$/, e.blanklineStartRegex_ = /^\r?\n\r?\n/, e.prototype.diff_cleanupEfficiency = function(t) {
    for (var r = !1, i = [], s = 0, a = null, l = 0, c = !1, f = !1, h = !1, d = !1; l < t.length; )
      t[l][0] == g ? (t[l][1].length < this.Diff_EditCost && (h || d) ? (i[s++] = l, c = h, f = d, a = t[l][1]) : (s = 0, a = null), h = d = !1) : (t[l][0] == o ? d = !0 : h = !0, a && (c && f && h && d || a.length < this.Diff_EditCost / 2 && c + f + h + d == 3) && (t.splice(
        i[s - 1],
        0,
        new e.Diff(o, a)
      ), t[i[s - 1] + 1][0] = u, s--, a = null, c && f ? (h = d = !0, s = 0) : (s--, l = s > 0 ? i[s - 1] : -1, h = d = !1), r = !0)), l++;
    r && this.diff_cleanupMerge(t);
  }, e.prototype.diff_cleanupMerge = function(t) {
    t.push(new e.Diff(g, ""));
    for (var r = 0, i = 0, s = 0, a = "", l = "", c; r < t.length; )
      switch (t[r][0]) {
        case u:
          s++, l += t[r][1], r++;
          break;
        case o:
          i++, a += t[r][1], r++;
          break;
        case g:
          i + s > 1 ? (i !== 0 && s !== 0 && (c = this.diff_commonPrefix(l, a), c !== 0 && (r - i - s > 0 && t[r - i - s - 1][0] == g ? t[r - i - s - 1][1] += l.substring(0, c) : (t.splice(0, 0, new e.Diff(
            g,
            l.substring(0, c)
          )), r++), l = l.substring(c), a = a.substring(c)), c = this.diff_commonSuffix(l, a), c !== 0 && (t[r][1] = l.substring(l.length - c) + t[r][1], l = l.substring(0, l.length - c), a = a.substring(0, a.length - c))), r -= i + s, t.splice(r, i + s), a.length && (t.splice(
            r,
            0,
            new e.Diff(o, a)
          ), r++), l.length && (t.splice(
            r,
            0,
            new e.Diff(u, l)
          ), r++), r++) : r !== 0 && t[r - 1][0] == g ? (t[r - 1][1] += t[r][1], t.splice(r, 1)) : r++, s = 0, i = 0, a = "", l = "";
          break;
      }
    t[t.length - 1][1] === "" && t.pop();
    var f = !1;
    for (r = 1; r < t.length - 1; )
      t[r - 1][0] == g && t[r + 1][0] == g && (t[r][1].substring(t[r][1].length - t[r - 1][1].length) == t[r - 1][1] ? (t[r][1] = t[r - 1][1] + t[r][1].substring(0, t[r][1].length - t[r - 1][1].length), t[r + 1][1] = t[r - 1][1] + t[r + 1][1], t.splice(r - 1, 1), f = !0) : t[r][1].substring(0, t[r + 1][1].length) == t[r + 1][1] && (t[r - 1][1] += t[r + 1][1], t[r][1] = t[r][1].substring(t[r + 1][1].length) + t[r + 1][1], t.splice(r + 1, 1), f = !0)), r++;
    f && this.diff_cleanupMerge(t);
  }, e.prototype.diff_xIndex = function(t, r) {
    var i = 0, s = 0, a = 0, l = 0, c;
    for (c = 0; c < t.length && (t[c][0] !== u && (i += t[c][1].length), t[c][0] !== o && (s += t[c][1].length), !(i > r)); c++)
      a = i, l = s;
    return t.length != c && t[c][0] === o ? l : l + (r - a);
  }, e.prototype.diff_prettyHtml = function(t) {
    for (var r = [], i = /&/g, s = /</g, a = />/g, l = /\n/g, c = 0; c < t.length; c++) {
      var f = t[c][0], h = t[c][1], d = h.replace(i, "&amp;").replace(s, "&lt;").replace(a, "&gt;").replace(l, "&para;<br>");
      switch (f) {
        case u:
          r[c] = '<ins style="background:#e6ffe6;">' + d + "</ins>";
          break;
        case o:
          r[c] = '<del style="background:#ffe6e6;">' + d + "</del>";
          break;
        case g:
          r[c] = "<span>" + d + "</span>";
          break;
      }
    }
    return r.join("");
  }, e.prototype.diff_text1 = function(t) {
    for (var r = [], i = 0; i < t.length; i++)
      t[i][0] !== u && (r[i] = t[i][1]);
    return r.join("");
  }, e.prototype.diff_text2 = function(t) {
    for (var r = [], i = 0; i < t.length; i++)
      t[i][0] !== o && (r[i] = t[i][1]);
    return r.join("");
  }, e.prototype.diff_levenshtein = function(t) {
    for (var r = 0, i = 0, s = 0, a = 0; a < t.length; a++) {
      var l = t[a][0], c = t[a][1];
      switch (l) {
        case u:
          i += c.length;
          break;
        case o:
          s += c.length;
          break;
        case g:
          r += Math.max(i, s), i = 0, s = 0;
          break;
      }
    }
    return r += Math.max(i, s), r;
  }, e.prototype.diff_toDelta = function(t) {
    for (var r = [], i = 0; i < t.length; i++)
      switch (t[i][0]) {
        case u:
          r[i] = "+" + encodeURI(t[i][1]);
          break;
        case o:
          r[i] = "-" + t[i][1].length;
          break;
        case g:
          r[i] = "=" + t[i][1].length;
          break;
      }
    return r.join("	").replace(/%20/g, " ");
  }, e.prototype.diff_fromDelta = function(t, r) {
    for (var i = [], s = 0, a = 0, l = r.split(/\t/g), c = 0; c < l.length; c++) {
      var f = l[c].substring(1);
      switch (l[c].charAt(0)) {
        case "+":
          try {
            i[s++] = new e.Diff(u, decodeURI(f));
          } catch (p) {
            throw new Error("Illegal escape in diff_fromDelta: " + f);
          }
          break;
        case "-":
        case "=":
          var h = parseInt(f, 10);
          if (isNaN(h) || h < 0)
            throw new Error("Invalid number in diff_fromDelta: " + f);
          var d = t.substring(a, a += h);
          l[c].charAt(0) == "=" ? i[s++] = new e.Diff(g, d) : i[s++] = new e.Diff(o, d);
          break;
        default:
          if (l[c])
            throw new Error("Invalid diff operation in diff_fromDelta: " + l[c]);
      }
    }
    if (a != t.length)
      throw new Error("Delta length (" + a + ") does not equal source text length (" + t.length + ").");
    return i;
  }, e.prototype.match_main = function(t, r, i) {
    if (t == null || r == null || i == null)
      throw new Error("Null input. (match_main)");
    return i = Math.max(0, Math.min(i, t.length)), t == r ? 0 : t.length ? t.substring(i, i + r.length) == r ? i : this.match_bitap_(t, r, i) : -1;
  }, e.prototype.match_bitap_ = function(t, r, i) {
    if (r.length > this.Match_MaxBits)
      throw new Error("Pattern too long for this browser.");
    var s = this.match_alphabet_(r), a = this;
    function l(R, H) {
      var U = R / r.length, $ = Math.abs(i - H);
      return a.Match_Distance ? U + $ / a.Match_Distance : $ ? 1 : U;
    }
    var c = this.Match_Threshold, f = t.indexOf(r, i);
    f != -1 && (c = Math.min(l(0, f), c), f = t.lastIndexOf(r, i + r.length), f != -1 && (c = Math.min(l(0, f), c)));
    var h = 1 << r.length - 1;
    f = -1;
    for (var d, p, _ = r.length + t.length, v, E = 0; E < r.length; E++) {
      for (d = 0, p = _; d < p; )
        l(E, i + p) <= c ? d = p : _ = p, p = Math.floor((_ - d) / 2 + d);
      _ = p;
      var w = Math.max(1, i - p + 1), m = Math.min(i + p, t.length) + r.length, T = Array(m + 2);
      T[m + 1] = (1 << E) - 1;
      for (var D = m; D >= w; D--) {
        var M = s[t.charAt(D - 1)];
        if (E === 0 ? T[D] = (T[D + 1] << 1 | 1) & M : T[D] = (T[D + 1] << 1 | 1) & M | ((v[D + 1] | v[D]) << 1 | 1) | v[D + 1], T[D] & h) {
          var I = l(E, D - 1);
          if (I <= c)
            if (c = I, f = D - 1, f > i)
              w = Math.max(1, 2 * i - f);
            else
              break;
        }
      }
      if (l(E + 1, i) > c)
        break;
      v = T;
    }
    return f;
  }, e.prototype.match_alphabet_ = function(t) {
    for (var r = {}, i = 0; i < t.length; i++)
      r[t.charAt(i)] = 0;
    for (var i = 0; i < t.length; i++)
      r[t.charAt(i)] |= 1 << t.length - i - 1;
    return r;
  }, e.prototype.patch_addContext_ = function(t, r) {
    if (r.length != 0) {
      if (t.start2 === null)
        throw Error("patch not initialized");
      for (var i = r.substring(t.start2, t.start2 + t.length1), s = 0; r.indexOf(i) != r.lastIndexOf(i) && i.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin; )
        s += this.Patch_Margin, i = r.substring(
          t.start2 - s,
          t.start2 + t.length1 + s
        );
      s += this.Patch_Margin;
      var a = r.substring(t.start2 - s, t.start2);
      a && t.diffs.unshift(new e.Diff(g, a));
      var l = r.substring(
        t.start2 + t.length1,
        t.start2 + t.length1 + s
      );
      l && t.diffs.push(new e.Diff(g, l)), t.start1 -= a.length, t.start2 -= a.length, t.length1 += a.length + l.length, t.length2 += a.length + l.length;
    }
  }, e.prototype.patch_make = function(t, r, i) {
    var s, a;
    if (typeof t == "string" && typeof r == "string" && typeof i == "undefined")
      s = /** @type {string} */
      t, a = this.diff_main(
        s,
        /** @type {string} */
        r,
        !0
      ), a.length > 2 && (this.diff_cleanupSemantic(a), this.diff_cleanupEfficiency(a));
    else if (t && typeof t == "object" && typeof r == "undefined" && typeof i == "undefined")
      a = /** @type {!Array.<!diff_match_patch.Diff>} */
      t, s = this.diff_text1(a);
    else if (typeof t == "string" && r && typeof r == "object" && typeof i == "undefined")
      s = /** @type {string} */
      t, a = /** @type {!Array.<!diff_match_patch.Diff>} */
      r;
    else if (typeof t == "string" && typeof r == "string" && i && typeof i == "object")
      s = /** @type {string} */
      t, a = /** @type {!Array.<!diff_match_patch.Diff>} */
      i;
    else
      throw new Error("Unknown call format to patch_make.");
    if (a.length === 0)
      return [];
    for (var l = [], c = new e.patch_obj(), f = 0, h = 0, d = 0, p = s, _ = s, v = 0; v < a.length; v++) {
      var E = a[v][0], w = a[v][1];
      switch (!f && E !== g && (c.start1 = h, c.start2 = d), E) {
        case u:
          c.diffs[f++] = a[v], c.length2 += w.length, _ = _.substring(0, d) + w + _.substring(d);
          break;
        case o:
          c.length1 += w.length, c.diffs[f++] = a[v], _ = _.substring(0, d) + _.substring(d + w.length);
          break;
        case g:
          w.length <= 2 * this.Patch_Margin && f && a.length != v + 1 ? (c.diffs[f++] = a[v], c.length1 += w.length, c.length2 += w.length) : w.length >= 2 * this.Patch_Margin && f && (this.patch_addContext_(c, p), l.push(c), c = new e.patch_obj(), f = 0, p = _, h = d);
          break;
      }
      E !== u && (h += w.length), E !== o && (d += w.length);
    }
    return f && (this.patch_addContext_(c, p), l.push(c)), l;
  }, e.prototype.patch_deepCopy = function(t) {
    for (var r = [], i = 0; i < t.length; i++) {
      var s = t[i], a = new e.patch_obj();
      a.diffs = [];
      for (var l = 0; l < s.diffs.length; l++)
        a.diffs[l] = new e.Diff(s.diffs[l][0], s.diffs[l][1]);
      a.start1 = s.start1, a.start2 = s.start2, a.length1 = s.length1, a.length2 = s.length2, r[i] = a;
    }
    return r;
  }, e.prototype.patch_apply = function(t, r) {
    if (t.length == 0)
      return [r, []];
    t = this.patch_deepCopy(t);
    var i = this.patch_addPadding(t);
    r = i + r + i, this.patch_splitMax(t);
    for (var s = 0, a = [], l = 0; l < t.length; l++) {
      var c = t[l].start2 + s, f = this.diff_text1(t[l].diffs), h, d = -1;
      if (f.length > this.Match_MaxBits ? (h = this.match_main(
        r,
        f.substring(0, this.Match_MaxBits),
        c
      ), h != -1 && (d = this.match_main(
        r,
        f.substring(f.length - this.Match_MaxBits),
        c + f.length - this.Match_MaxBits
      ), (d == -1 || h >= d) && (h = -1))) : h = this.match_main(r, f, c), h == -1)
        a[l] = !1, s -= t[l].length2 - t[l].length1;
      else {
        a[l] = !0, s = h - c;
        var p;
        if (d == -1 ? p = r.substring(h, h + f.length) : p = r.substring(h, d + this.Match_MaxBits), f == p)
          r = r.substring(0, h) + this.diff_text2(t[l].diffs) + r.substring(h + f.length);
        else {
          var _ = this.diff_main(f, p, !1);
          if (f.length > this.Match_MaxBits && this.diff_levenshtein(_) / f.length > this.Patch_DeleteThreshold)
            a[l] = !1;
          else {
            this.diff_cleanupSemanticLossless(_);
            for (var v = 0, E, w = 0; w < t[l].diffs.length; w++) {
              var m = t[l].diffs[w];
              m[0] !== g && (E = this.diff_xIndex(_, v)), m[0] === u ? r = r.substring(0, h + E) + m[1] + r.substring(h + E) : m[0] === o && (r = r.substring(0, h + E) + r.substring(h + this.diff_xIndex(
                _,
                v + m[1].length
              ))), m[0] !== o && (v += m[1].length);
            }
          }
        }
      }
    }
    return r = r.substring(i.length, r.length - i.length), [r, a];
  }, e.prototype.patch_addPadding = function(t) {
    for (var r = this.Patch_Margin, i = "", s = 1; s <= r; s++)
      i += String.fromCharCode(s);
    for (var s = 0; s < t.length; s++)
      t[s].start1 += r, t[s].start2 += r;
    var a = t[0], l = a.diffs;
    if (l.length == 0 || l[0][0] != g)
      l.unshift(new e.Diff(g, i)), a.start1 -= r, a.start2 -= r, a.length1 += r, a.length2 += r;
    else if (r > l[0][1].length) {
      var c = r - l[0][1].length;
      l[0][1] = i.substring(l[0][1].length) + l[0][1], a.start1 -= c, a.start2 -= c, a.length1 += c, a.length2 += c;
    }
    if (a = t[t.length - 1], l = a.diffs, l.length == 0 || l[l.length - 1][0] != g)
      l.push(new e.Diff(g, i)), a.length1 += r, a.length2 += r;
    else if (r > l[l.length - 1][1].length) {
      var c = r - l[l.length - 1][1].length;
      l[l.length - 1][1] += i.substring(0, c), a.length1 += c, a.length2 += c;
    }
    return i;
  }, e.prototype.patch_splitMax = function(t) {
    for (var r = this.Match_MaxBits, i = 0; i < t.length; i++)
      if (!(t[i].length1 <= r)) {
        var s = t[i];
        t.splice(i--, 1);
        for (var a = s.start1, l = s.start2, c = ""; s.diffs.length !== 0; ) {
          var f = new e.patch_obj(), h = !0;
          for (f.start1 = a - c.length, f.start2 = l - c.length, c !== "" && (f.length1 = f.length2 = c.length, f.diffs.push(new e.Diff(g, c))); s.diffs.length !== 0 && f.length1 < r - this.Patch_Margin; ) {
            var d = s.diffs[0][0], p = s.diffs[0][1];
            d === u ? (f.length2 += p.length, l += p.length, f.diffs.push(s.diffs.shift()), h = !1) : d === o && f.diffs.length == 1 && f.diffs[0][0] == g && p.length > 2 * r ? (f.length1 += p.length, a += p.length, h = !1, f.diffs.push(new e.Diff(d, p)), s.diffs.shift()) : (p = p.substring(
              0,
              r - f.length1 - this.Patch_Margin
            ), f.length1 += p.length, a += p.length, d === g ? (f.length2 += p.length, l += p.length) : h = !1, f.diffs.push(new e.Diff(d, p)), p == s.diffs[0][1] ? s.diffs.shift() : s.diffs[0][1] = s.diffs[0][1].substring(p.length));
          }
          c = this.diff_text2(f.diffs), c = c.substring(c.length - this.Patch_Margin);
          var _ = this.diff_text1(s.diffs).substring(0, this.Patch_Margin);
          _ !== "" && (f.length1 += _.length, f.length2 += _.length, f.diffs.length !== 0 && f.diffs[f.diffs.length - 1][0] === g ? f.diffs[f.diffs.length - 1][1] += _ : f.diffs.push(new e.Diff(g, _))), h || t.splice(++i, 0, f);
        }
      }
  }, e.prototype.patch_toText = function(t) {
    for (var r = [], i = 0; i < t.length; i++)
      r[i] = t[i];
    return r.join("");
  }, e.prototype.patch_fromText = function(t) {
    var r = [];
    if (!t)
      return r;
    for (var i = t.split(`
`), s = 0, a = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/; s < i.length; ) {
      var l = i[s].match(a);
      if (!l)
        throw new Error("Invalid patch string: " + i[s]);
      var c = new e.patch_obj();
      for (r.push(c), c.start1 = parseInt(l[1], 10), l[2] === "" ? (c.start1--, c.length1 = 1) : l[2] == "0" ? c.length1 = 0 : (c.start1--, c.length1 = parseInt(l[2], 10)), c.start2 = parseInt(l[3], 10), l[4] === "" ? (c.start2--, c.length2 = 1) : l[4] == "0" ? c.length2 = 0 : (c.start2--, c.length2 = parseInt(l[4], 10)), s++; s < i.length; ) {
        var f = i[s].charAt(0);
        try {
          var h = decodeURI(i[s].substring(1));
        } catch (d) {
          throw new Error("Illegal escape in patch_fromText: " + h);
        }
        if (f == "-")
          c.diffs.push(new e.Diff(o, h));
        else if (f == "+")
          c.diffs.push(new e.Diff(u, h));
        else if (f == " ")
          c.diffs.push(new e.Diff(g, h));
        else {
          if (f == "@")
            break;
          if (f !== "")
            throw new Error('Invalid patch mode "' + f + '" in: ' + h);
        }
        s++;
      }
    }
    return r;
  }, e.patch_obj = function() {
    this.diffs = [], this.start1 = null, this.start2 = null, this.length1 = 0, this.length2 = 0;
  }, e.patch_obj.prototype.toString = function() {
    var t, r;
    this.length1 === 0 ? t = this.start1 + ",0" : this.length1 == 1 ? t = this.start1 + 1 : t = this.start1 + 1 + "," + this.length1, this.length2 === 0 ? r = this.start2 + ",0" : this.length2 == 1 ? r = this.start2 + 1 : r = this.start2 + 1 + "," + this.length2;
    for (var i = ["@@ -" + t + " +" + r + ` @@
`], s, a = 0; a < this.diffs.length; a++) {
      switch (this.diffs[a][0]) {
        case u:
          s = "+";
          break;
        case o:
          s = "-";
          break;
        case g:
          s = " ";
          break;
      }
      i[a + 1] = s + encodeURI(this.diffs[a][1]) + `
`;
    }
    return i.join("").replace(/%20/g, " ");
  }, n.exports = e, n.exports.diff_match_patch = e, n.exports.DIFF_DELETE = o, n.exports.DIFF_INSERT = u, n.exports.DIFF_EQUAL = g;
})(xn);
var Be = { exports: {} };
function $e(n) {
  return n instanceof Map ? n.clear = n.delete = n.set = function() {
    throw new Error("map is read-only");
  } : n instanceof Set && (n.add = n.clear = n.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(n), Object.getOwnPropertyNames(n).forEach(function(e) {
    var o = n[e];
    typeof o == "object" && !Object.isFrozen(o) && $e(o);
  }), n;
}
Be.exports = $e;
Be.exports.default = $e;
class Ve {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1;
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function rn(n) {
  return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function te(n, ...e) {
  const o = /* @__PURE__ */ Object.create(null);
  for (const u in n)
    o[u] = n[u];
  return e.forEach(function(u) {
    for (const g in u)
      o[g] = u[g];
  }), /** @type {T} */
  o;
}
const Hn = "</span>", Ze = (n) => !!n.scope || n.sublanguage && n.language, Fn = (n, { prefix: e }) => {
  if (n.includes(".")) {
    const o = n.split(".");
    return [
      `${e}${o.shift()}`,
      ...o.map((u, g) => `${u}${"_".repeat(g + 1)}`)
    ].join(" ");
  }
  return `${e}${n}`;
};
class zn {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, o) {
    this.buffer = "", this.classPrefix = o.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += rn(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!Ze(e))
      return;
    let o = "";
    e.sublanguage ? o = `language-${e.language}` : o = Fn(e.scope, { prefix: this.classPrefix }), this.span(o);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    Ze(e) && (this.buffer += Hn);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
}
const Ye = (n = {}) => {
  const e = { children: [] };
  return Object.assign(e, n), e;
};
class Ue {
  constructor() {
    this.rootNode = Ye(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const o = Ye({ scope: e });
    this.add(o), this.stack.push(o);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, o) {
    return typeof o == "string" ? e.addText(o) : o.children && (e.openNode(o), o.children.forEach((u) => this._walk(e, u)), e.closeNode(o)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((o) => typeof o == "string") ? e.children = [e.children.join("")] : e.children.forEach((o) => {
      Ue._collapse(o);
    }));
  }
}
class Gn extends Ue {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   * @param {string} scope
   */
  addKeyword(e, o) {
    e !== "" && (this.openNode(o), this.addText(e), this.closeNode());
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  addSublanguage(e, o) {
    const u = e.root;
    u.sublanguage = !0, u.language = o, this.add(u);
  }
  toHTML() {
    return new zn(this, this.options).value();
  }
  finalize() {
    return !0;
  }
}
function fe(n) {
  return n ? typeof n == "string" ? n : n.source : null;
}
function sn(n) {
  return se("(?=", n, ")");
}
function Kn(n) {
  return se("(?:", n, ")*");
}
function Wn(n) {
  return se("(?:", n, ")?");
}
function se(...n) {
  return n.map((o) => fe(o)).join("");
}
function Qn(n) {
  const e = n[n.length - 1];
  return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {};
}
function Pe(...n) {
  return "(" + (Qn(n).capture ? "" : "?:") + n.map((u) => fe(u)).join("|") + ")";
}
function an(n) {
  return new RegExp(n.toString() + "|").exec("").length - 1;
}
function Vn(n, e) {
  const o = n && n.exec(e);
  return o && o.index === 0;
}
const Zn = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function xe(n, { joinWith: e }) {
  let o = 0;
  return n.map((u) => {
    o += 1;
    const g = o;
    let t = fe(u), r = "";
    for (; t.length > 0; ) {
      const i = Zn.exec(t);
      if (!i) {
        r += t;
        break;
      }
      r += t.substring(0, i.index), t = t.substring(i.index + i[0].length), i[0][0] === "\\" && i[1] ? r += "\\" + String(Number(i[1]) + g) : (r += i[0], i[0] === "(" && o++);
    }
    return r;
  }).map((u) => `(${u})`).join(e);
}
const Yn = /\b\B/, on = "[a-zA-Z]\\w*", He = "[a-zA-Z_]\\w*", ln = "\\b\\d+(\\.\\d+)?", cn = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", un = "\\b(0b[01]+)", Xn = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", jn = (n = {}) => {
  const e = /^#![ ]*\//;
  return n.binary && (n.begin = se(
    e,
    /.*\b/,
    n.binary,
    /\b.*/
  )), te({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (o, u) => {
      o.index !== 0 && u.ignoreMatch();
    }
  }, n);
}, ge = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
}, Jn = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [ge]
}, qn = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [ge]
}, et = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
}, De = function(n, e, o = {}) {
  const u = te(
    {
      scope: "comment",
      begin: n,
      end: e,
      contains: []
    },
    o
  );
  u.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: !0,
    relevance: 0
  });
  const g = Pe(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return u.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: se(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        g,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), u;
}, nt = De("//", "$"), tt = De("/\\*", "\\*/"), rt = De("#", "$"), it = {
  scope: "number",
  begin: ln,
  relevance: 0
}, st = {
  scope: "number",
  begin: cn,
  relevance: 0
}, at = {
  scope: "number",
  begin: un,
  relevance: 0
}, ot = {
  // this outer rule makes sure we actually have a WHOLE regex and not simply
  // an expression such as:
  //
  //     3 / something
  //
  // (which will then blow up when regex's `illegal` sees the newline)
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{
    scope: "regexp",
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      ge,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [ge]
      }
    ]
  }]
}, lt = {
  scope: "title",
  begin: on,
  relevance: 0
}, ct = {
  scope: "title",
  begin: He,
  relevance: 0
}, ut = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + He,
  relevance: 0
}, ft = function(n) {
  return Object.assign(
    n,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, o) => {
        o.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, o) => {
        o.data._beginMatch !== e[1] && o.ignoreMatch();
      }
    }
  );
};
var ye = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MATCH_NOTHING_RE: Yn,
  IDENT_RE: on,
  UNDERSCORE_IDENT_RE: He,
  NUMBER_RE: ln,
  C_NUMBER_RE: cn,
  BINARY_NUMBER_RE: un,
  RE_STARTERS_RE: Xn,
  SHEBANG: jn,
  BACKSLASH_ESCAPE: ge,
  APOS_STRING_MODE: Jn,
  QUOTE_STRING_MODE: qn,
  PHRASAL_WORDS_MODE: et,
  COMMENT: De,
  C_LINE_COMMENT_MODE: nt,
  C_BLOCK_COMMENT_MODE: tt,
  HASH_COMMENT_MODE: rt,
  NUMBER_MODE: it,
  C_NUMBER_MODE: st,
  BINARY_NUMBER_MODE: at,
  REGEXP_MODE: ot,
  TITLE_MODE: lt,
  UNDERSCORE_TITLE_MODE: ct,
  METHOD_GUARD: ut,
  END_SAME_AS_BEGIN: ft
});
function gt(n, e) {
  n.input[n.index - 1] === "." && e.ignoreMatch();
}
function ht(n, e) {
  n.className !== void 0 && (n.scope = n.className, delete n.className);
}
function dt(n, e) {
  e && n.beginKeywords && (n.begin = "\\b(" + n.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n.__beforeBegin = gt, n.keywords = n.keywords || n.beginKeywords, delete n.beginKeywords, n.relevance === void 0 && (n.relevance = 0));
}
function pt(n, e) {
  Array.isArray(n.illegal) && (n.illegal = Pe(...n.illegal));
}
function _t(n, e) {
  if (n.match) {
    if (n.begin || n.end)
      throw new Error("begin & end are not supported with match");
    n.begin = n.match, delete n.match;
  }
}
function bt(n, e) {
  n.relevance === void 0 && (n.relevance = 1);
}
const vt = (n, e) => {
  if (!n.beforeMatch)
    return;
  if (n.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const o = Object.assign({}, n);
  Object.keys(n).forEach((u) => {
    delete n[u];
  }), n.keywords = o.keywords, n.begin = se(o.beforeMatch, sn(o.begin)), n.starts = {
    relevance: 0,
    contains: [
      Object.assign(o, { endsParent: !0 })
    ]
  }, n.relevance = 0, delete o.beforeMatch;
}, Et = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
], mt = "keyword";
function fn(n, e, o = mt) {
  const u = /* @__PURE__ */ Object.create(null);
  return typeof n == "string" ? g(o, n.split(" ")) : Array.isArray(n) ? g(o, n) : Object.keys(n).forEach(function(t) {
    Object.assign(
      u,
      fn(n[t], e, t)
    );
  }), u;
  function g(t, r) {
    e && (r = r.map((i) => i.toLowerCase())), r.forEach(function(i) {
      const s = i.split("|");
      u[s[0]] = [t, yt(s[0], s[1])];
    });
  }
}
function yt(n, e) {
  return e ? Number(e) : wt(n) ? 0 : 1;
}
function wt(n) {
  return Et.includes(n.toLowerCase());
}
const Xe = {}, ie = (n) => {
  console.error(n);
}, je = (n, ...e) => {
  console.log(`WARN: ${n}`, ...e);
}, ae = (n, e) => {
  Xe[`${n}/${e}`] || (console.log(`Deprecated as of ${n}. ${e}`), Xe[`${n}/${e}`] = !0);
}, Ae = new Error();
function gn(n, e, { key: o }) {
  let u = 0;
  const g = n[o], t = {}, r = {};
  for (let i = 1; i <= e.length; i++)
    r[i + u] = g[i], t[i + u] = !0, u += an(e[i - 1]);
  n[o] = r, n[o]._emit = t, n[o]._multi = !0;
}
function Nt(n) {
  if (Array.isArray(n.begin)) {
    if (n.skip || n.excludeBegin || n.returnBegin)
      throw ie("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), Ae;
    if (typeof n.beginScope != "object" || n.beginScope === null)
      throw ie("beginScope must be object"), Ae;
    gn(n, n.begin, { key: "beginScope" }), n.begin = xe(n.begin, { joinWith: "" });
  }
}
function Mt(n) {
  if (Array.isArray(n.end)) {
    if (n.skip || n.excludeEnd || n.returnEnd)
      throw ie("skip, excludeEnd, returnEnd not compatible with endScope: {}"), Ae;
    if (typeof n.endScope != "object" || n.endScope === null)
      throw ie("endScope must be object"), Ae;
    gn(n, n.end, { key: "endScope" }), n.end = xe(n.end, { joinWith: "" });
  }
}
function At(n) {
  n.scope && typeof n.scope == "object" && n.scope !== null && (n.beginScope = n.scope, delete n.scope);
}
function Tt(n) {
  At(n), typeof n.beginScope == "string" && (n.beginScope = { _wrap: n.beginScope }), typeof n.endScope == "string" && (n.endScope = { _wrap: n.endScope }), Nt(n), Mt(n);
}
function Dt(n) {
  function e(r, i) {
    return new RegExp(
      fe(r),
      "m" + (n.case_insensitive ? "i" : "") + (n.unicodeRegex ? "u" : "") + (i ? "g" : "")
    );
  }
  class o {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(i, s) {
      s.position = this.position++, this.matchIndexes[this.matchAt] = s, this.regexes.push([s, i]), this.matchAt += an(i) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const i = this.regexes.map((s) => s[1]);
      this.matcherRe = e(xe(i, { joinWith: "|" }), !0), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(i) {
      this.matcherRe.lastIndex = this.lastIndex;
      const s = this.matcherRe.exec(i);
      if (!s)
        return null;
      const a = s.findIndex((c, f) => f > 0 && c !== void 0), l = this.matchIndexes[a];
      return s.splice(0, a), Object.assign(s, l);
    }
  }
  class u {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(i) {
      if (this.multiRegexes[i])
        return this.multiRegexes[i];
      const s = new o();
      return this.rules.slice(i).forEach(([a, l]) => s.addRule(a, l)), s.compile(), this.multiRegexes[i] = s, s;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(i, s) {
      this.rules.push([i, s]), s.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(i) {
      const s = this.getMatcher(this.regexIndex);
      s.lastIndex = this.lastIndex;
      let a = s.exec(i);
      if (this.resumingScanAtSamePosition() && !(a && a.index === this.lastIndex)) {
        const l = this.getMatcher(0);
        l.lastIndex = this.lastIndex + 1, a = l.exec(i);
      }
      return a && (this.regexIndex += a.position + 1, this.regexIndex === this.count && this.considerAll()), a;
    }
  }
  function g(r) {
    const i = new u();
    return r.contains.forEach((s) => i.addRule(s.begin, { rule: s, type: "begin" })), r.terminatorEnd && i.addRule(r.terminatorEnd, { type: "end" }), r.illegal && i.addRule(r.illegal, { type: "illegal" }), i;
  }
  function t(r, i) {
    const s = (
      /** @type CompiledMode */
      r
    );
    if (r.isCompiled)
      return s;
    [
      ht,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      _t,
      Tt,
      vt
    ].forEach((l) => l(r, i)), n.compilerExtensions.forEach((l) => l(r, i)), r.__beforeBegin = null, [
      dt,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      pt,
      // default to 1 relevance if not specified
      bt
    ].forEach((l) => l(r, i)), r.isCompiled = !0;
    let a = null;
    return typeof r.keywords == "object" && r.keywords.$pattern && (r.keywords = Object.assign({}, r.keywords), a = r.keywords.$pattern, delete r.keywords.$pattern), a = a || /\w+/, r.keywords && (r.keywords = fn(r.keywords, n.case_insensitive)), s.keywordPatternRe = e(a, !0), i && (r.begin || (r.begin = /\B|\b/), s.beginRe = e(s.begin), !r.end && !r.endsWithParent && (r.end = /\B|\b/), r.end && (s.endRe = e(s.end)), s.terminatorEnd = fe(s.end) || "", r.endsWithParent && i.terminatorEnd && (s.terminatorEnd += (r.end ? "|" : "") + i.terminatorEnd)), r.illegal && (s.illegalRe = e(
      /** @type {RegExp | string} */
      r.illegal
    )), r.contains || (r.contains = []), r.contains = [].concat(...r.contains.map(function(l) {
      return St(l === "self" ? r : l);
    })), r.contains.forEach(function(l) {
      t(
        /** @type Mode */
        l,
        s
      );
    }), r.starts && t(r.starts, i), s.matcher = g(s), s;
  }
  if (n.compilerExtensions || (n.compilerExtensions = []), n.contains && n.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return n.classNameAliases = te(n.classNameAliases || {}), t(
    /** @type Mode */
    n
  );
}
function hn(n) {
  return n ? n.endsWithParent || hn(n.starts) : !1;
}
function St(n) {
  return n.variants && !n.cachedVariants && (n.cachedVariants = n.variants.map(function(e) {
    return te(n, { variants: null }, e);
  })), n.cachedVariants ? n.cachedVariants : hn(n) ? te(n, { starts: n.starts ? te(n.starts) : null }) : Object.isFrozen(n) ? te(n) : n;
}
var Rt = "11.7.0";
class Lt extends Error {
  constructor(e, o) {
    super(e), this.name = "HTMLInjectionError", this.html = o;
  }
}
const Oe = rn, Je = te, qe = Symbol("nomatch"), Ot = 7, Ct = function(n) {
  const e = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null), u = [];
  let g = !0;
  const t = "Could not find the language '{}', did you forget to load/include a language module?", r = { disableAutodetect: !0, name: "Plain text", contains: [] };
  let i = {
    ignoreUnescapedHTML: !1,
    throwUnescapedHTML: !1,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: Gn
  };
  function s(b) {
    return i.noHighlightRe.test(b);
  }
  function a(b) {
    let N = b.className + " ";
    N += b.parentNode ? b.parentNode.className : "";
    const O = i.languageDetectRe.exec(N);
    if (O) {
      const k = R(O[1]);
      return k || (je(t.replace("{}", O[1])), je("Falling back to no-highlight mode for this block.", b)), k ? O[1] : "no-highlight";
    }
    return N.split(/\s+/).find((k) => s(k) || R(k));
  }
  function l(b, N, O) {
    let k = "", x = "";
    typeof N == "object" ? (k = b, O = N.ignoreIllegals, x = N.language) : (ae("10.7.0", "highlight(lang, code, ...args) has been deprecated."), ae("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), x = b, k = N), O === void 0 && (O = !0);
    const W = {
      code: k,
      language: x
    };
    G("before:highlight", W);
    const Y = W.result ? W.result : c(W.language, W.code, O);
    return Y.code = W.code, G("after:highlight", Y), Y;
  }
  function c(b, N, O, k) {
    const x = /* @__PURE__ */ Object.create(null);
    function W(y, A) {
      return y.keywords[A];
    }
    function Y() {
      if (!L.keywords) {
        z.addText(P);
        return;
      }
      let y = 0;
      L.keywordPatternRe.lastIndex = 0;
      let A = L.keywordPatternRe.exec(P), C = "";
      for (; A; ) {
        C += P.substring(y, A.index);
        const B = ne.case_insensitive ? A[0].toLowerCase() : A[0], K = W(L, B);
        if (K) {
          const [X, An] = K;
          if (z.addText(C), C = "", x[B] = (x[B] || 0) + 1, x[B] <= Ot && (Ee += An), X.startsWith("_"))
            C += A[0];
          else {
            const Tn = ne.classNameAliases[X] || X;
            z.addKeyword(A[0], Tn);
          }
        } else
          C += A[0];
        y = L.keywordPatternRe.lastIndex, A = L.keywordPatternRe.exec(P);
      }
      C += P.substring(y), z.addText(C);
    }
    function be() {
      if (P === "")
        return;
      let y = null;
      if (typeof L.subLanguage == "string") {
        if (!e[L.subLanguage]) {
          z.addText(P);
          return;
        }
        y = c(L.subLanguage, P, !0, Ke[L.subLanguage]), Ke[L.subLanguage] = /** @type {CompiledMode} */
        y._top;
      } else
        y = h(P, L.subLanguage.length ? L.subLanguage : null);
      L.relevance > 0 && (Ee += y.relevance), z.addSublanguage(y._emitter, y.language);
    }
    function Q() {
      L.subLanguage != null ? be() : Y(), P = "";
    }
    function ee(y, A) {
      let C = 1;
      const B = A.length - 1;
      for (; C <= B; ) {
        if (!y._emit[C]) {
          C++;
          continue;
        }
        const K = ne.classNameAliases[y[C]] || y[C], X = A[C];
        K ? z.addKeyword(X, K) : (P = X, Y(), P = ""), C++;
      }
    }
    function Fe(y, A) {
      return y.scope && typeof y.scope == "string" && z.openNode(ne.classNameAliases[y.scope] || y.scope), y.beginScope && (y.beginScope._wrap ? (z.addKeyword(P, ne.classNameAliases[y.beginScope._wrap] || y.beginScope._wrap), P = "") : y.beginScope._multi && (ee(y.beginScope, A), P = "")), L = Object.create(y, { parent: { value: L } }), L;
    }
    function ze(y, A, C) {
      let B = Vn(y.endRe, C);
      if (B) {
        if (y["on:end"]) {
          const K = new Ve(y);
          y["on:end"](A, K), K.isMatchIgnored && (B = !1);
        }
        if (B) {
          for (; y.endsParent && y.parent; )
            y = y.parent;
          return y;
        }
      }
      if (y.endsWithParent)
        return ze(y.parent, A, C);
    }
    function mn(y) {
      return L.matcher.regexIndex === 0 ? (P += y[0], 1) : (Le = !0, 0);
    }
    function yn(y) {
      const A = y[0], C = y.rule, B = new Ve(C), K = [C.__beforeBegin, C["on:begin"]];
      for (const X of K)
        if (X && (X(y, B), B.isMatchIgnored))
          return mn(A);
      return C.skip ? P += A : (C.excludeBegin && (P += A), Q(), !C.returnBegin && !C.excludeBegin && (P = A)), Fe(C, y), C.returnBegin ? 0 : A.length;
    }
    function wn(y) {
      const A = y[0], C = N.substring(y.index), B = ze(L, y, C);
      if (!B)
        return qe;
      const K = L;
      L.endScope && L.endScope._wrap ? (Q(), z.addKeyword(A, L.endScope._wrap)) : L.endScope && L.endScope._multi ? (Q(), ee(L.endScope, y)) : K.skip ? P += A : (K.returnEnd || K.excludeEnd || (P += A), Q(), K.excludeEnd && (P = A));
      do
        L.scope && z.closeNode(), !L.skip && !L.subLanguage && (Ee += L.relevance), L = L.parent;
      while (L !== B.parent);
      return B.starts && Fe(B.starts, y), K.returnEnd ? 0 : A.length;
    }
    function Nn() {
      const y = [];
      for (let A = L; A !== ne; A = A.parent)
        A.scope && y.unshift(A.scope);
      y.forEach((A) => z.openNode(A));
    }
    let ve = {};
    function Ge(y, A) {
      const C = A && A[0];
      if (P += y, C == null)
        return Q(), 0;
      if (ve.type === "begin" && A.type === "end" && ve.index === A.index && C === "") {
        if (P += N.slice(A.index, A.index + 1), !g) {
          const B = new Error(`0 width match regex (${b})`);
          throw B.languageName = b, B.badRule = ve.rule, B;
        }
        return 1;
      }
      if (ve = A, A.type === "begin")
        return yn(A);
      if (A.type === "illegal" && !O) {
        const B = new Error('Illegal lexeme "' + C + '" for mode "' + (L.scope || "<unnamed>") + '"');
        throw B.mode = L, B;
      } else if (A.type === "end") {
        const B = wn(A);
        if (B !== qe)
          return B;
      }
      if (A.type === "illegal" && C === "")
        return 1;
      if (Re > 1e5 && Re > A.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return P += C, C.length;
    }
    const ne = R(b);
    if (!ne)
      throw ie(t.replace("{}", b)), new Error('Unknown language: "' + b + '"');
    const Mn = Dt(ne);
    let Se = "", L = k || Mn;
    const Ke = {}, z = new i.__emitter(i);
    Nn();
    let P = "", Ee = 0, re = 0, Re = 0, Le = !1;
    try {
      for (L.matcher.considerAll(); ; ) {
        Re++, Le ? Le = !1 : L.matcher.considerAll(), L.matcher.lastIndex = re;
        const y = L.matcher.exec(N);
        if (!y)
          break;
        const A = N.substring(re, y.index), C = Ge(A, y);
        re = y.index + C;
      }
      return Ge(N.substring(re)), z.closeAllNodes(), z.finalize(), Se = z.toHTML(), {
        language: b,
        value: Se,
        relevance: Ee,
        illegal: !1,
        _emitter: z,
        _top: L
      };
    } catch (y) {
      if (y.message && y.message.includes("Illegal"))
        return {
          language: b,
          value: Oe(N),
          illegal: !0,
          relevance: 0,
          _illegalBy: {
            message: y.message,
            index: re,
            context: N.slice(re - 100, re + 100),
            mode: y.mode,
            resultSoFar: Se
          },
          _emitter: z
        };
      if (g)
        return {
          language: b,
          value: Oe(N),
          illegal: !1,
          relevance: 0,
          errorRaised: y,
          _emitter: z,
          _top: L
        };
      throw y;
    }
  }
  function f(b) {
    const N = {
      value: Oe(b),
      illegal: !1,
      relevance: 0,
      _top: r,
      _emitter: new i.__emitter(i)
    };
    return N._emitter.addText(b), N;
  }
  function h(b, N) {
    N = N || i.languages || Object.keys(e);
    const O = f(b), k = N.filter(R).filter(U).map(
      (Q) => c(Q, b, !1)
    );
    k.unshift(O);
    const x = k.sort((Q, ee) => {
      if (Q.relevance !== ee.relevance)
        return ee.relevance - Q.relevance;
      if (Q.language && ee.language) {
        if (R(Q.language).supersetOf === ee.language)
          return 1;
        if (R(ee.language).supersetOf === Q.language)
          return -1;
      }
      return 0;
    }), [W, Y] = x, be = W;
    return be.secondBest = Y, be;
  }
  function d(b, N, O) {
    const k = N && o[N] || O;
    b.classList.add("hljs"), b.classList.add(`language-${k}`);
  }
  function p(b) {
    let N = null;
    const O = a(b);
    if (s(O))
      return;
    if (G(
      "before:highlightElement",
      { el: b, language: O }
    ), b.children.length > 0 && (i.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(b)), i.throwUnescapedHTML))
      throw new Lt(
        "One of your code blocks includes unescaped HTML.",
        b.innerHTML
      );
    N = b;
    const k = N.textContent, x = O ? l(k, { language: O, ignoreIllegals: !0 }) : h(k);
    b.innerHTML = x.value, d(b, O, x.language), b.result = {
      language: x.language,
      // TODO: remove with version 11.0
      re: x.relevance,
      relevance: x.relevance
    }, x.secondBest && (b.secondBest = {
      language: x.secondBest.language,
      relevance: x.secondBest.relevance
    }), G("after:highlightElement", { el: b, result: x, text: k });
  }
  function _(b) {
    i = Je(i, b);
  }
  const v = () => {
    m(), ae("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function E() {
    m(), ae("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let w = !1;
  function m() {
    if (document.readyState === "loading") {
      w = !0;
      return;
    }
    document.querySelectorAll(i.cssSelector).forEach(p);
  }
  function T() {
    w && m();
  }
  typeof window != "undefined" && window.addEventListener && window.addEventListener("DOMContentLoaded", T, !1);
  function D(b, N) {
    let O = null;
    try {
      O = N(n);
    } catch (k) {
      if (ie("Language definition for '{}' could not be registered.".replace("{}", b)), g)
        ie(k);
      else
        throw k;
      O = r;
    }
    O.name || (O.name = b), e[b] = O, O.rawDefinition = N.bind(null, n), O.aliases && H(O.aliases, { languageName: b });
  }
  function M(b) {
    delete e[b];
    for (const N of Object.keys(o))
      o[N] === b && delete o[N];
  }
  function I() {
    return Object.keys(e);
  }
  function R(b) {
    return b = (b || "").toLowerCase(), e[b] || e[o[b]];
  }
  function H(b, { languageName: N }) {
    typeof b == "string" && (b = [b]), b.forEach((O) => {
      o[O.toLowerCase()] = N;
    });
  }
  function U(b) {
    const N = R(b);
    return N && !N.disableAutodetect;
  }
  function $(b) {
    b["before:highlightBlock"] && !b["before:highlightElement"] && (b["before:highlightElement"] = (N) => {
      b["before:highlightBlock"](
        Object.assign({ block: N.el }, N)
      );
    }), b["after:highlightBlock"] && !b["after:highlightElement"] && (b["after:highlightElement"] = (N) => {
      b["after:highlightBlock"](
        Object.assign({ block: N.el }, N)
      );
    });
  }
  function F(b) {
    $(b), u.push(b);
  }
  function G(b, N) {
    const O = b;
    u.forEach(function(k) {
      k[O] && k[O](N);
    });
  }
  function _e(b) {
    return ae("10.7.0", "highlightBlock will be removed entirely in v12.0"), ae("10.7.0", "Please use highlightElement now."), p(b);
  }
  Object.assign(n, {
    highlight: l,
    highlightAuto: h,
    highlightAll: m,
    highlightElement: p,
    // TODO: Remove with v12 API
    highlightBlock: _e,
    configure: _,
    initHighlighting: v,
    initHighlightingOnLoad: E,
    registerLanguage: D,
    unregisterLanguage: M,
    listLanguages: I,
    getLanguage: R,
    registerAliases: H,
    autoDetection: U,
    inherit: Je,
    addPlugin: F
  }), n.debugMode = function() {
    g = !1;
  }, n.safeMode = function() {
    g = !0;
  }, n.versionString = Rt, n.regex = {
    concat: se,
    lookahead: sn,
    either: Pe,
    optional: Wn,
    anyNumberOfTimes: Kn
  };
  for (const b in ye)
    typeof ye[b] == "object" && Be.exports(ye[b]);
  return Object.assign(n, ye), n;
};
var he = Ct({}), It = he;
he.HighlightJS = he;
he.default = he;
const Z = It;
function kt(n) {
  const e = n.regex, o = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), u = /[\p{L}0-9._:-]+/u, g = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, t = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, r = n.inherit(t, {
    begin: /\(/,
    end: /\)/
  }), i = n.inherit(n.APOS_STRING_MODE, { className: "string" }), s = n.inherit(n.QUOTE_STRING_MODE, { className: "string" }), a = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: u,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [g]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [g]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          t,
          s,
          i,
          r,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  t,
                  r,
                  s,
                  i
                ]
              }
            ]
          }
        ]
      },
      n.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      g,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              s
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [a],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [a],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: e.concat(
          /</,
          e.lookahead(e.concat(
            o,
            // <tag/>
            // <tag>
            // <tag ...
            e.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: o,
            relevance: 0,
            starts: a
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: e.concat(
          /<\//,
          e.lookahead(e.concat(
            o,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: o,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
const en = "[A-Za-z$_][0-9A-Za-z$_]*", Bt = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
], $t = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], dn = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], pn = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], _n = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], Ut = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "module",
  "global"
  // Node.js
], Pt = [].concat(
  _n,
  dn,
  pn
);
function xt(n) {
  const e = n.regex, o = (N, { after: O }) => {
    const k = "</" + N[0].slice(1);
    return N.input.indexOf(k, O) !== -1;
  }, u = en, g = {
    begin: "<>",
    end: "</>"
  }, t = /<[A-Za-z0-9\\._:-]+\s*\/>/, r = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (N, O) => {
      const k = N[0].length + N.index, x = N.input[k];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        x === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        x === ","
      ) {
        O.ignoreMatch();
        return;
      }
      x === ">" && (o(N, { after: k }) || O.ignoreMatch());
      let W;
      const Y = N.input.substring(k);
      if (W = Y.match(/^\s*=/)) {
        O.ignoreMatch();
        return;
      }
      if ((W = Y.match(/^\s+extends\s+/)) && W.index === 0) {
        O.ignoreMatch();
        return;
      }
    }
  }, i = {
    $pattern: en,
    keyword: Bt,
    literal: $t,
    built_in: Pt,
    "variable.language": Ut
  }, s = "[0-9](_?[0-9])*", a = `\\.(${s})`, l = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", c = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${l})((${a})|\\.)?|(${a}))[eE][+-]?(${s})\\b` },
      { begin: `\\b(${l})\\b((${a})\\b|\\.)?|(${a})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: i,
    contains: []
    // defined later
  }, h = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, d = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, p = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      n.BACKSLASH_ESCAPE,
      f
    ]
  }, v = {
    className: "comment",
    variants: [
      n.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: u + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      n.C_BLOCK_COMMENT_MODE,
      n.C_LINE_COMMENT_MODE
    ]
  }, E = [
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    h,
    d,
    p,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    c
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = E.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: i,
    contains: [
      "self"
    ].concat(E)
  });
  const w = [].concat(v, f.contains), m = w.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: i,
      contains: ["self"].concat(w)
    }
  ]), T = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: i,
    contains: m
  }, D = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          u,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(u, "(", e.concat(/\./, u), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          u
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, M = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...dn,
        ...pn
      ]
    }
  }, I = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, R = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          u,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [T],
    illegal: /%/
  }, H = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function U(N) {
    return e.concat("(?!", N.join("|"), ")");
  }
  const $ = {
    match: e.concat(
      /\b/,
      U([
        ..._n,
        "super",
        "import"
      ]),
      u,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, F = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(u, /(?![0-9A-Za-z$_(])/)
    )),
    end: u,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, G = {
    match: [
      /get|set/,
      /\s+/,
      u,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      T
    ]
  }, _e = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", b = {
    match: [
      /const|var|let/,
      /\s+/,
      u,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(_e)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      T
    ]
  };
  return {
    name: "Javascript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: i,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: m, CLASS_REFERENCE: M },
    illegal: /#(?![$_A-z])/,
    contains: [
      n.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      I,
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      h,
      d,
      p,
      v,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      c,
      M,
      {
        className: "attr",
        begin: u + e.lookahead(":"),
        relevance: 0
      },
      b,
      {
        // "value" container
        begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          v,
          n.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: _e,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: n.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: i,
                    contains: m
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: g.begin, end: g.end },
              { match: t },
              {
                begin: r.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": r.isTrulyOpeningTag,
                end: r.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: r.begin,
                end: r.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      R,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          T,
          n.inherit(n.TITLE_MODE, { begin: u, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      F,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + u,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [T]
      },
      $,
      H,
      D,
      G,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function Ht(n) {
  const e = {
    className: "attr",
    begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
    relevance: 1.01
  }, o = {
    match: /[{}[\],:]/,
    className: "punctuation",
    relevance: 0
  }, u = [
    "true",
    "false",
    "null"
  ], g = {
    scope: "literal",
    beginKeywords: u.join(" ")
  };
  return {
    name: "JSON",
    keywords: {
      literal: u
    },
    contains: [
      e,
      o,
      n.QUOTE_STRING_MODE,
      g,
      n.C_NUMBER_MODE,
      n.C_LINE_COMMENT_MODE,
      n.C_BLOCK_COMMENT_MODE
    ],
    illegal: "\\S"
  };
}
function Ft(n) {
  const e = "true false yes no null", o = "[\\w#;/?:@&=+$,.~*'()[\\]]+", u = {
    className: "attr",
    variants: [
      { begin: "\\w[\\w :\\/.-]*:(?=[ 	]|$)" },
      {
        // double quoted keys
        begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)'
      },
      {
        // single quoted keys
        begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)"
      }
    ]
  }, g = {
    className: "template-variable",
    variants: [
      {
        // jinja templates Ansible
        begin: /\{\{/,
        end: /\}\}/
      },
      {
        // Ruby i18n
        begin: /%\{/,
        end: /\}/
      }
    ]
  }, t = {
    className: "string",
    relevance: 0,
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      { begin: /\S+/ }
    ],
    contains: [
      n.BACKSLASH_ESCAPE,
      g
    ]
  }, r = n.inherit(t, { variants: [
    {
      begin: /'/,
      end: /'/
    },
    {
      begin: /"/,
      end: /"/
    },
    { begin: /[^\s,{}[\]]+/ }
  ] }), i = "[0-9]{4}(-[0-9][0-9]){0,2}", s = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?", a = "(\\.[0-9]*)?", l = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?", c = {
    className: "number",
    begin: "\\b" + i + s + a + l + "\\b"
  }, f = {
    end: ",",
    endsWithParent: !0,
    excludeEnd: !0,
    keywords: e,
    relevance: 0
  }, h = {
    begin: /\{/,
    end: /\}/,
    contains: [f],
    illegal: "\\n",
    relevance: 0
  }, d = {
    begin: "\\[",
    end: "\\]",
    contains: [f],
    illegal: "\\n",
    relevance: 0
  }, p = [
    u,
    {
      className: "meta",
      begin: "^---\\s*$",
      relevance: 10
    },
    {
      // multi line string
      // Blocks start with a | or > followed by a newline
      //
      // Indentation of subsequent lines must be the same to
      // be considered part of the block
      className: "string",
      begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
    },
    {
      // Ruby/Rails erb
      begin: "<%[%=-]?",
      end: "[%-]?%>",
      subLanguage: "ruby",
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0
    },
    {
      // named tags
      className: "type",
      begin: "!\\w+!" + o
    },
    // https://yaml.org/spec/1.2/spec.html#id2784064
    {
      // verbatim tags
      className: "type",
      begin: "!<" + o + ">"
    },
    {
      // primary tags
      className: "type",
      begin: "!" + o
    },
    {
      // secondary tags
      className: "type",
      begin: "!!" + o
    },
    {
      // fragment id &ref
      className: "meta",
      begin: "&" + n.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // fragment reference *ref
      className: "meta",
      begin: "\\*" + n.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // array listing
      className: "bullet",
      // TODO: remove |$ hack when we have proper look-ahead support
      begin: "-(?=[ ]|$)",
      relevance: 0
    },
    n.HASH_COMMENT_MODE,
    {
      beginKeywords: e,
      keywords: { literal: e }
    },
    c,
    // numbers are any valid C-style number that
    // sit isolated from other words
    {
      className: "number",
      begin: n.C_NUMBER_RE + "\\b",
      relevance: 0
    },
    h,
    d,
    t
  ], _ = [...p];
  return _.pop(), _.push(r), f.contains = _, {
    name: "YAML",
    case_insensitive: !0,
    aliases: ["yml"],
    contains: p
  };
}
function zt(n) {
  return {
    name: "Plain text",
    aliases: [
      "text",
      "txt"
    ],
    disableAutodetect: !0
  };
}
function Gt(n) {
  const e = n.regex, o = /[\p{XID_Start}_]\p{XID_Continue}*/u, u = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], i = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: u,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, s = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, a = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: i,
    illegal: /#/
  }, l = {
    begin: /\{\{/,
    relevance: 0
  }, c = {
    className: "string",
    contains: [n.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          s
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          s
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          s,
          l,
          a
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          s,
          l,
          a
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          n.BACKSLASH_ESCAPE,
          l,
          a
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          n.BACKSLASH_ESCAPE,
          l,
          a
        ]
      },
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE
    ]
  }, f = "[0-9](_?[0-9])*", h = `(\\b(${f}))?\\.(${f})|\\b(${f})\\.`, d = `\\b|${u.join("|")}`, p = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${f})|(${h}))[eE][+-]?(${f})[jJ]?(?=${d})`
      },
      {
        begin: `(${h})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${d})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${d})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${d})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${d})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${f})[jJ](?=${d})`
      }
    ]
  }, _ = {
    className: "comment",
    begin: e.lookahead(/# type:/),
    end: /$/,
    keywords: i,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, v = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: i,
        contains: [
          "self",
          s,
          p,
          c,
          n.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return a.contains = [
    c,
    p,
    s
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: i,
    illegal: /(<\/|->|\?)|=>/,
    contains: [
      s,
      p,
      {
        // very common convention
        begin: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      c,
      _,
      n.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          o
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [v]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              o,
              /\s*/,
              /\(\s*/,
              o,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              o
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          p,
          v,
          c
        ]
      }
    ]
  };
}
var oe = "[0-9](_*[0-9])*", we = `\\.(${oe})`, Ne = "[0-9a-fA-F](_*[0-9a-fA-F])*", nn = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${oe})((${we})|\\.)?|(${we}))[eE][+-]?(${oe})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${oe})((${we})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${we})[fFdD]?\\b` },
    { begin: `\\b(${oe})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${Ne})\\.?|(${Ne})?\\.(${Ne}))[pP][+-]?(${oe})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${Ne})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function bn(n, e, o) {
  return o === -1 ? "" : n.replace(e, (u) => bn(n, e, o - 1));
}
function Kt(n) {
  const e = n.regex, o = "[-a-zA-Z_$][-a-zA-Z_$0-9]*", u = o + bn("(?:<" + o + "~~~(?:\\s*,\\s*" + o + "~~~)*>)?", /~~~/g, 2), s = {
    keyword: [
      "synchronized",
      "abstract",
      "private",
      "var",
      "static",
      "if",
      "const ",
      "for",
      "while",
      "strictfp",
      "finally",
      "protected",
      "import",
      "native",
      "final",
      "void",
      "enum",
      "else",
      "break",
      "transient",
      "catch",
      "instanceof",
      "volatile",
      "case",
      "assert",
      "package",
      "default",
      "public",
      "try",
      "switch",
      "continue",
      "throws",
      "protected",
      "public",
      "private",
      "module",
      "requires",
      "exports",
      "do",
      "sealed",
      "yield",
      "permits"
    ],
    literal: [
      "false",
      "true",
      "null"
    ],
    type: [
      "char",
      "boolean",
      "long",
      "float",
      "int",
      "byte",
      "short",
      "double"
    ],
    built_in: [
      "super",
      "this"
    ]
  }, a = {
    className: "meta",
    begin: "@" + o,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: ["self"]
        // allow nested () inside our annotation
      }
    ]
  }, l = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    keywords: s,
    relevance: 0,
    contains: [n.C_BLOCK_COMMENT_MODE],
    endsParent: !0
  };
  return {
    name: "Java",
    aliases: ["jsp"],
    keywords: s,
    illegal: /<\/|#/,
    contains: [
      n.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              // eat up @'s in emails to prevent them to be recognized as doctags
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      // relevance boost
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      n.C_LINE_COMMENT_MODE,
      n.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [n.BACKSLASH_ESCAPE]
      },
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          o
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        // Exceptions for hyphenated keywords
        match: /non-sealed/,
        scope: "keyword"
      },
      {
        begin: [
          e.concat(/(?!else)/, o),
          /\s+/,
          o,
          /\s+/,
          /=(?!=)/
        ],
        className: {
          1: "type",
          3: "variable",
          5: "operator"
        }
      },
      {
        begin: [
          /record/,
          /\s+/,
          o
        ],
        className: {
          1: "keyword",
          3: "title.class"
        },
        contains: [
          l,
          n.C_LINE_COMMENT_MODE,
          n.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new throw return else",
        relevance: 0
      },
      {
        begin: [
          "(?:" + u + "\\s+)",
          n.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: "title.function" },
        keywords: s,
        contains: [
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: s,
            relevance: 0,
            contains: [
              a,
              n.APOS_STRING_MODE,
              n.QUOTE_STRING_MODE,
              nn,
              n.C_BLOCK_COMMENT_MODE
            ]
          },
          n.C_LINE_COMMENT_MODE,
          n.C_BLOCK_COMMENT_MODE
        ]
      },
      nn,
      a
    ]
  };
}
function Wt(n) {
  const e = n.regex, o = {}, u = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [o]
      }
      // default values
    ]
  };
  Object.assign(o, {
    className: "variable",
    variants: [
      { begin: e.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      u
    ]
  });
  const g = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [n.BACKSLASH_ESCAPE]
  }, t = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      n.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, r = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      n.BACKSLASH_ESCAPE,
      o,
      g
    ]
  };
  g.contains.push(r);
  const i = {
    className: "",
    begin: /\\"/
  }, s = {
    className: "string",
    begin: /'/,
    end: /'/
  }, a = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      n.NUMBER_MODE,
      o
    ]
  }, l = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], c = n.SHEBANG({
    binary: `(${l.join("|")})`,
    relevance: 10
  }), f = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [n.inherit(n.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, h = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function"
  ], d = [
    "true",
    "false"
  ], p = { match: /(\/[a-z._-]+)+/ }, _ = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], v = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], E = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], w = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: h,
      literal: d,
      built_in: [
        ..._,
        ...v,
        // Shell modifiers
        "set",
        "shopt",
        ...E,
        ...w
      ]
    },
    contains: [
      c,
      // to catch known shells and boost relevancy
      n.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      f,
      a,
      n.HASH_COMMENT_MODE,
      t,
      p,
      r,
      i,
      s,
      o
    ]
  };
}
function Qt(n) {
  const e = n.regex, o = n.COMMENT("--", "$"), u = {
    className: "string",
    variants: [
      {
        begin: /'/,
        end: /'/,
        contains: [{ begin: /''/ }]
      }
    ]
  }, g = {
    begin: /"/,
    end: /"/,
    contains: [{ begin: /""/ }]
  }, t = [
    "true",
    "false",
    // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
    // "null",
    "unknown"
  ], r = [
    "double precision",
    "large object",
    "with timezone",
    "without timezone"
  ], i = [
    "bigint",
    "binary",
    "blob",
    "boolean",
    "char",
    "character",
    "clob",
    "date",
    "dec",
    "decfloat",
    "decimal",
    "float",
    "int",
    "integer",
    "interval",
    "nchar",
    "nclob",
    "national",
    "numeric",
    "real",
    "row",
    "smallint",
    "time",
    "timestamp",
    "varchar",
    "varying",
    // modifier (character varying)
    "varbinary"
  ], s = [
    "add",
    "asc",
    "collation",
    "desc",
    "final",
    "first",
    "last",
    "view"
  ], a = [
    "abs",
    "acos",
    "all",
    "allocate",
    "alter",
    "and",
    "any",
    "are",
    "array",
    "array_agg",
    "array_max_cardinality",
    "as",
    "asensitive",
    "asin",
    "asymmetric",
    "at",
    "atan",
    "atomic",
    "authorization",
    "avg",
    "begin",
    "begin_frame",
    "begin_partition",
    "between",
    "bigint",
    "binary",
    "blob",
    "boolean",
    "both",
    "by",
    "call",
    "called",
    "cardinality",
    "cascaded",
    "case",
    "cast",
    "ceil",
    "ceiling",
    "char",
    "char_length",
    "character",
    "character_length",
    "check",
    "classifier",
    "clob",
    "close",
    "coalesce",
    "collate",
    "collect",
    "column",
    "commit",
    "condition",
    "connect",
    "constraint",
    "contains",
    "convert",
    "copy",
    "corr",
    "corresponding",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "create",
    "cross",
    "cube",
    "cume_dist",
    "current",
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_row",
    "current_schema",
    "current_time",
    "current_timestamp",
    "current_path",
    "current_role",
    "current_transform_group_for_type",
    "current_user",
    "cursor",
    "cycle",
    "date",
    "day",
    "deallocate",
    "dec",
    "decimal",
    "decfloat",
    "declare",
    "default",
    "define",
    "delete",
    "dense_rank",
    "deref",
    "describe",
    "deterministic",
    "disconnect",
    "distinct",
    "double",
    "drop",
    "dynamic",
    "each",
    "element",
    "else",
    "empty",
    "end",
    "end_frame",
    "end_partition",
    "end-exec",
    "equals",
    "escape",
    "every",
    "except",
    "exec",
    "execute",
    "exists",
    "exp",
    "external",
    "extract",
    "false",
    "fetch",
    "filter",
    "first_value",
    "float",
    "floor",
    "for",
    "foreign",
    "frame_row",
    "free",
    "from",
    "full",
    "function",
    "fusion",
    "get",
    "global",
    "grant",
    "group",
    "grouping",
    "groups",
    "having",
    "hold",
    "hour",
    "identity",
    "in",
    "indicator",
    "initial",
    "inner",
    "inout",
    "insensitive",
    "insert",
    "int",
    "integer",
    "intersect",
    "intersection",
    "interval",
    "into",
    "is",
    "join",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "language",
    "large",
    "last_value",
    "lateral",
    "lead",
    "leading",
    "left",
    "like",
    "like_regex",
    "listagg",
    "ln",
    "local",
    "localtime",
    "localtimestamp",
    "log",
    "log10",
    "lower",
    "match",
    "match_number",
    "match_recognize",
    "matches",
    "max",
    "member",
    "merge",
    "method",
    "min",
    "minute",
    "mod",
    "modifies",
    "module",
    "month",
    "multiset",
    "national",
    "natural",
    "nchar",
    "nclob",
    "new",
    "no",
    "none",
    "normalize",
    "not",
    "nth_value",
    "ntile",
    "null",
    "nullif",
    "numeric",
    "octet_length",
    "occurrences_regex",
    "of",
    "offset",
    "old",
    "omit",
    "on",
    "one",
    "only",
    "open",
    "or",
    "order",
    "out",
    "outer",
    "over",
    "overlaps",
    "overlay",
    "parameter",
    "partition",
    "pattern",
    "per",
    "percent",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "period",
    "portion",
    "position",
    "position_regex",
    "power",
    "precedes",
    "precision",
    "prepare",
    "primary",
    "procedure",
    "ptf",
    "range",
    "rank",
    "reads",
    "real",
    "recursive",
    "ref",
    "references",
    "referencing",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "release",
    "result",
    "return",
    "returns",
    "revoke",
    "right",
    "rollback",
    "rollup",
    "row",
    "row_number",
    "rows",
    "running",
    "savepoint",
    "scope",
    "scroll",
    "search",
    "second",
    "seek",
    "select",
    "sensitive",
    "session_user",
    "set",
    "show",
    "similar",
    "sin",
    "sinh",
    "skip",
    "smallint",
    "some",
    "specific",
    "specifictype",
    "sql",
    "sqlexception",
    "sqlstate",
    "sqlwarning",
    "sqrt",
    "start",
    "static",
    "stddev_pop",
    "stddev_samp",
    "submultiset",
    "subset",
    "substring",
    "substring_regex",
    "succeeds",
    "sum",
    "symmetric",
    "system",
    "system_time",
    "system_user",
    "table",
    "tablesample",
    "tan",
    "tanh",
    "then",
    "time",
    "timestamp",
    "timezone_hour",
    "timezone_minute",
    "to",
    "trailing",
    "translate",
    "translate_regex",
    "translation",
    "treat",
    "trigger",
    "trim",
    "trim_array",
    "true",
    "truncate",
    "uescape",
    "union",
    "unique",
    "unknown",
    "unnest",
    "update",
    "upper",
    "user",
    "using",
    "value",
    "values",
    "value_of",
    "var_pop",
    "var_samp",
    "varbinary",
    "varchar",
    "varying",
    "versioning",
    "when",
    "whenever",
    "where",
    "width_bucket",
    "window",
    "with",
    "within",
    "without",
    "year"
  ], l = [
    "abs",
    "acos",
    "array_agg",
    "asin",
    "atan",
    "avg",
    "cast",
    "ceil",
    "ceiling",
    "coalesce",
    "corr",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "cume_dist",
    "dense_rank",
    "deref",
    "element",
    "exp",
    "extract",
    "first_value",
    "floor",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "last_value",
    "lead",
    "listagg",
    "ln",
    "log",
    "log10",
    "lower",
    "max",
    "min",
    "mod",
    "nth_value",
    "ntile",
    "nullif",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "position",
    "position_regex",
    "power",
    "rank",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "row_number",
    "sin",
    "sinh",
    "sqrt",
    "stddev_pop",
    "stddev_samp",
    "substring",
    "substring_regex",
    "sum",
    "tan",
    "tanh",
    "translate",
    "translate_regex",
    "treat",
    "trim",
    "trim_array",
    "unnest",
    "upper",
    "value_of",
    "var_pop",
    "var_samp",
    "width_bucket"
  ], c = [
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_schema",
    "current_transform_group_for_type",
    "current_user",
    "session_user",
    "system_time",
    "system_user",
    "current_time",
    "localtime",
    "current_timestamp",
    "localtimestamp"
  ], f = [
    "create table",
    "insert into",
    "primary key",
    "foreign key",
    "not null",
    "alter table",
    "add constraint",
    "grouping sets",
    "on overflow",
    "character set",
    "respect nulls",
    "ignore nulls",
    "nulls first",
    "nulls last",
    "depth first",
    "breadth first"
  ], h = l, d = [
    ...a,
    ...s
  ].filter((w) => !l.includes(w)), p = {
    className: "variable",
    begin: /@[a-z0-9]+/
  }, _ = {
    className: "operator",
    begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
    relevance: 0
  }, v = {
    begin: e.concat(/\b/, e.either(...h), /\s*\(/),
    relevance: 0,
    keywords: { built_in: h }
  };
  function E(w, {
    exceptions: m,
    when: T
  } = {}) {
    const D = T;
    return m = m || [], w.map((M) => M.match(/\|\d+$/) || m.includes(M) ? M : D(M) ? `${M}|0` : M);
  }
  return {
    name: "SQL",
    case_insensitive: !0,
    // does not include {} or HTML tags `</`
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword: E(d, { when: (w) => w.length < 3 }),
      literal: t,
      type: i,
      built_in: c
    },
    contains: [
      {
        begin: e.either(...f),
        relevance: 0,
        keywords: {
          $pattern: /[\w\.]+/,
          keyword: d.concat(f),
          literal: t,
          type: i
        }
      },
      {
        className: "type",
        begin: e.either(...r)
      },
      v,
      p,
      u,
      g,
      n.C_NUMBER_MODE,
      n.C_BLOCK_COMMENT_MODE,
      o,
      _
    ]
  };
}
Z.registerLanguage("xml", kt);
Z.registerLanguage("javascript", xt);
Z.registerLanguage("json", Ht);
Z.registerLanguage("yaml", Ft);
Z.registerLanguage("plaintext", zt);
Z.registerLanguage("python", Gt);
Z.registerLanguage("java", Kt);
Z.registerLanguage("bash", Wt);
Z.registerLanguage("sql", Qt);
var S = /* @__PURE__ */ ((n) => (n.EQUAL = "equal", n.DELETE = "removed", n.ADD = "added", n.EMPTY = "empty", n))(S || {});
const j = "<code-diff-modified>", J = "</code-diff-modified>", Vt = j.replace("<", "&lt;").replace(">", "&gt;"), Zt = J.replace("<", "&lt;").replace(">", "&gt;"), le = (n) => n === void 0 ? S.EQUAL : n.added ? S.ADD : n.removed ? S.DELETE : S.EQUAL, Te = (n, e, o = "word") => typeof n == "undefined" ? e : typeof e == "undefined" ? n : (o === "char" ? In : Bn)(n, e).filter((g) => le(g) !== S.DELETE).map(
  (g) => le(g) === S.ADD ? `${j}${g.value}${J}` : g.value
).join("");
function vn(n, e) {
  const o = new ce.diff_match_patch(), u = o.diff_linesToChars_(n, e), g = u.chars1, t = u.chars2, r = u.lineArray, i = o.diff_main(g, t, !1);
  return o.diff_charsToLines_(i, r), i.map((s) => {
    const [a, l] = s;
    return {
      count: l.trim().split(`
`).length,
      value: l,
      removed: a === ce.DIFF_DELETE,
      added: a === ce.DIFF_INSERT
    };
  });
}
const V = (n, e) => {
  if (!e.match(new RegExp(`(${j}|${J})`, "g")))
    return Z.highlight(e, { language: n }).value;
  let u = e;
  const g = e.replace(new RegExp(`(${j}|${J})`, "g"), ""), t = document.createElement("div");
  t.innerHTML = Z.highlight(g, { language: n }).value;
  let r = !1;
  const i = (s) => {
    s.childNodes.forEach((a) => {
      if (a.nodeType === Node.ELEMENT_NODE && i(a), a.nodeType === Node.TEXT_NODE) {
        if (!a.textContent)
          return;
        let l = a.textContent, c = "";
        for (r && (c = c + j); l.length; ) {
          if (u.startsWith(j)) {
            u = u.slice(j.length), c = c + j, r = !0;
            continue;
          }
          if (u.startsWith(J)) {
            u = u.slice(J.length), c = c + J, r = !1;
            continue;
          }
          const f = u.match(new RegExp(`(${j}|${J})`)), h = f && f.index ? f.index : u.length, d = Math.min(h, l.length);
          c = c + u.substring(0, d), u = u.slice(d), l = l.slice(d);
        }
        r && (c = c + J), a.textContent = c;
      }
    });
  };
  return i(t), t.innerHTML.replace(new RegExp(Vt, "g"), '<span class="x">').replace(new RegExp(Zt, "g"), "</span>");
};
function En(n) {
  const e = (g, t) => (g.match(new RegExp(t, "g")) || []).length;
  let o = 0, u = 0;
  for (const g of n)
    g.added && (o += e(g.value.trim(), `
`) + 1), g.removed && (u += e(g.value.trim(), `
`) + 1);
  return { additionsNum: o, deletionsNum: u };
}
function Yt(n, e, o = "plaintext", u = "word", g = 10) {
  const t = () => ({ type: S.EMPTY }), r = (p, _, v) => ({ type: p, num: _, code: v }), i = vn(n, e);
  let s = 0, a = 0, l = !1;
  const c = [], f = {
    changes: c,
    collector: [],
    stat: En(i)
  };
  for (let p = 0; p < i.length; p++) {
    if (l) {
      l = !1;
      continue;
    }
    const [_, v] = [i[p], i[p + 1]], [E, w] = [le(_), le(v)], m = _.value.replace(/\n$/, "").split(`
`);
    if (v === void 0) {
      for (const D of m) {
        let M = t(), I = t();
        const R = V(o, D);
        E === S.EQUAL && (s++, a++, M = r(S.EQUAL, s, R), I = r(S.EQUAL, a, R)), E === S.DELETE && (s++, M = r(S.DELETE, s, R), I = t()), E === S.ADD && (a++, M = t(), I = r(S.ADD, a, R)), c.push({ left: M, right: I });
      }
      break;
    }
    if (E === S.EQUAL)
      for (const D of m) {
        s++, a++;
        const M = V(o, D);
        c.push({
          left: r(S.EQUAL, s, M),
          right: r(S.EQUAL, a, M)
        });
      }
    const T = v.value.replace(/\n$/, "").split(`
`);
    if (E === S.DELETE) {
      if (w === S.EQUAL)
        for (const D of m)
          s++, c.push({
            left: r(S.DELETE, s, V(o, D)),
            right: t()
          });
      if (w === S.ADD) {
        l = !0;
        const D = Math.max(_.count, v.count);
        for (let M = 0; M < D; M++) {
          M < _.count && s++, M < v.count && a++;
          const [I, R] = [m[M], T[M]], H = m.length === T.length ? Te(R, I, u) : I, U = m.length === T.length ? Te(I, R, u) : R, $ = M < _.count ? r(S.DELETE, s, V(o, H)) : t(), F = M < v.count ? r(S.ADD, a, V(o, U)) : t();
          c.push({ left: $, right: F });
        }
      }
    }
    if (E === S.ADD)
      for (const D of m)
        a++, c.push({
          left: t(),
          right: r(S.ADD, a, V(o, D))
        });
  }
  if (n === e) {
    for (let p = 0; p < c.length; p++)
      c[p].fold = !1;
    return f;
  }
  for (let p = 0; p < c.length; p++) {
    const _ = c[p];
    if (_.left.type === S.DELETE || _.right.type === S.ADD) {
      const [v, E] = [Math.max(p - g, 0), Math.min(p + g + 1, c.length)];
      for (let w = v; w < E; w++)
        c[w].fold = !1;
    }
    _.fold === void 0 && (_.fold = !0);
  }
  const h = [];
  let d = [];
  for (let p = 0; p < c.length; p++) {
    const _ = c[p];
    if (_.fold === !1) {
      d.length && (d[0].hideIndex = f.collector.length, f.collector.push({
        lines: d,
        fold: !0
      }), d = []), h.push(_);
      continue;
    }
    _.hide = !0, d.push(_), h.push(_);
  }
  return d.length && (d[0].hideIndex = f.collector.length, f.collector.push({
    lines: d,
    fold: !0
  }), d = []), f.changes = h, f;
}
function Xt(n, e, o = "plaintext", u = "word", g = 10) {
  const t = vn(n, e);
  let r = 0, i = 0, s = !1;
  const a = [], l = {
    changes: a,
    collector: [],
    stat: En(t)
  };
  for (let h = 0; h < t.length; h++) {
    if (s) {
      s = !1;
      continue;
    }
    const [d, p] = [t[h], t[h + 1]], [_, v] = [le(d), le(p)], E = d.value.replace(/\n$/, "").split(`
`);
    if (p === void 0) {
      for (const m of E) {
        _ === S.EQUAL && (r++, i++), _ === S.DELETE && r++, _ === S.ADD && i++;
        const T = V(o, m);
        a.push({
          type: _,
          code: T,
          addNum: _ === S.DELETE ? void 0 : i,
          delNum: _ === S.ADD ? void 0 : r
        });
      }
      break;
    }
    if (_ === S.EQUAL)
      for (const m of E) {
        r++, i++;
        const T = V(o, m);
        a.push({ type: S.EQUAL, code: T, delNum: r, addNum: i });
      }
    const w = p.value.replace(/\n$/, "").split(`
`);
    if (_ === S.DELETE)
      if (v === S.ADD && E.length === w.length) {
        for (let m = 0; m < E.length; m++) {
          const T = E[m], D = w[m];
          r++;
          const M = V(o, Te(D, T, u));
          a.push({ type: S.DELETE, code: M, delNum: r });
        }
        for (let m = 0; m < w.length; m++) {
          const T = E[m], D = w[m];
          i++;
          const M = V(o, Te(T, D, u));
          a.push({ type: S.ADD, code: M, addNum: i });
        }
        s = !0;
      } else
        for (const m of E) {
          r++;
          const T = V(o, m);
          a.push({ type: S.DELETE, code: T, delNum: r });
        }
    if (_ === S.ADD)
      for (const m of E) {
        i++;
        const T = V(o, m);
        a.push({ type: S.ADD, code: T, addNum: i });
      }
  }
  for (let h = 0; h < a.length; h++) {
    const d = a[h];
    if (d.type === S.DELETE || d.type === S.ADD) {
      const [p, _] = [Math.max(h - g, 0), Math.min(h + g + 1, a.length)];
      for (let v = p; v < _; v++)
        a[v].fold = !1;
    }
    d.fold === void 0 && (d.fold = !0);
  }
  if (n === e) {
    for (let h = 0; h < a.length; h++)
      a[h].fold = !1;
    return l;
  }
  const c = [];
  let f = [];
  for (let h = 0; h < a.length; h++) {
    const d = a[h];
    if (d.fold === !1) {
      f.length && (f[0].hideIndex = l.collector.length, l.collector.push({
        lines: f,
        fold: !0
      }), f = []), c.push(d);
      continue;
    }
    d.type === "equal" && (d.hide = !0, f.push(d)), c.push(d);
  }
  return f.length && (f[0].hideIndex = l.collector.length, l.collector.push({
    lines: f,
    fold: !0
  }), f = []), l.changes = c, l;
}
const jt = /* @__PURE__ */ de({
  __name: "UnifiedLine",
  props: {
    line: null
  },
  emits: ["expand"],
  setup(n, { emit: e }) {
    return { __sfc: !0, props: n, emit: e, getCodeMarker: (g) => g === S.DELETE ? "-" : g === S.ADD ? "+" : "", DiffType: S };
  }
});
function pe(n, e, o, u, g, t, r, i) {
  var s = typeof n == "function" ? n.options : n;
  e && (s.render = e, s.staticRenderFns = o, s._compiled = !0), u && (s.functional = !0), t && (s._scopeId = "data-v-" + t);
  var a;
  if (r ? (a = function(f) {
    f = f || // cached call
    this.$vnode && this.$vnode.ssrContext || // stateful
    this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, !f && typeof __VUE_SSR_CONTEXT__ != "undefined" && (f = __VUE_SSR_CONTEXT__), g && g.call(this, f), f && f._registeredComponents && f._registeredComponents.add(r);
  }, s._ssrRegister = a) : g && (a = i ? function() {
    g.call(
      this,
      (s.functional ? this.parent : this).$root.$options.shadowRoot
    );
  } : g), a)
    if (s.functional) {
      s._injectStyles = a;
      var l = s.render;
      s.render = function(h, d) {
        return a.call(d), l(h, d);
      };
    } else {
      var c = s.beforeCreate;
      s.beforeCreate = c ? [].concat(c, a) : [a];
    }
  return {
    exports: n,
    options: s
  };
}
var Jt = function() {
  var e = this, o = e._self._c, u = e._self._setupProxy;
  return e.line.hideIndex !== void 0 && e.line.hide ? o("tr", [o("td", { staticClass: "blob-num blob-num-hunk text-center", attrs: { colspan: "2" }, on: { click: function(g) {
    return u.emit("expand", e.line);
  } } }, [e._v(" > ")]), o("td", { staticClass: "blob-code blob-code-hunk", attrs: { align: "left" } }, [e._v("  ")])]) : e.line.hide ? e._e() : o("tr", [o("td", { staticClass: "blob-num", class: {
    "blob-num-deletion": e.line.type === u.DiffType.DELETE,
    "blob-num-addition": e.line.type === u.DiffType.ADD,
    "blob-num-context": e.line.type === u.DiffType.EQUAL,
    "blob-num-hunk": e.line.hide !== void 0
  } }, [e._v(" " + e._s(e.line.delNum) + " ")]), o("td", { staticClass: "blob-num", class: {
    "blob-num-deletion": e.line.type === u.DiffType.DELETE,
    "blob-num-addition": e.line.type === u.DiffType.ADD,
    "blob-num-context": e.line.type === u.DiffType.EQUAL,
    "blob-num-hunk": e.line.hide !== void 0
  } }, [e._v(" " + e._s(e.line.addNum) + " ")]), o("td", { staticClass: "blob-code", class: {
    "blob-code-deletion": e.line.type === u.DiffType.DELETE,
    "blob-code-addition": e.line.type === u.DiffType.ADD,
    "blob-code-context": e.line.type === u.DiffType.EQUAL,
    "blob-code-hunk": e.line.hide !== void 0
  } }, [o("span", { staticClass: "blob-code-inner blob-code-marker", attrs: { "data-code-marker": u.getCodeMarker(e.line.type) }, domProps: { innerHTML: e._s(e.line.code) } })])]);
}, qt = [], er = /* @__PURE__ */ pe(
  jt,
  Jt,
  qt,
  !1,
  null,
  null,
  null,
  null
);
const nr = er.exports, tr = /* @__PURE__ */ de({
  __name: "UnifiedViewer",
  props: {
    diffChange: null
  },
  setup(n) {
    const e = n;
    function o({ hideIndex: u }) {
      u !== void 0 && e.diffChange.collector[u].lines.forEach((g) => {
        g.hide = !1, g.fold = !1;
      });
    }
    return { __sfc: !0, props: e, expandHandler: o, UnifiedLine: nr };
  }
});
var rr = function() {
  var g;
  var e = this, o = e._self._c, u = e._self._setupProxy;
  return o("table", { staticClass: "diff-table" }, [o("tbody", e._l((g = e.diffChange) == null ? void 0 : g.changes, function(t, r) {
    return o(u.UnifiedLine, { key: r, attrs: { line: t }, on: { expand: u.expandHandler } });
  }), 1)]);
}, ir = [], sr = /* @__PURE__ */ pe(
  tr,
  rr,
  ir,
  !1,
  null,
  "238e1326",
  null,
  null
);
const ar = sr.exports, or = /* @__PURE__ */ de({
  __name: "SplitLine",
  props: {
    splitLine: null
  },
  emits: ["expand"],
  setup(n, { emit: e }) {
    return { __sfc: !0, props: n, emit: e, getCodeMarker: (g) => g === S.DELETE ? "-" : g === S.ADD ? "+" : "", DiffType: S };
  }
});
var lr = function() {
  var e = this, o = e._self._c, u = e._self._setupProxy;
  return e.splitLine.hideIndex !== void 0 && e.splitLine.hide ? o("tr", [o("td", { staticClass: "blob-num blob-num-hunk", attrs: { colspan: "1" }, on: { click: function(g) {
    return u.emit("expand", e.splitLine);
  } } }, [e._v(" > ")]), o("td", { staticClass: "blob-code blob-code-inner blob-code-hunk", attrs: { colspan: "3", align: "left" } }, [e._v("  ")])]) : e.splitLine.hide ? e._e() : o("tr", [e._l([e.splitLine.left, e.splitLine.right], function(g) {
    return [g.type === u.DiffType.EMPTY ? [o("td", { staticClass: "blob-num blob-num-empty empty-cell" }), o("td", { staticClass: "blob-code blob-code-empty empty-cell" })] : [o("td", { staticClass: "blob-num", class: {
      "blob-num-deletion": g.type === u.DiffType.DELETE,
      "blob-num-addition": g.type === u.DiffType.ADD,
      "blob-num-context": g.type === u.DiffType.EQUAL,
      "blob-num-hunk": e.splitLine.hide !== void 0
    } }, [e._v(" " + e._s(g.num) + " ")]), o("td", { staticClass: "blob-code", class: {
      "blob-code-deletion": g.type === u.DiffType.DELETE,
      "blob-code-addition": g.type === u.DiffType.ADD,
      "blob-code-context": g.type === u.DiffType.EQUAL,
      "blob-code-hunk": e.splitLine.hide !== void 0
    } }, [o("span", { staticClass: "blob-code-inner blob-code-marker", attrs: { "data-code-marker": u.getCodeMarker(g.type) }, domProps: { innerHTML: e._s(g.code) } })])]];
  })], 2);
}, cr = [], ur = /* @__PURE__ */ pe(
  or,
  lr,
  cr,
  !1,
  null,
  null,
  null,
  null
);
const fr = ur.exports, gr = /* @__PURE__ */ de({
  __name: "SplitViewer",
  props: {
    diffChange: null
  },
  setup(n) {
    const e = n;
    function o({ hideIndex: u }) {
      u !== void 0 && e.diffChange.collector[u].lines.forEach((g) => {
        g.hide = !1, g.fold = !1;
      });
    }
    return { __sfc: !0, props: e, expandHandler: o, SplitLine: fr };
  }
});
var hr = function() {
  var g;
  var e = this, o = e._self._c, u = e._self._setupProxy;
  return o("table", { staticClass: "file-diff-split diff-table" }, [e._m(0), o("tbody", e._l((g = e.diffChange) == null ? void 0 : g.changes, function(t, r) {
    return o(u.SplitLine, { key: r, attrs: { "split-line": t }, on: { expand: u.expandHandler } });
  }), 1)]);
}, dr = [function() {
  var n = this, e = n._self._c;
  return n._self._setupProxy, e("colgroup", [e("col", { attrs: { width: "44" } }), e("col"), e("col", { attrs: { width: "44" } }), e("col")]);
}], pr = /* @__PURE__ */ pe(
  gr,
  hr,
  dr,
  !1,
  null,
  "829edc33",
  null,
  null
);
const _r = pr.exports;
const br = /* @__PURE__ */ de({
  __name: "CodeDiff",
  props: {
    newString: null,
    oldString: null,
    language: { default: "plaintext" },
    context: { default: 10 },
    diffStyle: { default: "word" },
    outputFormat: { default: "line-by-line" },
    trim: { type: Boolean, default: !1 },
    noDiffLineFeed: { type: Boolean, default: !1 },
    maxHeight: { default: void 0 },
    filename: { default: void 0 }
  },
  setup(n) {
    const e = n, o = me(() => e.outputFormat === "line-by-line"), u = me(() => {
      let i = e.oldString || "";
      return i = e.trim ? i.trim() : i, i = e.noDiffLineFeed ? i.replace(/(\r\n)/g, `
`) : i, i;
    }), g = me(() => {
      let i = e.newString || "";
      return i = e.trim ? i.trim() : i, i = e.noDiffLineFeed ? i.replace(/(\r\n)/g, `
`) : i, i;
    }), t = me(
      () => o.value ? Xt(u.value, g.value, e.language, e.diffStyle, e.context) : Yt(u.value, g.value, e.language, e.diffStyle, e.context)
    ), r = Sn(t.value);
    return Rn(() => e, () => {
      r.value = t.value;
    }, { deep: !0 }), { __sfc: !0, props: e, isUnifiedViewer: o, oldString: u, newString: g, raw: t, diffChange: r, UnifiedViewer: ar, SplitViewer: _r };
  }
});
var vr = function() {
  var e = this, o = e._self._c, u = e._self._setupProxy;
  return o("div", { staticClass: "code-diff-view", style: { maxHeight: e.maxHeight } }, [o("div", { staticClass: "file-header" }, [o("div", { staticClass: "file-info" }, [o("span", { staticClass: "filename" }, [e._v(e._s(e.filename))]), o("span", { staticClass: "diff-stat" }, [o("span", { staticClass: "diff-stat-added" }, [e._v("+" + e._s(u.diffChange.stat.additionsNum) + " additions")]), o("span", { staticClass: "diff-stat-deleted", staticStyle: { "margin-left": "8px" } }, [e._v("-" + e._s(u.diffChange.stat.deletionsNum) + " deletions")])])])]), u.isUnifiedViewer ? o(u.UnifiedViewer, { attrs: { "diff-change": u.diffChange } }) : o(u.SplitViewer, { attrs: { "diff-change": u.diffChange } })], 1);
}, Er = [], mr = /* @__PURE__ */ pe(
  br,
  vr,
  Er,
  !1,
  null,
  null,
  null,
  null
);
const yr = mr.exports, wr = (n) => {
  n.component("CodeDiff", yr);
}, Mr = {
  install: wr,
  hljs: Z
};
export {
  yr as CodeDiff,
  Mr as default
};
